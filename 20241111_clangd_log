```shell
V[15:12:23.765] <<< {"id":2016,"jsonrpc":"2.0","method":"textDocument/codeAction","params":{"context":{"diagnostics":[],"triggerKind":2},"range":{"end":{"character":28,"line":191},"start":{"character":28,"line":191}},"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:23.765] <-- textDocument/codeAction(2016)
V[15:12:23.766] ASTWorker running codeAction on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:23.766] --> reply:textDocument/codeAction(2016) 0 ms
V[15:12:23.766] >>> {"id":2016,"jsonrpc":"2.0","result":[]}

I[15:12:23.766] --> textDocument/clangd.fileStatus
V[15:12:23.766] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/init.cc"}}

V[15:12:27.118] <<< {"id":2017,"jsonrpc":"2.0","method":"shutdown"}

I[15:12:27.118] <-- shutdown(2017)
I[15:12:27.118] --> reply:shutdown(2017) 0 ms
V[15:12:27.118] >>> {"id":2017,"jsonrpc":"2.0","result":null}

V[15:12:27.144] <<< {"jsonrpc":"2.0","method":"exit"}

I[15:12:27.144] <-- exit
I[15:12:27.144] LSP finished, exiting with status 0
The flag `-cross-file-rename` is obsolete and ignored.
The flag `-clang-tidy-checks` is obsolete and ignored.
I[15:12:27.141] clangd version 18.1.3 (https://github.com/llvm/llvm-project c13b7485b87909fcf739f62cfa382b55407433c0)
I[15:12:27.141] Features: linux+grpc
I[15:12:27.141] PID: 1174083
I[15:12:27.141] Working directory: /root/code/nccl-trace
I[15:12:27.141] argv[0]: /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/bin/clangd
I[15:12:27.141] argv[1]: --log=verbose
I[15:12:27.141] argv[2]: --all-scopes-completion
I[15:12:27.141] argv[3]: --completion-style=bundled
I[15:12:27.141] argv[4]: --cross-file-rename
I[15:12:27.141] argv[5]: --header-insertion=iwyu
I[15:12:27.141] argv[6]: --header-insertion-decorators
I[15:12:27.141] argv[7]: --background-index
I[15:12:27.141] argv[8]: --clang-tidy
I[15:12:27.141] argv[9]: --clang-tidy-checks=cppcoreguidelines-*,performance-*,bugprone-*,portability-*,modernize-*,google-*
I[15:12:27.141] argv[10]: -j=12
I[15:12:27.141] argv[11]: --pch-storage=disk
I[15:12:27.141] argv[12]: --function-arg-placeholders=false
V[15:12:27.141] User config file is /root/.config/clangd/config.yaml
I[15:12:27.141] Starting LSP over stdin/stdout
V[15:12:27.146] <<< {"id":0,"jsonrpc":"2.0","method":"initialize","params":{"capabilities":{"general":{"markdown":{"parser":"marked","version":"1.1.0"},"positionEncodings":["utf-16"],"regularExpressions":{"engine":"ECMAScript","version":"ES2020"},"staleRequestSupport":{"cancel":true,"retryOnContentModified":["textDocument/semanticTokens/full","textDocument/semanticTokens/range","textDocument/semanticTokens/full/delta"]}},"notebookDocument":{"synchronization":{"dynamicRegistration":true,"executionSummarySupport":true}},"textDocument":{"callHierarchy":{"dynamicRegistration":true},"codeAction":{"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}},"dataSupport":true,"disabledSupport":true,"dynamicRegistration":true,"honorsChangeAnnotations":false,"isPreferredSupport":true,"resolveSupport":{"properties":["edit"]}},"codeLens":{"dynamicRegistration":true},"colorProvider":{"dynamicRegistration":true},"completion":{"completionItem":{"commitCharactersSupport":true,"deprecatedSupport":true,"documentationFormat":["markdown","plaintext"],"insertReplaceSupport":true,"insertTextModeSupport":{"valueSet":[1,2]},"labelDetailsSupport":true,"preselectSupport":true,"resolveSupport":{"properties":["documentation","detail","additionalTextEdits"]},"snippetSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]},"completionList":{"itemDefaults":["commitCharacters","editRange","insertTextFormat","insertTextMode"]},"contextSupport":true,"dynamicRegistration":true,"editsNearCursor":true,"insertTextMode":2},"declaration":{"dynamicRegistration":true,"linkSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"diagnostic":{"dynamicRegistration":true,"relatedDocumentSupport":false},"documentHighlight":{"dynamicRegistration":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"documentSymbol":{"dynamicRegistration":true,"hierarchicalDocumentSymbolSupport":true,"labelSupport":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"tagSupport":{"valueSet":[1]}},"foldingRange":{"dynamicRegistration":true,"foldingRange":{"collapsedText":false},"foldingRangeKind":{"valueSet":["comment","imports","region"]},"lineFoldingOnly":true,"rangeLimit":5000},"formatting":{"dynamicRegistration":true},"hover":{"contentFormat":["markdown","plaintext"],"dynamicRegistration":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"inactiveRegionsCapabilities":{"inactiveRegions":true},"inlayHint":{"dynamicRegistration":true,"resolveSupport":{"properties":["tooltip","textEdits","label.tooltip","label.location","label.command"]}},"inlineValue":{"dynamicRegistration":true},"linkedEditingRange":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"publishDiagnostics":{"codeDescriptionSupport":true,"dataSupport":true,"relatedInformation":true,"tagSupport":{"valueSet":[1,2]},"versionSupport":false},"rangeFormatting":{"dynamicRegistration":true},"references":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"honorsChangeAnnotations":true,"prepareSupport":true,"prepareSupportDefaultBehavior":1},"selectionRange":{"dynamicRegistration":true},"semanticTokens":{"augmentsSyntaxTokens":true,"dynamicRegistration":true,"formats":["relative"],"multilineTokenSupport":false,"overlappingTokenSupport":false,"requests":{"full":{"delta":true},"range":true},"serverCancelSupport":true,"tokenModifiers":["declaration","definition","readonly","static","deprecated","abstract","async","modification","documentation","defaultLibrary"],"tokenTypes":["namespace","type","class","enum","interface","struct","typeParameter","parameter","variable","property","enumMember","event","function","method","macro","keyword","modifier","comment","string","number","regexp","operator","decorator"]},"signatureHelp":{"contextSupport":true,"dynamicRegistration":true,"signatureInformation":{"activeParameterSupport":true,"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}}},"synchronization":{"didSave":true,"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"typeHierarchy":{"dynamicRegistration":true}},"window":{"showDocument":{"support":true},"showMessage":{"messageActionItem":{"additionalPropertiesSupport":true}},"workDoneProgress":true},"workspace":{"applyEdit":true,"codeLens":{"refreshSupport":true},"configuration":true,"diagnostics":{"refreshSupport":true},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true,"relativePatternSupport":true},"executeCommand":{"dynamicRegistration":true},"fileOperations":{"didCreate":true,"didDelete":true,"didRename":true,"dynamicRegistration":true,"willCreate":true,"willDelete":true,"willRename":true},"inlayHint":{"refreshSupport":true},"inlineValue":{"refreshSupport":true},"semanticTokens":{"refreshSupport":true},"symbol":{"dynamicRegistration":true,"resolveSupport":{"properties":["location.range"]},"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"tagSupport":{"valueSet":[1]}},"workspaceEdit":{"changeAnnotationSupport":{"groupsOnLabel":true},"documentChanges":true,"failureHandling":"textOnlyTransactional","normalizesLineEndings":true,"resourceOperations":["create","rename","delete"]},"workspaceFolders":true}},"clientInfo":{"name":"Visual Studio Code","version":"1.95.2"},"initializationOptions":{"clangdFileStatus":true,"fallbackFlags":[]},"locale":"zh-cn","processId":1172843,"rootPath":"/root/code/nccl-trace","rootUri":"file:///root/code/nccl-trace","trace":"off","workspaceFolders":[{"name":"nccl-trace","uri":"file:///root/code/nccl-trace"}]}}

I[15:12:27.146] <-- initialize(0)
I[15:12:27.148] --> reply:initialize(0) 1 ms
V[15:12:27.148] >>> {"id":0,"jsonrpc":"2.0","result":{"capabilities":{"astProvider":true,"callHierarchyProvider":true,"clangdInlayHintsProvider":true,"codeActionProvider":{"codeActionKinds":["quickfix","refactor","info"]},"compilationDatabase":{"automaticReload":true},"completionProvider":{"resolveProvider":false,"triggerCharacters":[".","<",">",":","\"","/","*"]},"declarationProvider":true,"definitionProvider":true,"documentFormattingProvider":true,"documentHighlightProvider":true,"documentLinkProvider":{"resolveProvider":false},"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n","moreTriggerCharacter":[]},"documentRangeFormattingProvider":true,"documentSymbolProvider":true,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]},"foldingRangeProvider":true,"hoverProvider":true,"implementationProvider":true,"inactiveRegionsProvider":true,"inlayHintProvider":true,"memoryUsageProvider":true,"referencesProvider":true,"renameProvider":{"prepareProvider":true},"selectionRangeProvider":true,"semanticTokensProvider":{"full":{"delta":true},"legend":{"tokenModifiers":["declaration","definition","deprecated","deduced","readonly","static","abstract","virtual","dependentName","defaultLibrary","usedAsMutableReference","usedAsMutablePointer","constructorOrDestructor","userDefined","functionScope","classScope","fileScope","globalScope"],"tokenTypes":["variable","variable","parameter","function","method","function","property","variable","class","interface","enum","enumMember","type","type","unknown","namespace","typeParameter","concept","type","macro","modifier","operator","bracket","label","comment"]},"range":false},"signatureHelpProvider":{"triggerCharacters":["(",")","{","}","<",">",","]},"standardTypeHierarchyProvider":true,"textDocumentSync":{"change":2,"openClose":true,"save":true},"typeDefinitionProvider":true,"typeHierarchyProvider":true,"workspaceSymbolProvider":true},"serverInfo":{"name":"clangd","version":"clangd version 18.1.3 (https://github.com/llvm/llvm-project c13b7485b87909fcf739f62cfa382b55407433c0) linux+grpc x86_64-unknown-linux-gnu"}}}

V[15:12:27.151] <<< {"jsonrpc":"2.0","method":"initialized","params":{}}

I[15:12:27.151] <-- initialized
V[15:12:27.183] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"/*************************************************************************\n * Copyright (c) 2015-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#include \"nccl.h\"\n#include \"channel.h\"\n#include \"nvmlwrap.h\"\n#include \"gdrwrap.h\"\n#include \"bootstrap.h\"\n#include \"transport.h\"\n#include \"group.h\"\n#include \"net.h\"\n#include \"coll_net.h\"\n#include \"enqueue.h\"\n#include \"graph.h\"\n#include \"argcheck.h\"\n#include \"tuner.h\"\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include \"param.h\"\n\n#include \"nccl_tp.h\"\n\n#define STR2(v) #v\n#define STR(v) STR2(v)\n\n#if CUDART_VERSION >= 9020\n#define NCCL_GROUP_CUDA_STREAM 0 // CGMD: CUDA 9.2,10.X Don't need to use an internal CUDA stream\n#else\n#define NCCL_GROUP_CUDA_STREAM 1 // CGMD: CUDA 9.0,9.1 Need to use an internal CUDA stream\n#endif\n\nconst char* ncclFuncStr[NCCL_NUM_FUNCTIONS] = { \"Broadcast\", \"Reduce\", \"AllGather\", \"ReduceScatter\", \"AllReduce\" };\nconst char* ncclAlgoStr[NCCL_NUM_ALGORITHMS] = { \"Tree\", \"Ring\", \"CollNetDirect\", \"CollNetChain\", \"NVLS\", \"NVLSTree\" };\nconst char* ncclProtoStr[NCCL_NUM_PROTOCOLS] = { \"LL\", \"LL128\", \"Simple\" };\n\nNCCL_PARAM(GroupCudaStream, \"GROUP_CUDA_STREAM\", NCCL_GROUP_CUDA_STREAM);\n\nNCCL_PARAM(CheckPointers, \"CHECK_POINTERS\", 0);\nNCCL_PARAM(CommBlocking, \"COMM_BLOCKING\", NCCL_CONFIG_UNDEF_INT);\n\nstatic ncclResult_t commReclaim(ncclComm_t comm);\n\nstatic uint64_t hashUniqueId(ncclUniqueId const &id) {\n  char const *bytes = (char const*)&id;\n  uint64_t h = 0xdeadbeef;\n  for(int i=0; i < (int)sizeof(ncclUniqueId); i++) {\n    h ^= h >> 32;\n    h *= 0x8db3db47fa2994ad;\n    h += bytes[i];\n  }\n  return h;\n}\n\n// GDRCOPY support: Off by default\nNCCL_PARAM(GdrCopyEnable, \"GDRCOPY_ENABLE\", 0);\n\n// GDRCOPY support\ngdr_t ncclGdrCopy = NULL;\n\nncclResult_t initGdrCopy() {\n  if (ncclParamGdrCopyEnable() == 1) {\n    ncclGdrCopy = ncclGdrInit();\n  }\n  return ncclSuccess;\n}\n\npthread_mutex_t initLock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool initialized = false;\n\nstatic ncclResult_t ncclInit() {\n  if (__atomic_load_n(&initialized, __ATOMIC_ACQUIRE)) return ncclSuccess;\n  pthread_mutex_lock(&initLock);\n  if (!initialized) {\n    initEnv();\n    initGdrCopy();\n    // Always initialize bootstrap network\n    NCCLCHECK(bootstrapNetInit());\n    NCCLCHECK(ncclNetPluginInit());\n\n    initNvtxRegisteredEnums();\n    __atomic_store_n(&initialized, true, __ATOMIC_RELEASE);\n  }\n  pthread_mutex_unlock(&initLock);\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclGetVersion, int* version);\nncclResult_t ncclGetVersion(int* version) {\n  if (version == NULL) return ncclInvalidArgument;\n  *version = NCCL_VERSION_CODE;\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclGetUniqueId, ncclUniqueId* out);\nncclResult_t ncclGetUniqueId(ncclUniqueId* out) {\n  NCCLCHECK(ncclInit());\n  NCCLCHECK(PtrCheck(out, \"GetUniqueId\", \"out\"));\n  ncclResult_t res = bootstrapGetUniqueId((struct ncclBootstrapHandle*)out);\n  TRACE_CALL(\"ncclGetUniqueId(0x%llx)\", (unsigned long long)hashUniqueId(*out));\n  return res;\n}\n\n// Prevent compiler from optimizing out these operations\n#ifdef __clang__\n#define NCCL_NO_OPTIMIZE __attribute__((optnone))\n#else\n#define NCCL_NO_OPTIMIZE __attribute__((optimize(\"O0\")))\n#endif\n\nvoid NCCL_NO_OPTIMIZE commPoison(ncclComm_t comm) {\n  // Important that this does not trash intraComm0.\n  comm->rank = comm->cudaDev = comm->busId = comm->nRanks = -1;\n  comm->startMagic = comm->endMagic = 0;\n}\n\n#undef NCCL_NO_OPTIMIZE\n\n\nstatic ncclResult_t ncclDestructorFnFree(struct ncclDestructor* dtor) {\n  free(dtor->obj);\n  return ncclSuccess;\n}\nvoid ncclCommPushFree(struct ncclComm* comm, void* obj) {\n  struct ncclDestructor* dtor = ncclMemoryStackAlloc<struct ncclDestructor>(&comm->memPermanent);\n  dtor->fn = ncclDestructorFnFree;\n  dtor->obj = obj;\n  dtor->next = comm->destructorHead;\n  comm->destructorHead = dtor;\n}\n\nstatic ncclResult_t ncclDestructorFnCudaFree(struct ncclDestructor* dtor) {\n  NCCLCHECK(ncclCudaFree(dtor->obj));\n  return ncclSuccess;\n}\nvoid ncclCommPushCudaFree(struct ncclComm* comm, void* obj) {\n  struct ncclDestructor* dtor = ncclMemoryStackAlloc<struct ncclDestructor>(&comm->memPermanent);\n  dtor->fn = ncclDestructorFnCudaFree;\n  dtor->obj = obj;\n  dtor->next = comm->destructorHead;\n  comm->destructorHead = dtor;\n}\n\nstatic ncclResult_t ncclDestructorFnCudaHostFree(struct ncclDestructor* dtor) {\n  CUDACHECK(cudaFreeHost(dtor->obj));\n  return ncclSuccess;\n}\nvoid ncclCommPushCudaHostFree(struct ncclComm* comm, void* obj) {\n  struct ncclDestructor* dtor = ncclMemoryStackAlloc<struct ncclDestructor>(&comm->memPermanent);\n  dtor->fn = ncclDestructorFnCudaHostFree;\n  dtor->obj = obj;\n  dtor->next = comm->destructorHead;\n  comm->destructorHead = dtor;\n}\n\nstatic ncclResult_t ncclDestructorFnCudaGdrFree(struct ncclDestructor* dtor) {\n  NCCLCHECK(ncclGdrCudaFree(dtor->obj));\n  return ncclSuccess;\n}\nvoid ncclCommPushCudaGdrFree(struct ncclComm* comm, void* handle) {\n  struct ncclDestructor* dtor = ncclMemoryStackAlloc<struct ncclDestructor>(&comm->memPermanent);\n  dtor->fn = ncclDestructorFnCudaGdrFree;\n  dtor->obj = handle;\n  dtor->next = comm->destructorHead;\n  comm->destructorHead = dtor;\n}\n\nstatic ncclResult_t commFree(ncclComm_t comm) {\n  /* commFree() should not involve any sync among ranks. */\n  if (comm == NULL)\n    return ncclSuccess;\n\n  /* in commReclaim, we have guaranteed only last rank which calls ncclCommDestroy() will\n   * free all intra-process communicators; therefore, we only need to focus on local\n   * resource cleanup in commFree(). */\n  if (comm->proxyState && comm->proxyRefCountOld == 0 && comm->proxyState->thread) {\n    pthread_join(comm->proxyState->thread, nullptr);\n    if (comm->proxyState->threadUDS) {\n      // UDS support\n      pthread_join(comm->proxyState->threadUDS, nullptr);;\n    }\n  }\n\n  delete[] comm->userRedOps;\n\n  free(comm->connectSend);\n  free(comm->connectRecv);\n\n  free(comm->peerInfo);\n  if (comm->topo)\n    ncclTopoFree(comm->topo);\n  if (comm->nodeRanks) {\n    for (int n=0; n<comm->nNodes; n++) free(comm->nodeRanks[n].localRankToRank);\n    free(comm->nodeRanks);\n  }\n  free(comm->rankToNode);\n  free(comm->rankToLocalRank);\n  free(comm->collNetHeads);\n\n  if (comm->bootstrap)\n    NCCLCHECK(bootstrapClose(comm->bootstrap));\n\n  for (int channel=0; channel<MAXCHANNELS; channel++)\n    NCCLCHECK(freeChannel(comm->channels+channel, comm->nRanks, 1, comm->localRanks));\n\n  if (comm->sharedRes) {\n    if (ncclAtomicRefCountDecrement(&comm->sharedRes->refCount) == 0) {\n      for (int c=0; c<MAXCHANNELS; c++) {\n        if (comm->sharedRes->peers[c]) free(comm->sharedRes->peers[c]);\n        if (comm->sharedRes->devPeers[c]) ncclCudaFree(comm->sharedRes->devPeers[c]);\n      }\n      free(comm->sharedRes->tpRankToLocalRank);\n      NCCLCHECK(ncclStrongStreamDestruct(&comm->sharedRes->hostStream));\n      NCCLCHECK(ncclStrongStreamDestruct(&comm->sharedRes->deviceStream));\n      NCCLCHECK(ncclProxyDestroy(comm));\n      free(comm->sharedRes);\n    }\n  }\n\n  if (comm->nvlsSupport) NCCLCHECK(ncclNvlsFree(comm));\n\n  struct ncclDestructor* dtor = comm->destructorHead;\n  while (dtor != nullptr) {\n    NCCLCHECK(dtor->fn(dtor));\n    dtor = dtor->next;\n  }\n\n  ncclMemoryStackDestruct(&comm->memScoped);\n  ncclMemoryStackDestruct(&comm->memPermanent);\n\n  if (ncclAtomicRefCountDecrement(comm->abortFlagRefCount) == 0) {\n    NCCLCHECK(ncclCudaHostFree((void *)comm->abortFlag));\n    free(comm->abortFlagRefCount);\n  }\n  free((void*)comm->config.netName);\n\n  free(comm->topParentRanks);\n  free(comm->topParentLocalRanks);\n\n  NCCLCHECK(ncclRegCleanup(comm));\n\n  commPoison(comm); // poison comm before free to avoid comm reuse.\n  free(comm);\n\n  return ncclSuccess;\n}\n\nNCCL_PARAM(DisableGraphHelper, \"GRAPH_HELPER_DISABLE\", 0);\n// GDRCOPY support: FIFO_ENABLE when enabled locates a workFifo in CUDA memory\nNCCL_PARAM(GdrCopyFifoEnable, \"GDRCOPY_FIFO_ENABLE\", 1);\nNCCL_PARAM(WorkFifoDepth, \"WORK_FIFO_DEPTH\", 64<<10);\nenum ncclLaunchMode ncclParamLaunchMode;\n\nNCCL_PARAM(DmaBufEnable, \"DMABUF_ENABLE\", 1);\n\n// Detect DMA-BUF support\nstatic ncclResult_t dmaBufSupported(struct ncclComm* comm) {\n  if (ncclParamDmaBufEnable() == 0 || comm->ncclNet->regMrDmaBuf == NULL || ncclCudaLibraryInit() != ncclSuccess) return ncclInternalError;\n#if CUDA_VERSION >= 11070\n  int flag = 0;\n  CUdevice dev;\n  int cudaDriverVersion;\n  CUDACHECK(cudaDriverGetVersion(&cudaDriverVersion));\n  if (CUPFN(cuDeviceGet) == NULL || cudaDriverVersion < 11070) return ncclInternalError;\n  CUCHECK(cuDeviceGet(&dev, comm->cudaDev));\n  // Query device to see if DMA-BUF support is available\n  (void) CUPFN(cuDeviceGetAttribute(&flag, CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED, dev));\n  if (flag == 0) return ncclInternalError;\n  INFO(NCCL_INIT, \"DMA-BUF is available on GPU device %d\", comm->cudaDev);\n  return ncclSuccess;\n#endif\n  return ncclInternalError;\n}\n\nncclResult_t ncclCommEnsureReady(ncclComm_t comm) {\n  /* comm must be ready, or error will be reported */\n  ncclResult_t ret = ncclSuccess;\n  if (__atomic_load_n(comm->abortFlag, __ATOMIC_RELAXED)) {\n    ncclGroupJobAbort(comm->groupJob);\n  } else {\n    NCCLCHECK(ncclCommGetAsyncError(comm, &ret));\n    if (ret != ncclSuccess) {\n      /* if ret is not ncclInProgress, we just keep it. */\n      WARN(\"Attempt to use communicator before the previous operation returned ncclSuccess\");\n      if (ret == ncclInProgress) ret = ncclInvalidArgument;\n      goto exit;\n    }\n    /* if there is linked group job, we should complete it. */\n    if (comm->groupJob) {\n      NCCLCHECK(ncclGroupJobComplete(comm->groupJob));\n      comm->groupJob = NULL;\n    }\n  }\n\nexit:\n  return ret;\n}\n\nstatic ncclResult_t commAlloc(struct ncclComm* comm, struct ncclComm* parent, int ndev, int rank) {\n  if (ndev < 1) {\n    WARN(\"invalid device count (%d) requested\", ndev);\n    return ncclInvalidArgument;\n  }\n  if (rank >= ndev || rank < 0) {\n    WARN(\"rank %d exceeds ndev=%d\", rank, ndev);\n    return ncclInvalidArgument;\n  }\n\n  ncclMemoryStackConstruct(&comm->memPermanent);\n  ncclMemoryStackConstruct(&comm->memScoped);\n  comm->destructorHead = nullptr;\n  comm->rank = rank;\n  comm->nRanks = ndev;\n\n  NCCLCHECK(ncclNetInit(comm));\n  INFO(NCCL_INIT, \"Using network %s\", comm->ncclNet->name);\n\n  if (parent && parent->config.splitShare) {\n    if (parent->ncclNet != comm->ncclNet) {\n      WARN(\"Split shares resources, but parent comm netName %s is different from child comm netName %s\", parent->ncclNet->name, comm->ncclNet->name);\n      return ncclInvalidUsage;\n    }\n  }\n  // Try to create a CUDA object right away. If there is something wrong with\n  // the device we're on (failure cause #1) , better know it early.\n  CUDACHECK(cudaGetDevice(&comm->cudaDev));\n\n  NCCLCHECK(getBusId(comm->cudaDev, &comm->busId));\n  nvmlDevice_t nvmlDev;\n  char busId[NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE];\n  NCCLCHECK(int64ToBusId(comm->busId, busId));\n  NCCLCHECK(ncclNvmlDeviceGetHandleByPciBusId(busId, &nvmlDev));\n  NCCLCHECK(ncclNvmlDeviceGetIndex(nvmlDev, (unsigned int*)&comm->nvmlDev));\n\n  comm->compCap = ncclCudaCompCap();\n  TRACE(NCCL_INIT,\"comm %p rank %d nranks %d cudaDev %d busId %lx compCap %d\", comm, rank, ndev, comm->cudaDev, comm->busId, comm->compCap);\n\n  comm->checkPointers = ncclParamCheckPointers() == 1 ? true : false;\n  comm->dmaBufSupport = (dmaBufSupported(comm) == ncclSuccess) ? true : false;\n\n  comm->collNetSupport = 0;\n  memset(comm->collNetSupportMatrix, 0, sizeof(comm->collNetSupportMatrix));\n\n  ncclMemoryPoolConstruct(&comm->memPool_ncclKernelPlan);\n  ncclMemoryPoolConstruct(&comm->memPool_ncclProxyOp);\n  ncclMemoryPoolConstruct(&comm->memPool_ncclPointerList);\n  ncclMemoryPoolConstruct(&comm->memPool_ncclNvlsHandleList);\n  ncclMemoryPoolConstruct(&comm->memPool_ncclCollnetHandleList);\n\n  comm->groupNext = reinterpret_cast<struct ncclComm*>(0x1);\n  comm->preconnectNext = reinterpret_cast<struct ncclComm*>(0x1);\n\n  static_assert(MAXCHANNELS <= sizeof(*comm->connectSend)*8, \"comm->connectSend must have enough bits for all channels\");\n  static_assert(MAXCHANNELS <= sizeof(*comm->connectRecv)*8, \"comm->connectRecv must have enough bits for all channels\");\n  NCCLCHECK(ncclCalloc(&comm->connectSend, comm->nRanks));\n  NCCLCHECK(ncclCalloc(&comm->connectRecv, comm->nRanks));\n\n  // Mark channels as non initialized.\n  for (int c=0; c < MAXCHANNELS; c++) comm->channels[c].id = -1;\n\n  if (parent == NULL || !parent->config.splitShare) {\n    struct ncclSharedResources* sharedRes = NULL;\n    NCCLCHECK(ncclCalloc(&sharedRes, 1));\n    /* most of attributes are assigned later in initTransportsRank(). */\n    sharedRes->owner = comm;\n    sharedRes->tpNRanks = comm->nRanks;\n    NCCLCHECK(ncclCalloc(&sharedRes->tpRankToLocalRank, comm->nRanks));\n    NCCLCHECK(ncclStrongStreamConstruct(&sharedRes->deviceStream));\n    NCCLCHECK(ncclStrongStreamConstruct(&sharedRes->hostStream));\n    comm->sharedRes = sharedRes;\n    sharedRes->refCount = 1;\n  } else {\n    comm->sharedRes = parent->sharedRes;\n    ncclAtomicRefCountIncrement(&parent->sharedRes->refCount);\n  }\n\n  if (comm->topParentRanks == NULL) {\n    NCCLCHECK(ncclCalloc(&comm->topParentRanks, comm->nRanks));\n    for (int i = 0; i < comm->nRanks; ++i)\n      comm->topParentRanks[i] = i;\n  }\n\n  ncclIntruQueueMpscConstruct(&comm->callbackQueue);\n\n  comm->regCache.pageSize = sysconf(_SC_PAGESIZE);\n  return ncclSuccess;\n}\n\nstatic ncclResult_t devCommSetup(ncclComm_t comm) {\n  ncclResult_t ret = ncclSuccess;\n  int nRanks = comm->nRanks;\n  struct ncclDevCommAndChannels tmpCommAndChans;\n  struct ncclDevCommAndChannels *devCommAndChans = NULL;\n\n  NCCLCHECKGOTO(ncclStrongStreamAcquireUncaptured(&comm->sharedRes->deviceStream), ret, fail);\n  NCCLCHECKGOTO(ncclCudaCallocAsync(&devCommAndChans, 1, comm->sharedRes->deviceStream.cudaStream), ret, fail);\n  ncclCommPushCudaFree(comm, devCommAndChans);\n  comm->devComm = &devCommAndChans->comm;\n  tmpCommAndChans.comm.rank = comm->rank;\n  tmpCommAndChans.comm.nRanks = nRanks;\n  tmpCommAndChans.comm.node = comm->node;\n  tmpCommAndChans.comm.nNodes = comm->nNodes;\n  tmpCommAndChans.comm.abortFlag = comm->abortFlag;\n  for (int p=0; p < NCCL_NUM_PROTOCOLS; p++) {\n    tmpCommAndChans.comm.buffSizes[p] = comm->buffSizes[p];\n  }\n  tmpCommAndChans.comm.p2pChunkSize = comm->p2pChunkSize;\n  tmpCommAndChans.comm.channels = &devCommAndChans->channels[0];\n\n  comm->workFifoDepth = ncclParamWorkFifoDepth();\n  if (0 != (comm->workFifoDepth & (comm->workFifoDepth-1))) {\n    WARN(\"NCCL_WORK_FIFO_DEPTH=%d is being ignored because it is not a power of 2.\", comm->workFifoDepth);\n    comm->workFifoDepth = 64<<10;\n  }\n  tmpCommAndChans.comm.workFifoDepth = comm->workFifoDepth;\n\n  if (ncclGdrCopy != NULL && ncclParamGdrCopyFifoEnable() == 1) {\n    // The workFifoHeap lives in GDR mapped CUDA memory.\n    NCCLCHECKGOTO(ncclGdrCudaCalloc(&comm->workFifoHeap, &comm->devWorkFifoHeap, comm->workFifoDepth, &comm->workFifoHeapGdrHandle), ret, fail);\n    ncclCommPushCudaGdrFree(comm, comm->workFifoHeapGdrHandle);\n  } else {\n    // The workFifoHeap lives in cudaHost memory.\n    comm->workFifoHeapGdrHandle = nullptr;\n    NCCLCHECKGOTO(ncclCudaHostCalloc(&comm->workFifoHeap, comm->workFifoDepth), ret, fail);\n    ncclCommPushCudaHostFree(comm, comm->workFifoHeap);\n    comm->devWorkFifoHeap = comm->workFifoHeap;\n  }\n  tmpCommAndChans.comm.workFifoHeap = comm->devWorkFifoHeap;\n\n  NCCLCHECKGOTO(ncclCudaHostCalloc(&comm->workFifoDone, MAXCHANNELS), ret, fail);\n  ncclCommPushCudaHostFree(comm, comm->workFifoDone);\n  comm->workFifoSent = 0;\n  comm->workFifoAckdMin = 0;\n\n  if (comm->collNetDenseToUserRank != nullptr) {\n    NCCLCHECKGOTO(ncclCudaCallocAsync(&tmpCommAndChans.comm.collNetDenseToUserRank, nRanks, comm->sharedRes->deviceStream.cudaStream), ret, fail);\n    ncclCommPushCudaFree(comm, tmpCommAndChans.comm.collNetDenseToUserRank);\n    NCCLCHECKGOTO(ncclCudaMemcpyAsync(tmpCommAndChans.comm.collNetDenseToUserRank, comm->collNetDenseToUserRank, nRanks, comm->sharedRes->deviceStream.cudaStream), ret, fail);\n  }\n\n  for (int c=0; c < MAXCHANNELS; c++) {\n    tmpCommAndChans.channels[c].peers = comm->channels[c].devPeers;\n    tmpCommAndChans.channels[c].ring = comm->channels[c].ring;\n    tmpCommAndChans.channels[c].ring.userRanks = comm->channels[c].devRingUserRanks;\n    tmpCommAndChans.channels[c].tree = comm->channels[c].tree;\n    tmpCommAndChans.channels[c].collnetChain = comm->channels[c].collnetChain;\n    tmpCommAndChans.channels[c].collnetDirect = comm->channels[c].collnetDirect;\n    tmpCommAndChans.channels[c].nvls = comm->channels[c].nvls;\n    tmpCommAndChans.channels[c].workFifoDone = &comm->workFifoDone[c];\n\n    if (comm->channels[c].ring.userRanks != nullptr) {\n      NCCLCHECKGOTO(ncclCudaMemcpyAsync(tmpCommAndChans.channels[c].ring.userRanks, comm->channels[c].ring.userRanks, nRanks, comm->sharedRes->deviceStream.cudaStream), ret, fail);\n    }\n  }\n\n  NCCLCHECKGOTO(ncclCudaMemcpyAsync(devCommAndChans, &tmpCommAndChans, 1, comm->sharedRes->deviceStream.cudaStream), ret, fail);\nexit:\n  NCCLCHECK(ncclStrongStreamSynchronize(&comm->sharedRes->deviceStream));\n  NCCLCHECK(ncclStrongStreamRelease(ncclCudaGraphNone(), &comm->sharedRes->deviceStream));\n  return ret;\nfail:\n  goto exit;\n}\n\n// Pre-process the string so that running \"strings\" on the lib can quickly reveal the version.\n#define VERSION_STRING \"NCCL version \" STR(NCCL_MAJOR) \".\" STR(NCCL_MINOR) \".\" STR(NCCL_PATCH) NCCL_SUFFIX \"+cuda\" STR(CUDA_MAJOR) \".\" STR(CUDA_MINOR)\nstatic void showVersion() {\n  static int shown = 0;\n  if (shown == 0 && ncclDebugLevel >= NCCL_LOG_VERSION) {\n    printf(\"%s\\n\", VERSION_STRING);\n    fflush(stdout);\n    if (ncclDebugFile != stdout)\n      INFO(NCCL_ALL,\"%s\", VERSION_STRING); // Also log NCCL version in one of the files\n    shown = 1;\n  }\n}\n\nstatic ncclResult_t fillInfo(struct ncclComm* comm, struct ncclPeerInfo* info, uint64_t commHash) {\n  info->rank = comm->rank;\n  info->cudaDev = comm->cudaDev;\n  info->nvmlDev = comm->nvmlDev;\n  info->hostHash=getHostHash()+commHash;\n  info->pidHash=getPidHash()+commHash;\n\n  // Get the device MAJOR:MINOR of /dev/shm so we can use that\n  // information to decide whether we can use SHM for inter-process\n  // communication in a container environment\n  struct stat statbuf;\n  SYSCHECK(stat(\"/dev/shm\", &statbuf), \"stat\");\n  info->shmDev = statbuf.st_dev;\n\n  info->busId = comm->busId;\n\n  NCCLCHECK(ncclGpuGdrSupport(comm, &info->gdrSupport));\n  info->comm = comm;\n  info->cudaCompCap = comm->minCompCap = comm->maxCompCap = comm->compCap;\n\n  // MNNVL support\n  {\n    // MNNVL: Request the fabric UUID and partition info\n    char busId[NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE];\n    nvmlDevice_t nvmlDev;\n    NCCLCHECK(int64ToBusId(info->busId, busId));\n    NCCLCHECK(ncclNvmlDeviceGetHandleByPciBusId(busId, &nvmlDev));\n    info->fabricInfo.state = NVML_GPU_FABRIC_STATE_NOT_SUPPORTED;\n    (void) ncclNvmlDeviceGetGpuFabricInfoV(nvmlDev, &info->fabricInfo);\n    if (info->fabricInfo.state != NVML_GPU_FABRIC_STATE_NOT_SUPPORTED) {\n      INFO(NCCL_INIT, \"MNNVL busId 0x%lx fabric UUID %lx.%lx cliqueId 0x%x state %d healthMask 0x%x\",\n           info->busId,\n           ((long *)&info->fabricInfo.clusterUuid)[0], ((long *)&info->fabricInfo.clusterUuid)[1],\n           info->fabricInfo.cliqueId, info->fabricInfo.state, info->fabricInfo.healthMask);\n    }\n  }\n\n  return ncclSuccess;\n}\n\nstatic ncclResult_t setupChannel(struct ncclComm* comm, int channelId, int rank, int nranks, int* ringRanks) {\n  TRACE(NCCL_INIT, \"rank %d nranks %d\", rank, nranks);\n  NCCLCHECK(initChannel(comm, channelId));\n\n  struct ncclRing* ring = &comm->channels[channelId].ring;\n  // Find our ring-distance from rank zero and reorganize ranks to start with rank.\n  int ixZero=0, ixRank=0;\n  for (int i=0; i < nranks; i++) {\n    if (ringRanks[i] == 0) ixZero = i;\n    if (ringRanks[i] == rank) ixRank = i;\n  }\n  ring->index = (ixRank-ixZero + nranks)%nranks;\n  for (int i=0; i<nranks; i++) {\n    ring->userRanks[i] = ringRanks[(i+ixRank)%nranks];\n  }\n  return ncclSuccess;\n}\n\n#define DEFAULT_LL_BUFFSIZE (NCCL_LL_LINES_PER_THREAD*NCCL_LL_MAX_NTHREADS*NCCL_STEPS*sizeof(union ncclLLFifoLine))\n#define DEFAULT_LL128_BUFFSIZE (NCCL_LL128_ELEMS_PER_THREAD*NCCL_LL128_MAX_NTHREADS*NCCL_STEPS*sizeof(uint64_t))\n#define DEFAULT_BUFFSIZE (1 << 22) /* 4MiB */\nNCCL_PARAM(BuffSize, \"BUFFSIZE\", -2);\nNCCL_PARAM(LlBuffSize, \"LL_BUFFSIZE\", -2);\nNCCL_PARAM(Ll128BuffSize, \"LL128_BUFFSIZE\", -2);\n\nNCCL_PARAM(P2pNetChunkSize, \"P2P_NET_CHUNKSIZE\", (1 << 17)); /* 128 kB */\nNCCL_PARAM(P2pPciChunkSize, \"P2P_PCI_CHUNKSIZE\", (1 << 17)); /* 128 kB */\nNCCL_PARAM(P2pNvlChunkSize, \"P2P_NVL_CHUNKSIZE\", (1 << 19)); /* 512 kB */\n\nstatic ncclResult_t computeBuffSizes(struct ncclComm* comm) {\n  int cpuArch, cpuVendor, cpuModel;\n  NCCLCHECK(ncclTopoCpuType(comm->topo, &cpuArch, &cpuVendor, &cpuModel));\n\n  int64_t envs[NCCL_NUM_PROTOCOLS] = { ncclParamLlBuffSize(), ncclParamLl128BuffSize(), ncclParamBuffSize() };\n  int defaults[NCCL_NUM_PROTOCOLS] = { DEFAULT_LL_BUFFSIZE, DEFAULT_LL128_BUFFSIZE, DEFAULT_BUFFSIZE };\n\n  for (int p=0; p<NCCL_NUM_PROTOCOLS; p++) {\n    comm->buffSizes[p] = envs[p] != -2 ? envs[p] : defaults[p];\n  }\n\n  if (comm->nNodes > 1) comm->p2pChunkSize = ncclParamP2pNetChunkSize();\n  else if (ncclTopoPathAllNVLink(comm->topo)) comm->p2pChunkSize = ncclParamP2pNvlChunkSize();\n  else comm->p2pChunkSize = ncclParamP2pPciChunkSize();\n\n  // Make sure P2P chunksize is not larger than coll chunksize.\n  if (comm->p2pChunkSize * NCCL_STEPS > comm->buffSizes[NCCL_PROTO_SIMPLE]) comm->p2pChunkSize = comm->buffSizes[NCCL_PROTO_SIMPLE]/NCCL_STEPS;\n\n  if (comm->sharedRes->owner != comm) {\n    /* make sure split comm p2pChunkSize won't exceed shared p2pChunkSize. */\n    comm->p2pChunkSize = std::min(comm->p2pChunkSize, comm->sharedRes->tpP2pChunkSize);\n  } else {\n    comm->sharedRes->tpP2pChunkSize = comm->p2pChunkSize;\n  }\n\n  INFO(NCCL_INIT, \"P2P Chunksize set to %d\", comm->p2pChunkSize);\n  return ncclSuccess;\n}\n\nNCCL_PARAM(GraphDumpFileRank, \"GRAPH_DUMP_FILE_RANK\", 0);\nNCCL_PARAM(CollNetNodeThreshold, \"COLLNET_NODE_THRESHOLD\", 2);\nNCCL_PARAM(NvbPreconnect, \"NVB_PRECONNECT\", 1);\nNCCL_PARAM(AllocP2pNetLLBuffers, \"ALLOC_P2P_NET_LL_BUFFERS\", 0);\n\nstatic ncclResult_t collNetInitRailRankMap(ncclComm_t comm) {\n  int rank = comm->rank;\n  uint64_t nonHeadMask = (1ull << comm->localRanks) - 1;\n\n  comm->collNetDenseToUserRank = ncclMemoryStackAlloc<int>(&comm->memPermanent, comm->nRanks);\n  comm->collNetUserToDenseRank = ncclMemoryStackAlloc<int>(&comm->memPermanent, comm->nRanks);\n  // initialize collNetUserToDenseRank[rank]  \n  comm->collNetUserToDenseRank[rank] = -1;\n  for (int h = 0; h < comm->collNetHeadsNum; h++) {\n    nonHeadMask ^= 1ull << comm->rankToLocalRank[comm->collNetHeads[h]];\n    if (comm->collNetHeads[h] == rank) { comm->collNetUserToDenseRank[rank] = h; break; }\n  }\n  if (comm->collNetUserToDenseRank[rank] == -1) {\n    comm->collNetUserToDenseRank[rank] = __builtin_popcountll(nonHeadMask & ((1ull << comm->localRank) - 1));\n  }\n  comm->collNetUserToDenseRank[rank] += comm->node * comm->localRanks;\n\n  NCCLCHECK(bootstrapAllGather(comm->bootstrap, comm->collNetUserToDenseRank, sizeof(int)));\n  for (int r = 0; r < comm->nRanks; r++) {\n    comm->collNetDenseToUserRank[comm->collNetUserToDenseRank[r]] = r;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t collNetTrySetup(ncclComm_t comm, ncclComm_t parent, struct ncclTopoGraph* collNetGraph) {\n  ncclResult_t ret = ncclSuccess;\n  int rank = comm->rank;\n  int collNetSetupFail = 0;\n  int highestTypes[NCCL_MAX_LOCAL_RANKS] = { TRANSPORT_P2P };\n  // Find all head ranks\n  int nHeadsUnique = 0;\n  int* headsUnique = NULL;\n  int highestTransportType0, highestTransportType1;\n  char line[1024];\n  bool share;\n\n  struct collnetShareInfo {\n    int headPosition;\n    int isMaster;\n  };\n  struct collnetShareInfo* infos = NULL;\n\n  NCCLCHECKGOTO(ncclCalloc(&headsUnique, collNetGraph->nChannels), ret, fail);\n  { uint64_t mask = 0;\n    // Head GPU index is always 0\n    for (int c = 0; c < collNetGraph->nChannels; c++) {\n      int head = collNetGraph->intra[c * comm->localRanks + 0];\n      assert(comm->rankToNode[head] == comm->node);\n      uint64_t mask0 = mask;\n      mask |= 1ull<<comm->rankToLocalRank[head];\n      if (mask != mask0) headsUnique[nHeadsUnique++] = head;\n    }\n  }\n\n  comm->collNetHeads = headsUnique;\n  comm->collNetHeadsNum = nHeadsUnique;\n  if (parent && parent->collNetSupport && parent->config.splitShare && parent->nNodes == comm->nNodes) {\n    NCCLCHECKGOTO(ncclCalloc(&infos, comm->nRanks), ret, fail);\n    /* check whether child can share collnet resources of parent. Since parent builds each collnet communicator\n     * based on heads with the same head position in each node, as long as the collnet heads of child comm\n     * can match parent's heads, we can let child communicator share parent's collnet resources. */\n    for (int h = 0; h < nHeadsUnique; ++h) {\n      int prev = INT_MIN;\n      struct collnetShareInfo* myinfo;\n\n      share = true;\n      myinfo = infos + comm->rank;\n      memset(myinfo, 0, sizeof(struct collnetShareInfo));\n      /* find the child head position in parent collnet heads. */\n      if (headsUnique[h] == comm->rank) {\n        myinfo->headPosition = -1;\n        myinfo->isMaster = 1;\n        for (int th = 0; th < parent->collNetHeadsNum; ++th)\n          if (parent->topParentRanks[parent->collNetHeads[th]] == comm->topParentRanks[comm->rank]) {\n            myinfo->headPosition = th;\n            break;\n          }\n      }\n\n      NCCLCHECKGOTO(bootstrapAllGather(comm->bootstrap, infos, sizeof(struct collnetShareInfo)), ret, fail);\n      for (int i = 0; i < comm->nRanks; ++i) {\n        if (infos[i].isMaster) {\n          if (prev == INT_MIN)\n            prev = infos[i].headPosition;\n\n          if (infos[i].headPosition == -1 || prev != infos[i].headPosition) {\n            share = false;\n            break;\n          }\n        }\n      }\n\n      if (share) {\n        if (myinfo->isMaster) {\n          comm->collNetSharedRes = parent->collNetSharedRes;\n          for (int c = 0; c < comm->nChannels; ++c)\n            NCCLCHECKGOTO(initCollnetChannel(comm, c, parent, true), ret, fail);\n        }\n\n        NCCLCHECKGOTO(collNetInitRailRankMap(comm), ret, fail);\n      } else {\n        /* TODO: CX-6 and CX-7 both do not support multiple sharp resources per process, if child comm cannot\n         * share the sharp resource from parent, we cannot use sharp in this case. This restriction might be\n         * lifted by sharp plugin/IB hardware in the future. */\n        collNetSetupFail = 1;\n        if (comm->rank == 0) {\n          WARN(\"Child comms (nRanks %d) fails to share parent comms (nRanks %d) sharp resources\", comm->nRanks, parent->nRanks);\n        }\n        goto fail;\n      }\n    }\n    share = true;\n  } else {\n    /* this allocated buffer will be freed on proxy side */\n    NCCLCHECK(ncclCalloc(&comm->collNetSharedRes, 1));\n    comm->collNetSharedRes->nChannels = comm->nChannels;\n    comm->collNetSharedRes->buffSize = comm->buffSizes[NCCL_PROTO_SIMPLE];\n\n    NCCLCHECKGOTO(collNetInitRailRankMap(comm), ret, fail);\n\n    for (int c = 0; c < comm->nChannels; c++) {\n      struct ncclChannel* channel = comm->channels + c;\n      NCCLCHECKGOTO(initCollnetChannel(comm, c, parent, false), ret, fail);\n      for (int h = 0; h < nHeadsUnique; h++) {\n        const int head = headsUnique[h];\n        ncclConnect connect;\n        collNetSetupFail |= ncclTransportCollNetSetup(comm, collNetGraph, channel, head, head, h, collNetRecv, &connect);\n        if (!collNetSetupFail) collNetSetupFail |= ncclTransportCollNetSetup(comm, collNetGraph, channel, head, head, h, collNetSend, &connect);\n      }\n      // Verify CollNet setup across ranks after trying the first channel\n      if (c == 0) {\n        NCCLCHECKGOTO(ncclTransportCollNetCheck(comm, collNetSetupFail), ret, fail);\n      }\n    }\n    share = false;\n  }\n\n  if (share) {\n    memcpy(comm->collNetSupportMatrix, parent->collNetSupportMatrix, sizeof(comm->collNetSupportMatrix));\n  } else {\n    do {\n      /* Initialize all entries in collNetSupportMatrix[redop][type]. Since some\n      ranks don't connect to sharp we enable a (redop,type) if any rank claims\n      support. */\n      const ncclRedOp_t redops[] = {ncclSum, ncclProd, ncclMin, ncclMax};\n      uint8_t(*matrix)[4][ncclNumTypes];\n      bool isHead = false;\n      matrix = nullptr;\n      NCCLCHECKGOTO(ncclCalloc(&matrix, comm->nRanks), ret, matrix_end);\n      for (int h = 0; h < nHeadsUnique; h++) isHead |= (headsUnique[h] == comm->rank);\n      if (isHead) {\n        for (int ty=0; ty < ncclNumTypes; ty++) {\n          for (int i=0; i < 4; i++) {\n            int support = 0;\n            NCCLCHECKGOTO(collNetReduceSupport(comm, (ncclDataType_t)ty, redops[i], &support), ret, matrix_end);\n            // bit 0 = not supported, bit 1 = supported\n            matrix[rank][redops[i]][ty] = 1<<(support ? 1 : 0);\n          }\n        }\n      }\n      NCCLCHECKGOTO(bootstrapAllGather(comm->bootstrap, matrix, sizeof(*matrix)), ret, matrix_end);\n      for (int ty=0; ty < ncclNumTypes; ty++) {\n        for (int i=0; i < 4; i++) {\n          int op = redops[i];\n          uint8_t accum = 0;\n          for (int r=0; r < comm->nRanks; r++) accum |= matrix[r][op][ty];\n          // We support (redop, type) if some rank supports it and no rank doesn't support it\n          comm->collNetSupportMatrix[op][ty] = (accum == (1<<1));\n        }\n      }\n    matrix_end:\n      free(matrix);\n      if (ret != ncclSuccess) goto fail;\n    } while (0);\n  }\n\n  // Verify CollNet setup across ranks after trying all channels\n  NCCLCHECKGOTO(ncclTransportCollNetCheck(comm, collNetSetupFail), ret, fail);\n  TRACE(NCCL_INIT, \"rank %d Connected inter-node CollNet\", rank);\n\n  line[0] = '\\0';\n  for (int c = 0; c < comm->nChannels; c++) {\n    struct ncclTree* chain = &comm->channels[c].collnetChain;\n    snprintf(line + strlen(line), 1023 - strlen(line), \" [%d] %d->%d->%d\",\n      c, chain->down[0], rank, chain->up);\n  }\n  line[1023] = '\\0';\n\n  INFO(NCCL_INIT, \"Collnet Chains %s\", line);\n  // Connect Collnet + chain\n  for (int c = 0; c < comm->nChannels; c++) {\n    struct ncclChannel* channel = comm->channels + c;\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, 1, &channel->collnetChain.up, 1, channel->collnetChain.down, 0), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclTransportP2pSetup(comm, collNetGraph, 0), ret, fail);\n  for (int c = 0; c < comm->nChannels; c++) {\n    struct ncclChannel* channel = comm->channels + c;\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, 1, channel->collnetChain.down, 1, &channel->collnetChain.up, 1), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclTransportP2pSetup(comm, collNetGraph, 1), ret, fail);\n  INFO(NCCL_INIT, \"Connected collnet + chain\");\n\n  // Connect intra-node CollNet + Direct\n  for (int c = 0; c < comm->nChannels; c++) {\n    struct ncclChannel* channelRecv = comm->channels + c;\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, NCCL_MAX_DIRECT_ARITY, channelRecv->collnetDirect.up, NCCL_MAX_DIRECT_ARITY, channelRecv->collnetDirect.down, 0), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclTransportP2pSetup(comm, collNetGraph, 0, &highestTransportType0), ret, fail);\n\n  for (int c = 0; c < comm->nChannels; c++) {\n    struct ncclChannel* channelSend = comm->channels + c;\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, NCCL_MAX_DIRECT_ARITY, channelSend->collnetDirect.down, NCCL_MAX_DIRECT_ARITY, channelSend->collnetDirect.up, 1), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclTransportP2pSetup(comm, collNetGraph, 1, &highestTransportType1), ret, fail);\n\n  // Exchange highest intra-node transport type among ranks\n  // because we need to know whether all ranks can p2p each other to determine whether we can directly read/write registered user buffer\n  comm->intraHighestTransportType = highestTypes[comm->localRank] = highestTransportType0 > highestTransportType1 ? highestTransportType0 : highestTransportType1;\n  if (share) {\n    comm->intraHighestTransportType = std::max(comm->intraHighestTransportType, parent->intraHighestTransportType);\n  }\n  NCCLCHECKGOTO(bootstrapIntraNodeAllGather(comm->bootstrap, comm->localRankToRank, comm->localRank, comm->localRanks, highestTypes, sizeof(int)), ret, fail);\n  for (int i = 0; i < comm->localRanks; i++) {\n    if (highestTypes[i] > comm->intraHighestTransportType)\n      comm->intraHighestTransportType = highestTypes[i];\n  }\n\n  INFO(NCCL_INIT, \"rank %d Connected CollNet\", rank);\n\nexit:\n  free(infos);\n  return ret;\nfail:\n  ncclTransportCollNetFree(comm);\n  comm->collNetSupport = 0;\n  goto exit;\n}\n\n// MNNVL: Flag to indicate whether to enable Multi-Node NVLink\nNCCL_PARAM(MNNVLEnable, \"MNNVL_ENABLE\", 2);\n\n#if CUDART_VERSION >= 11030\n\n#include <cuda.h>\n#include \"cudawrap.h\"\n\n// Determine if MNNVL support is available\nstatic int checkMNNVL(struct ncclComm* comm) {\n  ncclResult_t ret = ncclSuccess;\n\n  // MNNVL requires cuMem to be enabled\n  if (!ncclCuMemEnable()) return 0;\n\n  // MNNVL also requires FABRIC handle support\n  int cudaDev;\n  int flag = 0;\n  CUdevice currentDev;\n  CUDACHECK(cudaGetDevice(&cudaDev));\n  CUCHECK(cuDeviceGet(&currentDev, cudaDev));\n  // Ignore error if CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED is not supported\n  (void) CUPFN(cuDeviceGetAttribute(&flag, CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED, currentDev));;\n  if (!flag) return 0;\n  // Check that all ranks have initialized the fabric fully\n  for (int i = 0; i < comm->nRanks; i++) {\n    if (comm->peerInfo[i].fabricInfo.state != NVML_GPU_FABRIC_STATE_COMPLETED) return 0;\n  }\n\n  // Determine our MNNVL domain/clique\n  NCCLCHECKGOTO(ncclCalloc(&comm->clique.ranks, comm->nRanks), ret, fail);\n  comm->clique.id = comm->peerInfo[comm->rank].fabricInfo.cliqueId;\n  for (int i = 0; i < comm->nRanks; i++) {\n    nvmlGpuFabricInfoV_t *fabricInfo1 = &comm->peerInfo[comm->rank].fabricInfo;\n    nvmlGpuFabricInfoV_t *fabricInfo2 = &comm->peerInfo[i].fabricInfo;\n    // Check if the cluster UUID and cliqueId match\n    // A zero UUID means we don't have MNNVL fabric info - disable MNNVL\n    if ((((long *)&fabricInfo2->clusterUuid)[0]|((long *)fabricInfo2->clusterUuid)[1]) == 0) goto fail;\n    if ((memcmp(fabricInfo1->clusterUuid, fabricInfo2->clusterUuid, NVML_GPU_FABRIC_UUID_LEN) == 0) &&\n        (fabricInfo1->cliqueId == fabricInfo2->cliqueId)) {\n      if (i == comm->rank) {\n        comm->cliqueRank = comm->clique.size;\n      }\n      comm->clique.ranks[comm->clique.size++] = i;\n    }\n  }\n  // Determine whether to enable MNNVL or not\n  comm->MNNVL = ncclParamMNNVLEnable() == 2 ? comm->clique.size > 1 : ncclParamMNNVLEnable();\n  INFO(NCCL_INIT, \"MNNVL %d cliqueId %x cliqueSize %d cliqueRank %d \", comm->MNNVL, comm->clique.id, comm->clique.size, comm->cliqueRank);\n\n  if (comm->MNNVL) {\n    // Force the CUMEM handle type to be FABRIC for MNNVL\n    ncclCuMemHandleType = CU_MEM_HANDLE_TYPE_FABRIC;\n  }\n\n  return comm->MNNVL;\n\nfail:\n  if (comm->clique.ranks) free(comm->clique.ranks);\n  return 0;\n}\n\n#else\nstatic int checkMNNVL(struct ncclComm* comm) {\n  return 0;\n}\n#endif\n\nstatic ncclResult_t initTransportsRank(struct ncclComm* comm, struct ncclComm* parent = NULL) {\n  // We use 2 AllGathers\n  // 1. { peerInfo, comm, compCap}\n  // 2. { nChannels, graphInfo, topoRanks }\n  ncclResult_t ret = ncclSuccess;\n  int rank = comm->rank;\n  int nranks = comm->nRanks;\n  int nNodes = 1;\n  cpu_set_t affinitySave;\n  struct ncclTopoGraph ringGraph;\n  struct ncclTopoGraph treeGraph;\n  struct ncclTopoGraph collNetGraph;\n  struct ncclTopoGraph nvlsGraph;\n  struct ncclTopoGraph* graphs[] = { &treeGraph, &ringGraph, &collNetGraph, &collNetGraph, &nvlsGraph, &nvlsGraph };\n\n  struct graphInfo {\n    int pattern;\n    int nChannels;\n    int sameChannels;\n    float bwIntra;\n    float bwInter;\n    int typeIntra;\n    int typeInter;\n    int crossNic;\n  };\n\n  struct allGatherInfo {\n    struct graphInfo graphInfo[NCCL_NUM_ALGORITHMS];\n    struct ncclTopoRanks topoRanks;\n  };\n\n  int nChannelsOrig;\n  struct allGatherInfo *allGather3Data = NULL;\n  struct ncclTopoRanks** allTopoRanks = NULL;\n  int *nodesFirstRank = NULL, *nodesTreePatterns = NULL;\n  int *rings = NULL;\n  int* nvbPeers = NULL;\n  struct ncclProxyConnector proxyConn;\n  int* pxnPeers = NULL;\n  int *topParentLocalRanks = NULL;\n  int tpProxyRank;\n\n  // AllGather1 - begin\n  NCCLCHECKGOTO(ncclCalloc(&comm->peerInfo, nranks+1), ret, fail); // Extra rank to represent CollNet root\n  NCCLCHECKGOTO(fillInfo(comm, comm->peerInfo+rank, comm->commHash), ret, fail);\n  NCCLCHECKGOTO(bootstrapAllGather(comm->bootstrap, comm->peerInfo, sizeof(struct ncclPeerInfo)), ret, fail);\n\n  for (int i = 0; i < nranks; i++) {\n    if (comm->peerInfo[i].hostHash != comm->peerInfo[rank].hostHash) nNodes++;\n    if ((i != rank) && (comm->peerInfo[i].hostHash == comm->peerInfo[rank].hostHash) && (comm->peerInfo[i].busId == comm->peerInfo[rank].busId)) {\n      WARN(\"Duplicate GPU detected : rank %d and rank %d both on CUDA device %lx\", rank, i, comm->peerInfo[rank].busId);\n      ret = ncclInvalidUsage;\n      goto fail;\n    }\n  }\n  // AllGather1 - end\n\n  // MNNVL support\n  if (nNodes > 1 && !checkMNNVL(comm) && ncclParamMNNVLEnable() == 1) {\n    // Return an error if the user specifically requested MNNVL support\n    WARN(\"MNNVL is not supported on this system\");\n    ret = ncclSystemError;\n    goto fail;\n  }\n\n  do {\n    // Compute intra-process ranks\n    int intraProcRank0 = -1, intraProcRank = -1, intraProcRanks = 0;\n    for (int i = 0; i < nranks; i++) comm->minCompCap = std::min(comm->minCompCap, comm->peerInfo[i].cudaCompCap);\n    for (int i = 0; i < nranks; i++) comm->maxCompCap = std::max(comm->maxCompCap, comm->peerInfo[i].cudaCompCap);\n\n    comm->nvlsRegSupport = 1;\n    for (int i = 0; i < nranks; i++) {\n      if ((comm->peerInfo[i].hostHash == comm->peerInfo[rank].hostHash)\n          && (comm->peerInfo[i].pidHash == comm->peerInfo[rank].pidHash)) {\n        // Rank is in same process\n        if (intraProcRanks == 0) intraProcRank0 = i;\n        if (i == rank) intraProcRank = intraProcRanks;\n        intraProcRanks++;\n        if (intraProcRank0 == rank && rank != i) {\n          comm->peerInfo[i].comm->intraNext = comm->intraNext;\n          comm->intraNext = comm->peerInfo[i].comm;\n        }\n      }\n\n      if (comm->nvlsRegSupport) {\n        for (int j = i + 1; j < nranks; j++) {\n          if (comm->peerInfo[i].hostHash == comm->peerInfo[j].hostHash &&\n            comm->peerInfo[i].pidHash == comm->peerInfo[j].pidHash) {\n            comm->nvlsRegSupport = 0;\n            break;\n          }\n        }\n      }\n    }\n\n    // Buffer Registration is not supported with MNNVL\n    if (comm->MNNVL) comm->nvlsRegSupport = 0;\n\n    TRACE(NCCL_INIT,\"pidHash[%d] %lx intraProcRank %d intraProcRanks %d intraProcRank0 %d\",\n        rank, comm->peerInfo[rank].pidHash, intraProcRank, intraProcRanks, intraProcRank0);\n    if (intraProcRank == -1 || intraProcRank0 == -1 || comm->peerInfo[intraProcRank0].comm == NULL) {\n      WARN(\"Failed to determine intra proc ranks rank %d hostHash %lx pidHash %lx intraProcRank %d intraProcRanks %d intraProcRank0 %d\",\n          rank, comm->peerInfo[rank].hostHash, comm->peerInfo[rank].pidHash,\n          intraProcRank, intraProcRanks, intraProcRank0);\n      ret = ncclInternalError;\n      goto fail;\n    }\n    struct ncclComm* comm0 = comm->peerInfo[intraProcRank0].comm;\n    assert(intraProcRank==0 ? comm==comm0 : true);\n    comm->intraComm0 = comm0;\n    comm->intraRank = intraProcRank;\n    comm->intraRanks = intraProcRanks;\n    comm->intraBarrierPhase = 0;\n    comm->intraBarrierCounter = 0;\n    comm->intraBarrierGate = 0;\n  } while(0);\n\n  // Topo detection / System graph creation\n  NCCLCHECKGOTO(ncclTopoGetSystem(comm, &comm->topo), ret, fail);\n  // Compute paths between GPUs and NICs\n  NCCLCHECKGOTO(ncclTopoComputePaths(comm->topo, comm), ret, fail);\n  // Remove inaccessible GPUs and unused NICs\n  NCCLCHECKGOTO(ncclTopoTrimSystem(comm->topo, comm), ret, fail);\n  // Recompute paths after trimming\n  NCCLCHECKGOTO(ncclTopoComputePaths(comm->topo, comm), ret, fail);\n  // Init search\n  NCCLCHECKGOTO(ncclTopoSearchInit(comm->topo), ret, fail);\n  // Print final topology\n  NCCLCHECKGOTO(ncclTopoPrint(comm->topo), ret, fail);\n\n  // Set Affinity to a CPU local the our GPU, so that all memory we allocate\n  // on the host is local.\n  NCCLCHECKGOTO(ncclTopoGetCpuAffinity(comm->topo, comm->rank, &comm->cpuAffinity), ret, fail);\n  if (CPU_COUNT(&comm->cpuAffinity)) {\n    sched_getaffinity(0, sizeof(cpu_set_t), &affinitySave);\n    sched_setaffinity(0, sizeof(cpu_set_t), &comm->cpuAffinity);\n  }\n\n  // Determine local CollNet support\n  if (collNetSupport(comm)) {\n    const char *collNetEnable = ncclGetEnv(\"NCCL_COLLNET_ENABLE\");\n    if (collNetEnable != NULL) {\n      INFO(NCCL_ALL, \"NCCL_COLLNET_ENABLE set by environment to %s.\", collNetEnable);\n      if (strcmp(collNetEnable, \"1\") == 0) {\n        comm->collNetSupport = 1;\n      }\n    }\n  }\n\n  // Determine local Nvls support\n  NCCLCHECK(ncclNvlsInit(comm));\n\n  // Get rings and trees\n  memset(&ringGraph, 0, sizeof(struct ncclTopoGraph));\n  ringGraph.id = 0;\n  ringGraph.pattern = NCCL_TOPO_PATTERN_RING;\n  ringGraph.minChannels = 1;\n  ringGraph.maxChannels = MAXCHANNELS/2;\n  NCCLCHECKGOTO(ncclTopoCompute(comm->topo, &ringGraph), ret, fail);\n  NCCLCHECKGOTO(ncclTopoPrintGraph(comm->topo, &ringGraph), ret, fail);\n\n  memset(&treeGraph, 0, sizeof(struct ncclTopoGraph));\n  treeGraph.id = 1;\n  treeGraph.pattern = NCCL_TOPO_PATTERN_BALANCED_TREE;\n  treeGraph.minChannels = ringGraph.nChannels;\n  treeGraph.maxChannels = ringGraph.nChannels;\n  NCCLCHECKGOTO(ncclTopoCompute(comm->topo, &treeGraph), ret, fail);\n  NCCLCHECKGOTO(ncclTopoPrintGraph(comm->topo, &treeGraph), ret, fail);\n\n  memset(&collNetGraph, 0, sizeof(struct ncclTopoGraph));\n  collNetGraph.id = 2;\n  collNetGraph.pattern = NCCL_TOPO_PATTERN_TREE;\n  collNetGraph.collNet = 1;\n  collNetGraph.minChannels = collNetGraph.maxChannels = ringGraph.nChannels;\n  if (comm->collNetSupport) {\n    NCCLCHECKGOTO(ncclTopoCompute(comm->topo, &collNetGraph), ret, fail);\n    NCCLCHECKGOTO(ncclTopoPrintGraph(comm->topo, &collNetGraph), ret, fail);\n  }\n\n  memset(&nvlsGraph, 0, sizeof(struct ncclTopoGraph));\n  nvlsGraph.id = 3;\n  nvlsGraph.pattern = NCCL_TOPO_PATTERN_NVLS;\n  nvlsGraph.minChannels = 1;\n  nvlsGraph.maxChannels = MAXCHANNELS;\n  if (comm->nvlsSupport) {\n    NCCLCHECKGOTO(ncclTopoCompute(comm->topo, &nvlsGraph), ret, fail);\n    NCCLCHECKGOTO(ncclTopoPrintGraph(comm->topo, &nvlsGraph), ret, fail);\n  }\n\n  // Initialize num P2P LL buffers for this communicator\n  comm->allocP2pNetLLBuffers = ncclParamAllocP2pNetLLBuffers() == 1;\n\n  if (comm->rank == ncclParamGraphDumpFileRank()) {\n    struct ncclTopoGraph* dumpGraphs[4] = { &ringGraph, &treeGraph, &collNetGraph, &nvlsGraph };\n    NCCLCHECKGOTO(ncclTopoDumpGraphs(comm->topo, 4, dumpGraphs), ret, fail);\n  }\n\n  // AllGather3 - begin\n  NCCLCHECKGOTO(ncclCalloc(&allGather3Data, nranks), ret, fail);\n\n  for (int a=0; a<NCCL_NUM_ALGORITHMS; a++) {\n    allGather3Data[rank].graphInfo[a].pattern = graphs[a]->pattern;\n    allGather3Data[rank].graphInfo[a].nChannels = graphs[a]->nChannels;\n    allGather3Data[rank].graphInfo[a].sameChannels = graphs[a]->sameChannels;\n    allGather3Data[rank].graphInfo[a].bwIntra = graphs[a]->bwIntra;\n    allGather3Data[rank].graphInfo[a].bwInter = graphs[a]->bwInter;\n    allGather3Data[rank].graphInfo[a].typeIntra = graphs[a]->typeIntra;\n    allGather3Data[rank].graphInfo[a].typeInter = graphs[a]->typeInter;\n    allGather3Data[rank].graphInfo[a].crossNic = graphs[a]->crossNic;\n  }\n\n  comm->nChannels = std::min(treeGraph.nChannels, ringGraph.nChannels);\n  NCCLCHECKGOTO(ncclTopoPreset(comm, graphs, &allGather3Data[rank].topoRanks), ret, fail);\n\n  NCCLCHECKGOTO(bootstrapAllGather(comm->bootstrap, allGather3Data, sizeof(*allGather3Data)), ret, fail);\n\n  // Determine nNodes, firstRanks, ...\n  NCCLCHECKGOTO(ncclCalloc(&nodesFirstRank, nranks), ret, fail);\n  NCCLCHECKGOTO(ncclCalloc(&nodesTreePatterns, nranks), ret, fail);\n  NCCLCHECKGOTO(ncclCalloc(&comm->rankToNode, comm->nRanks), ret, fail);\n  for (int r=0; r<nranks; r++) {\n    int node;\n    int firstRank = allGather3Data[r].topoRanks.ringRecv[0];\n    for (node=0; node<comm->nNodes && nodesFirstRank[node] != firstRank; node++);\n    if (node == comm->nNodes) {\n      comm->nNodes++;\n      nodesFirstRank[node] = firstRank;\n      // Record tree pattern of each node as they can be different depending on sm arch\n      nodesTreePatterns[node] = allGather3Data[r].graphInfo[NCCL_ALGO_TREE].pattern;\n    }\n    comm->rankToNode[r] = node;\n  }\n  // Now that we know nNodes, alloc nodeRanks and compute localRanks for each node\n  NCCLCHECKGOTO(ncclCalloc(&comm->nodeRanks, comm->nNodes), ret, fail);\n  NCCLCHECKGOTO(ncclCalloc(&comm->rankToLocalRank, comm->nRanks), ret, fail);\n  for (int r=0; r<comm->nRanks; r++) {\n    int node = comm->rankToNode[r];\n    comm->rankToLocalRank[r] = comm->nodeRanks[node].localRanks;\n    comm->nodeRanks[node].localRanks++;\n  }\n  // Allocate ranks arrays for each node\n  for (int n=0; n<comm->nNodes; n++) {\n    NCCLCHECKGOTO(ncclCalloc(&comm->nodeRanks[n].localRankToRank, comm->nodeRanks[n].localRanks), ret, fail);\n    comm->maxLocalRanks = std::max(comm->maxLocalRanks, comm->nodeRanks[n].localRanks);\n    comm->nodeRanks[n].localRanks = 0;\n  }\n  // And fill the ranks arrays\n  for (int r=0; r<comm->nRanks; r++) {\n    int node = comm->rankToNode[r];\n    comm->nodeRanks[node].localRankToRank[comm->nodeRanks[node].localRanks++] = r;\n  }\n  comm->node = comm->rankToNode[rank];\n  comm->localRankToRank = comm->nodeRanks[comm->node].localRankToRank;\n  comm->localRank = comm->rankToLocalRank[rank];\n  comm->localRanks = comm->nodeRanks[comm->node].localRanks;\n\n  TRACE(NCCL_INIT,\"hostHash[%d] %lx localRank %d localRanks %d localRank0 %d\",\n        rank, comm->peerInfo[rank].hostHash, comm->localRank, comm->localRanks, comm->localRankToRank[0]);\n  if (comm->localRank == -1 || comm->localRankToRank[0] == -1 || comm->localRanks == 0) {\n    WARN(\"Failed to determine local ranks rank %d hostHash %lx pidHash %lx localRank %d localRanks %d localRank0 %d\",\n         rank, comm->peerInfo[rank].hostHash, comm->peerInfo[rank].pidHash,\n         comm->localRank, comm->localRanks, comm->localRankToRank[0]);\n    ret = ncclInternalError;\n    goto fail;\n  }\n\n  INFO(NCCL_INIT, \"comm %p rank %d nRanks %d nNodes %d localRanks %d localRank %d MNNVL %d\",\n       comm, rank, comm->nRanks, comm->nNodes, comm->localRanks, comm->localRank, comm->MNNVL);\n\n  nChannelsOrig = comm->nChannels;\n  NCCLCHECKGOTO(ncclCalloc(&allTopoRanks, comm->nRanks), ret, fail);\n  for (int i=0; i<nranks; i++) {\n    allTopoRanks[i] = &allGather3Data[i].topoRanks;\n    // Make sure we align all ranks so that the tuning is consistent across ranks\n    for (int a=0; a<NCCL_NUM_ALGORITHMS; a++) {\n      graphs[a]->nChannels = std::min(allGather3Data[i].graphInfo[a].nChannels, graphs[a]->nChannels);\n      graphs[a]->sameChannels = std::min(allGather3Data[i].graphInfo[a].sameChannels, graphs[a]->sameChannels);\n      graphs[a]->bwIntra = std::min(allGather3Data[i].graphInfo[a].bwIntra, graphs[a]->bwIntra);\n      graphs[a]->bwInter = std::min(allGather3Data[i].graphInfo[a].bwInter, graphs[a]->bwInter);\n      graphs[a]->typeIntra = std::max(allGather3Data[i].graphInfo[a].typeIntra, graphs[a]->typeIntra);\n      graphs[a]->typeInter = std::max(allGather3Data[i].graphInfo[a].typeInter, graphs[a]->typeInter);\n      graphs[a]->crossNic = std::max(allGather3Data[i].graphInfo[a].crossNic, graphs[a]->crossNic);\n    }\n  }\n  if (graphs[NCCL_ALGO_COLLNET_CHAIN]->nChannels == 0) comm->collNetSupport = 0;\n  if (graphs[NCCL_ALGO_NVLS]->nChannels == 0) comm->nvlsSupport = comm->nvlsChannels = 0;\n\n  comm->nChannels = treeGraph.nChannels = ringGraph.nChannels = std::min(treeGraph.nChannels, ringGraph.nChannels);\n  if (comm->nChannels < nChannelsOrig) {\n    // We started duplicating channels during Preset(), so we need to move the\n    // duplicated channels since we have removed some.\n    for (int i=0; i<comm->nChannels; i++) memcpy(comm->channels+comm->nChannels+i, comm->channels+nChannelsOrig+i, sizeof(struct ncclChannel));\n  }\n\n  // Determine CollNet support after all-gather now that we know nNodes and each node localRanks\n  if (comm->collNetSupport == 1) {\n    int collNetNodeThreshold = ncclParamCollNetNodeThreshold();\n    if (comm->nNodes < collNetNodeThreshold) {\n      INFO(NCCL_INIT, \"Communicator has %d nodes which is less than CollNet node threshold %d, disabling CollNet\", comm->nNodes, collNetNodeThreshold);\n      comm->collNetSupport = 0;\n    }\n    comm->collNetRegSupport = true;\n    for (int n=0; n<comm->nNodes; n++) {\n      if (comm->nodeRanks[n].localRanks > NCCL_MAX_DIRECT_ARITY+1) {\n        WARN(\"CollNet currently only supports up to %d GPUs per node, disabling CollNet\", NCCL_MAX_DIRECT_ARITY+1);\n        comm->collNetSupport = 0;\n        break;\n      }\n      if (comm->nodeRanks[n].localRanks > 1) {\n        // As long as there is more than 1 rank on any node, we need to disable collnet reg\n        comm->collNetRegSupport = false;\n      }\n    }\n  }\n\n  NCCLCHECKGOTO(ncclCalloc(&rings, nranks*MAXCHANNELS), ret, fail);\n  NCCLCHECKGOTO(ncclTopoPostset(comm, nodesFirstRank, nodesTreePatterns, allTopoRanks, rings, graphs, parent), ret, fail);\n  // AllGather3 - end\n\n  TRACE(NCCL_INIT, \"rank %d nranks %d - BUILT %d TREES/RINGS\", rank, nranks, comm->nChannels);\n\n  char line[1024];\n  line[0]='\\0';\n  for (int c=0; c<comm->nChannels; c++) {\n    struct ncclTree* tree = &comm->channels[c].tree;\n    snprintf(line+strlen(line), 1023-strlen(line), \" [%d] %d/%d/%d->%d->%d\",\n        c, tree->down[0], tree->down[1], tree->down[2], rank, tree->up);\n    INFO(NCCL_GRAPH, \"Ring %02d : %d -> %d -> %d\", c, comm->channels[c].ring.prev, comm->rank, comm->channels[c].ring.next);\n  }\n  line[1023] = '\\0';\n  INFO(NCCL_INIT, \"Trees%s\", line);\n\n  NCCLCHECKGOTO(computeBuffSizes(comm), ret, fail);\n\n  // Compute nChannels per peer for p2p\n  NCCLCHECKGOTO(ncclTopoComputeP2pChannels(comm), ret, fail);\n\n  /* until now, all info of comm should be known. We can initialize shared resources and\n   * map localRanks to top parent local ranks. NOTE: this shareRes init must be put before\n   * all proxy operations. */\n  if (comm->sharedRes->owner == comm) {\n    comm->sharedRes->tpNLocalRanks = comm->localRanks;\n    comm->sharedRes->magic = comm->magic;\n    comm->sharedRes->tpNChannels = comm->nChannels;\n    comm->sharedRes->tpP2pNChannels = comm->p2pnChannels;\n    memcpy(comm->sharedRes->tpRankToLocalRank, comm->rankToLocalRank, sizeof(int) * comm->nRanks);\n  }\n  NCCLCHECKGOTO(ncclCalloc(&topParentLocalRanks, comm->localRanks), ret, fail);\n  for (int i = 0; i < comm->localRanks; ++i) {\n    int tpRank = comm->topParentRanks[comm->localRankToRank[i]];\n    topParentLocalRanks[i] = comm->sharedRes->tpRankToLocalRank[tpRank];\n  }\n  comm->topParentLocalRanks = topParentLocalRanks;\n\n  // Launch proxy service thread, after this, the proxy calls can be used.\n  if (parent && parent->config.splitShare) {\n    comm->proxyState = parent->sharedRes->proxyState;\n    ncclAtomicRefCountIncrement(&parent->sharedRes->proxyState->refCount);\n  } else {\n    NCCLCHECKGOTO(ncclProxyCreate(comm), ret, fail);\n  }\n\n  // Connect with prev/next for each ring\n  for (int c=0; c<comm->nChannels; c++) {\n    struct ncclChannel* channel = comm->channels+c;\n    NCCLCHECKGOTO(setupChannel(comm, c, rank, nranks, rings+c*nranks), ret, fail);\n    if (comm->nRanks == 1) continue;\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, 1, &channel->ring.prev, 1, &channel->ring.next, 0), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclTransportP2pSetup(comm, &ringGraph, 0), ret, fail);\n  INFO(NCCL_INIT, \"Connected all rings\");\n\n  // Connect Trees\n  for (int c=0; c<comm->nChannels; c++) {\n    struct ncclChannel* channel = comm->channels+c;\n    if (comm->nRanks == 1) continue;\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, NCCL_MAX_TREE_ARITY, channel->tree.down, 1, &channel->tree.up, 0), ret, fail);\n    NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, 1, &channel->tree.up, NCCL_MAX_TREE_ARITY, channel->tree.down, 0), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclTransportP2pSetup(comm, &treeGraph, 0), ret, fail);\n  INFO(NCCL_INIT, \"Connected all trees\");\n\n  // Setup NVLS\n  NCCLCHECKGOTO(ncclNvlsSetup(comm, parent), ret, fail);\n  // And NVLS trees if needed\n  if (comm->nvlsSupport && comm->nNodes > 1) {\n    for (int c=0; c<comm->nChannels; c++) {\n      struct ncclChannel* channel = comm->channels+c;\n      NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, NCCL_MAX_NVLS_TREE_ARITY, channel->nvls.treeDown, 1, &channel->nvls.treeUp, 0), ret, fail);\n      NCCLCHECKGOTO(ncclTransportP2pConnect(comm, c, 1, &channel->nvls.treeUp, NCCL_MAX_NVLS_TREE_ARITY, channel->nvls.treeDown, 0), ret, fail);\n    }\n    NCCLCHECKGOTO(ncclTransportP2pSetup(comm, &nvlsGraph, 0), ret, fail);\n    INFO(NCCL_INIT, \"Connected NVLS tree\");\n  }\n\n  // Check if we can setup CollNet\n  if (comm->collNetSupport > 0) collNetTrySetup(comm, parent, &collNetGraph);\n\n  TRACE(NCCL_INIT, \"rank %d nranks %d - CONNECTED %d RINGS AND TREES\", rank, nranks, comm->nChannels);\n\n  // Compute time models for algorithm and protocol combinations\n  NCCLCHECKGOTO(ncclTopoTuneModel(comm, comm->minCompCap, comm->maxCompCap, graphs), ret, fail);\n\n  INFO(NCCL_INIT, \"%d coll channels, %d collnet channels, %d nvls channels, %d p2p channels, %d p2p channels per peer\", comm->nChannels, comm->nChannels, comm->nvlsChannels, comm->p2pnChannels, comm->p2pnChannelsPerPeer);\n\n  do { // Setup p2p structures in comm->tasks\n    struct ncclTasks* tasks = &comm->tasks;\n    int node = comm->node;\n    int nNodes = comm->nNodes;\n    struct ncclNodeRanks *nodeRanks = comm->nodeRanks;\n    int localRank = comm->localRank;\n    // We want to fuse along node boundaries. Make sure nsteps is a multiple or divides 8.\n    int steps = ALIGN_POWER(comm->maxLocalRanks, NCCL_MAX_WORK_ELEMENTS_P2P/2);\n    tasks->p2pOrderSteps = comm->nNodes * steps;\n    tasks->peers = ncclMemoryStackAlloc<ncclTasks::Peer>(&comm->memPermanent, tasks->p2pOrderSteps);\n    tasks->p2pSendOrder = ncclMemoryStackAlloc<int>(&comm->memPermanent, tasks->p2pOrderSteps);\n    tasks->p2pRecvOrder = ncclMemoryStackAlloc<int>(&comm->memPermanent, tasks->p2pOrderSteps);\n    int i=0;\n    // schedule delta 0, +1, -1, +2, -2, ...\n    // also make sure we don't do 0 twice, nor +n/2 and -n/2 if n is even.\n    for (int d=0; d <= nNodes/4; d++) {\n      int deltas[4] = { d, (nNodes-d)%nNodes, nNodes/2-d, (nNodes-(nNodes/2-d))%nNodes };\n      int index = 0;\n      int delta = deltas[index];\n    sched_delta:\n      int recvNode = (node+nNodes-delta)%nNodes;\n      int sendNode = (node+delta)%nNodes;\n      for (int step=0; step < steps; step++) {\n        int recvIndex = (localRank-step+steps)%steps;\n        int recvRank = recvIndex < nodeRanks[recvNode].localRanks ? nodeRanks[recvNode].localRankToRank[recvIndex] : -1;\n        tasks->p2pRecvOrder[i] = recvRank;\n        int sendIndex = (localRank+step)%steps;\n        int sendRank = sendIndex < nodeRanks[sendNode].localRanks ? nodeRanks[sendNode].localRankToRank[sendIndex] : -1;\n        tasks->p2pSendOrder[i] = sendRank;\n        i++;\n      }\n      index++;\n      if (index == 1 && deltas[1] == deltas[0]) index++;\n      if (index == 2 && deltas[2] == deltas[0]) index++;\n      if (index == 3 && deltas[3] == deltas[2]) index++;\n      if (index == 3 && deltas[3] == deltas[1]) index++;\n      if (index < 4) {\n        delta = deltas[index];\n        goto sched_delta;\n      }\n    }\n    assert(i == tasks->p2pOrderSteps);\n  } while (0);\n\n  if (ncclParamNvbPreconnect()) {\n    // Connect p2p when using NVB path\n    int nvbNpeers;\n    NCCLCHECKGOTO(ncclTopoGetNvbGpus(comm->topo, comm->rank, &nvbNpeers, &nvbPeers), ret, fail);\n    for (int r=0; r<nvbNpeers; r++) {\n      int peer = nvbPeers[r];\n      int channelId;\n      for (int c=0; c<comm->p2pnChannelsPerPeer; c++) {\n        NCCLCHECKGOTO(ncclChannelCompute(comm, peer, c, ncclFuncSend, &channelId), ret, fail);\n        if (comm->channels[channelId].peers[peer]->send[1].connected == 0) {\n          comm->connectSend[peer] |= (1UL<<channelId);\n        }\n      }\n      for (int c=0; c<comm->p2pnChannelsPerPeer; c++) {\n        NCCLCHECKGOTO(ncclChannelCompute(comm, peer, c, ncclFuncRecv, &channelId), ret, fail);\n        if (comm->channels[channelId].peers[peer]->recv[1].connected == 0) {\n          comm->connectRecv[peer] |= (1UL<<channelId);\n        }\n      }\n    }\n\n    NCCLCHECKGOTO(ncclTransportP2pSetup(comm, NULL, 1), ret, fail);\n  }\n\n  // Connect to local net proxy\n  tpProxyRank = comm->topParentRanks[comm->rank];\n  NCCLCHECKGOTO(ncclProxyConnect(comm, TRANSPORT_NET, 1, tpProxyRank, &proxyConn), ret, fail);\n  NCCLCHECKGOTO(ncclProxyCallBlocking(comm, &proxyConn, ncclProxyMsgSharedInit, &comm->p2pnChannels, sizeof(int), NULL, 0), ret, fail);\n\n  // Then to remote ones when using PXN\n  if (ncclPxnDisable(comm) == 0) {\n    int nranks;\n    NCCLCHECKGOTO(ncclTopoGetPxnRanks(comm, &pxnPeers, &nranks), ret, fail);\n    for (int r=0; r<nranks; r++) {\n      tpProxyRank = comm->topParentRanks[pxnPeers[r]];\n      NCCLCHECKGOTO(ncclProxyConnect(comm, TRANSPORT_NET, 1, tpProxyRank, &proxyConn), ret, fail);\n      NCCLCHECKGOTO(ncclProxyCallBlocking(comm, &proxyConn, ncclProxyMsgSharedInit, &comm->p2pnChannels, sizeof(int), NULL, 0), ret, fail);\n    }\n  }\n\n  if (comm->intraRank == 0) { // Load ncclParamLaunchMode\n    const char* str = ncclGetEnv(\"NCCL_LAUNCH_MODE\");\n    enum ncclLaunchMode mode, modeOld;\n    if (str && strcasecmp(str, \"GROUP\") == 0) {\n      mode = ncclLaunchModeGroup;\n    } else {\n      mode = ncclLaunchModeParallel;\n    }\n    // In theory we could be racing with other communicators not associated with\n    // this one if the user is connecting to multiple ncclUniqueId's concurrently.\n    modeOld = __atomic_exchange_n(&ncclParamLaunchMode, mode, __ATOMIC_RELAXED);\n    if (modeOld == ncclLaunchModeInvalid && str && str[0]!='\\0') {\n      INFO(NCCL_ENV, \"NCCL_LAUNCH_MODE set by environment to %s\", mode == ncclLaunchModeParallel ? \"PARALLEL\" : \"GROUP\");\n    }\n  }\n\n  // Call devCommSetup before the last barrier, making sure we don't have a thread running in front and starting to\n  // launch NCCL kernels before all cuda mem allocation is complete. That could cause a deadlock.\n  NCCLCHECKGOTO(devCommSetup(comm), ret, fail);\n\n  /* Local intra-node barrier */\n  NCCLCHECKGOTO(bootstrapIntraNodeBarrier(comm->bootstrap, comm->localRankToRank, comm->localRank, comm->localRanks, comm->localRankToRank[0]), ret, fail);\n\n  // We should have allocated all buffers, collective fifos, ... we can\n  // restore the affinity.\n  TRACE(NCCL_INIT, \"rank %d nranks %d - DONE\", rank, nranks);\n\nexit:\n  if (CPU_COUNT(&comm->cpuAffinity)) sched_setaffinity(0, sizeof(cpu_set_t), &affinitySave);\n  /* If split resource is shared, we are not able to unlink the proxy ops pool here since the child comm can\n   * attach the proxy ops pool of parent at any time; otherwise, unlink it here to make sure the pool will be\n   * properly cleaned up. */\n  if (comm->sharedRes->owner == comm && !comm->config.splitShare && ret == ncclSuccess) ncclProxyShmUnlink(comm);\n  free(allTopoRanks);\n  free(nodesTreePatterns);\n  free(nodesFirstRank);\n  free(allGather3Data);\n  free(rings);\n  free(nvbPeers);\n  free(pxnPeers);\n  return ret;\nfail:\n  goto exit;\n}\n\nNCCL_PARAM(SetStackSize, \"SET_STACK_SIZE\", 0);\nNCCL_PARAM(CGAClusterSize, \"CGA_CLUSTER_SIZE\", NCCL_CONFIG_UNDEF_INT);\n// Match config max/minCTAs\nNCCL_PARAM(MaxCTAs, \"MAX_CTAS\", NCCL_CONFIG_UNDEF_INT);\nNCCL_PARAM(MinCTAs, \"MIN_CTAS\", NCCL_CONFIG_UNDEF_INT);\n#define NCCL_MAX_CGA_CLUSTER_SIZE 8\n\nstruct ncclCommInitRankAsyncJob {\n  struct ncclAsyncJob base;\n  struct ncclComm* comm;\n  struct ncclComm** newcomm;\n  int cudaDev;\n  // For ncclCommInitRank\n  int nranks, myrank;\n  ncclUniqueId commId;\n  // for ncclCommSplit\n  struct ncclComm* parent;\n  int color, key;\n};\n\nstruct ncclCommFinalizeAsyncJob {\n  struct ncclAsyncJob base;\n  ncclComm_t comm;\n};\n\nNCCL_PARAM(CommSplitShareResources, \"COMM_SPLIT_SHARE_RESOURCES\", NCCL_CONFIG_UNDEF_INT);\n\nstatic ncclResult_t commGetSplitInfo(struct ncclComm* comm, struct ncclComm* parent, int color, int key, int* nRanksRet, int* myRankRet, int* parentRanksRet) {\n  int* colors = NULL;\n  int* keys = NULL;\n  int nRanks = 0, myRank = 0;\n  ncclResult_t ret = ncclSuccess;\n\n  NCCLCHECKGOTO(ncclCalloc(&colors, parent->nRanks), ret, fail);\n  NCCLCHECKGOTO(ncclCalloc(&keys, parent->nRanks), ret, fail);\n\n  // Compute nRanks, my rank and the ranks (of the original comm) before and after me\n  colors[parent->rank] = color;\n  keys[parent->rank] = key;\n  NCCLCHECKGOTO(bootstrapAllGather(parent->bootstrap, colors, sizeof(int)), ret, fail);\n  NCCLCHECKGOTO(bootstrapAllGather(parent->bootstrap, keys, sizeof(int)), ret, fail);\n\n  // Negative color does not create a new comm. Return now.\n  if (color == NCCL_SPLIT_NOCOLOR) goto exit;\n\n  memset(parentRanksRet, 0xff, sizeof(int) * parent->nRanks);\n  for (int i = 0; i < parent->nRanks; i++) {\n    if (colors[i] != color) continue;\n    // Find where to insert this rank\n    int insert = 0;\n    while (insert < nRanks && keys[parentRanksRet[insert]] <= keys[i]) insert++;\n    // Shift ranks by one after insert\n    for (int r = nRanks; r > insert; r--) parentRanksRet[r] = parentRanksRet[r - 1];\n    // Insert our rank\n    parentRanksRet[insert] = i;\n    nRanks++;\n  }\n\n  for (int i = 0; i < nRanks; i++) {\n    if (parentRanksRet[i] == parent->rank) myRank = i;\n  }\n\n  *nRanksRet = nRanks;\n  *myRankRet = myRank;\n\nexit:\n  free(colors);\n  free(keys);\n  return ret;\nfail:\n  goto exit;\n}\n\nstatic ncclResult_t ncclCommInitRankFunc(struct ncclAsyncJob* job_) {\n  struct ncclCommInitRankAsyncJob* job = (struct ncclCommInitRankAsyncJob*)job_;\n  ncclComm_t comm = job->comm;\n  ncclResult_t res = ncclSuccess;\n  int archMajor, archMinor;\n  size_t maxLocalSizeBytes = 0;\n  int cudaDev = job->cudaDev;\n  int* parentRanks = NULL;\n  int cudaArch;\n\n  CUDACHECKGOTO(cudaSetDevice(cudaDev), res, fail);\n  CUDACHECKGOTO(cudaDeviceGetAttribute(&archMajor, cudaDevAttrComputeCapabilityMajor, cudaDev), res, fail);\n  CUDACHECKGOTO(cudaDeviceGetAttribute(&archMinor, cudaDevAttrComputeCapabilityMinor, cudaDev), res, fail);\n  cudaArch = 100*archMajor + 10*archMinor;\n\n  NCCLCHECK(ncclInitKernelsForDevice(cudaArch, &maxLocalSizeBytes));\n  // Set the maximum kernel stack size of all kernels to avoid\n  // a CUDA memory reconfig on load (c.f. NVSHMEM issue)\n  if (maxLocalSizeBytes > 0 && ncclParamSetStackSize() == 1) {\n    TRACE(NCCL_INIT, \"Setting cudaLimitStackSize to %zi\", maxLocalSizeBytes);\n    CUDACHECKIGNORE(cudaDeviceSetLimit(cudaLimitStackSize, maxLocalSizeBytes));\n  }\n\n  if (job->parent) {\n    NCCLCHECKGOTO(ncclCalloc(&parentRanks, job->parent->nRanks), res, fail);\n    NCCLCHECKGOTO(commGetSplitInfo(comm, job->parent, job->color, job->key, &job->nranks, &job->myrank, parentRanks), res, fail);\n    // Negative color does not create a new comm object. We needed to take part in the allgather, but we're done now.\n    if (job->color == NCCL_SPLIT_NOCOLOR) goto exit;\n    snprintf((char*)&job->commId, sizeof(job->commId), \"%016lx-%d\", job->parent->commHash, job->color);\n    NCCLCHECKGOTO(commAlloc(comm, job->parent, job->nranks, job->myrank), res, fail);\n    NCCLCHECKGOTO(bootstrapSplit((struct ncclBootstrapHandle*)&job->commId, comm, job->parent, job->color, job->key, parentRanks), res, fail);\n  } else {\n    NCCLCHECKGOTO(commAlloc(comm, NULL, job->nranks, job->myrank), res, fail);\n    NCCLCHECKGOTO(bootstrapInit((struct ncclBootstrapHandle*)&job->commId, comm), res, fail);\n  }\n\n  comm->cudaArch = cudaArch;\n  comm->commHash = getHash(job->commId.internal, NCCL_UNIQUE_ID_BYTES);\n\n  if (job->parent) {\n    INFO(NCCL_INIT,\"ncclCommSplit comm %p rank %d nranks %d cudaDev %d nvmlDev %d busId %lx parent %p color %d key %d commId 0x%llx - Init START\",\n    comm, comm->rank, comm->nRanks, comm->cudaDev, comm->nvmlDev, comm->busId, job->parent, job->color, job->key, (unsigned long long)hashUniqueId(job->commId));\n  } else {\n    INFO(NCCL_INIT,\"ncclCommInitRank comm %p rank %d nranks %d cudaDev %d nvmlDev %d busId %lx commId 0x%llx - Init START\",\n    comm, comm->rank, comm->nRanks, comm->cudaDev, comm->nvmlDev, comm->busId, (unsigned long long)hashUniqueId(job->commId));\n  }\n\n  NCCLCHECKGOTO(initTransportsRank(comm, job->parent), res, fail);\n\n  NCCLCHECKGOTO(ncclTunerPluginLoad(&comm->tuner), res, fail);\n  if (comm->tuner) {\n    NCCLCHECK(comm->tuner->init(comm->nRanks, comm->nNodes, ncclDebugLog, &comm->tunerContext));\n  }\n\n  // update communicator state\n  comm->initState = ncclSuccess;\n\n  // Trace this call for replay tool\n  if (job->parent) {\n    /* unlink child abort flag. */\n    __atomic_store_n(&job->parent->childAbortFlag, NULL, __ATOMIC_RELEASE);\n    TRACE_CALL(\"ncclCommSplit(%p, %d, %d, %p, %d, %d)\",\n                job->parent, job->color, job->key, comm, comm->rank, comm->nRanks);\n  } else {\n    TRACE_CALL(\"ncclCommInitRank(%p, %d, 0x%llx, %d, %d)\",\n                comm, comm->nRanks, (unsigned long long)hashUniqueId(job->commId), comm->rank, comm->cudaDev);\n  }\n\n  if (job->parent) {\n    INFO(NCCL_INIT,\"ncclCommSplit comm %p rank %d nranks %d cudaDev %d nvmlDev %d busId %lx parent %p color %d key %d commId 0x%llx - Init COMPLETE\",\n    comm, comm->rank, comm->nRanks, comm->cudaDev, comm->nvmlDev, comm->busId, job->parent, job->color, job->key, (unsigned long long)hashUniqueId(job->commId));\n  } else {\n    INFO(NCCL_INIT,\"ncclCommInitRank comm %p rank %d nranks %d cudaDev %d nvmlDev %d busId %lx commId 0x%llx - Init COMPLETE\",\n    comm, comm->rank, comm->nRanks, comm->cudaDev, comm->nvmlDev, comm->busId, (unsigned long long)hashUniqueId(job->commId));\n  }\n\n  tracepoint(nccl, commInit, comm->commHash, comm->localRanks, comm->nRanks, comm->nChannels, comm->p2pnChannels, comm->p2pnChannelsPerPeer);\n  int ringChannels[32];\n  int treeChannels[32*4];\n  for (int i=0; i<comm->nChannels; i++) {\n      ringChannels[i] = comm->channels[i].ring.next;\n      treeChannels[i*4] = comm->channels[i].tree.up;\n      treeChannels[i*4+1] = comm->channels[i].tree.down[0];\n      treeChannels[i*4+2] = comm->channels[i].tree.down[1];\n      treeChannels[i*4+3] = comm->channels[i].tree.down[2];\n  }\n  tracepoint(nccl, commChannel, comm->commHash, comm->rank, comm->nChannels, ringChannels, treeChannels);\n\nexit:\n  if (job->newcomm) {\n    /* assign it to user pointer. */\n    __atomic_store_n(job->newcomm, comm, __ATOMIC_RELEASE);\n  }\n  free(parentRanks);\n  return res;\nfail:\n  comm->initState = res;\n  goto exit;\n}\n\n#define NCCL_CONFIG_DEFAULT(config, field, undef, defvalue, fieldStr, format) \\\n  if (config->field == undef) { \\\n    config->field = defvalue; \\\n  } else { \\\n    INFO(NCCL_ENV, \"Comm config \" fieldStr \" set to \" format, config->field); \\\n  }\n\nstatic ncclResult_t envConfigOverride(ncclComm_t comm) {\n  ncclResult_t ret = ncclSuccess;\n  const char* tmpNetName = comm->config.netName;\n  const char* envNetName;\n  int blockingEnv;\n  int cgaClusterSizeEnv;\n  int minCTAsEnv;\n  int maxCTAsEnv;\n  int splitShareEnv;\n\n  /* override configuration from env variable. */\n  blockingEnv = ncclParamCommBlocking();\n  if (blockingEnv == 0 || blockingEnv == 1)\n    comm->config.blocking = blockingEnv;\n\n  cgaClusterSizeEnv = ncclParamCGAClusterSize();\n  if (0 <= cgaClusterSizeEnv && cgaClusterSizeEnv <= NCCL_MAX_CGA_CLUSTER_SIZE) {\n    comm->config.cgaClusterSize = cgaClusterSizeEnv;\n  } else if (cgaClusterSizeEnv > NCCL_MAX_CGA_CLUSTER_SIZE) {\n    WARN(\"NCCL_CGA_CLUSTER_SIZE value %d is too big. Limiting value to %d.\", cgaClusterSizeEnv, NCCL_MAX_CGA_CLUSTER_SIZE);\n    comm->config.cgaClusterSize = NCCL_MAX_CGA_CLUSTER_SIZE;\n  }\n\n  minCTAsEnv = ncclParamMinCTAs();\n  if (minCTAsEnv != NCCL_CONFIG_UNDEF_INT) {\n    comm->config.minCTAs = minCTAsEnv;\n  }\n\n  maxCTAsEnv = ncclParamMaxCTAs();\n  if (maxCTAsEnv != NCCL_CONFIG_UNDEF_INT) {\n    comm->config.maxCTAs = maxCTAsEnv;\n  }\n\n  envNetName = ncclGetEnv(\"NCCL_NET\");\n  if (envNetName)\n    tmpNetName = envNetName;\n  if (tmpNetName != NULL) {\n    int netNameLen = strlen(tmpNetName) + 1;\n    comm->config.netName = (char*)malloc(netNameLen);\n    memcpy((void*)comm->config.netName, tmpNetName, netNameLen);\n  } else {\n    comm->config.netName = NULL;\n  }\n\n  splitShareEnv = ncclParamCommSplitShareResources();\n  if (splitShareEnv != NCCL_CONFIG_UNDEF_INT) {\n    comm->config.splitShare = splitShareEnv;\n  }\n\n  /* cap channels if needed */\n  if (comm->config.minCTAs > MAXCHANNELS) {\n    WARN(\"minCTAs %d is larger than #channels upper limit %d, cap it to %d\", comm->config.minCTAs, MAXCHANNELS, MAXCHANNELS);\n    comm->config.minCTAs = MAXCHANNELS;\n  }\n\n  if (comm->config.maxCTAs > MAXCHANNELS) {\n    WARN(\"maxCTAs %d is larger than #channels upper limit %d, cap it to %d\", comm->config.maxCTAs, MAXCHANNELS, MAXCHANNELS);\n    comm->config.maxCTAs = MAXCHANNELS;\n  }\n\n  if (comm->config.minCTAs > comm->config.maxCTAs) {\n    WARN(\"minCTAs %d is larger than maxCTAs %d, set both to %d\", comm->config.minCTAs, comm->config.maxCTAs, comm->config.maxCTAs);\n    comm->config.minCTAs = comm->config.maxCTAs;\n  }\n\n  if (comm->config.splitShare != 1 && comm->config.splitShare != 0) {\n    WARN(\"splitShare %d is not a valid value 0/1, set it to 0\\n\", comm->config.splitShare);\n    comm->config.splitShare = 0;\n  }\n\n  return ret;\n}\n\nstatic ncclResult_t copyCommConfig(ncclComm_t childComm, ncclComm_t parnet) {\n  memcpy(&childComm->config, &parnet->config, sizeof(ncclConfig_t));\n  NCCLCHECK(envConfigOverride(childComm));\n  return ncclSuccess;\n}\n\nstatic ncclResult_t parseCommConfig(ncclComm_t comm, ncclConfig_t *config) {\n  ncclResult_t ret = ncclSuccess;\n  /* config must not be NULL in this function */\n  ncclConfig_t defaultConfig = NCCL_CONFIG_INITIALIZER;\n  ncclConfig_t internalConfig = NCCL_CONFIG_INITIALIZER;\n  ncclConfig_t *internalConfigPtr;\n  size_t realSize;\n\n  internalConfigPtr = &internalConfig;\n  if (config) {\n    memcpy((void*)&realSize, (void*)config, sizeof(size_t));\n    realSize = realSize > sizeof(ncclConfig_t) ? sizeof(ncclConfig_t) : realSize;\n    memcpy((void*)internalConfigPtr, (void*)config, realSize);\n    if (internalConfigPtr->magic != 0xcafebeef) {\n      WARN(\"ncclConfig_t argument not initialized via NCCL_CONFIG_INITIALIZER\");\n      ret = ncclInvalidArgument;\n      goto fail;\n    }\n\n    /* check version. */\n    if (internalConfigPtr->version < NCCL_VERSION(2, 14, 0)) {\n      internalConfigPtr->blocking = defaultConfig.blocking;\n    }\n\n    if (internalConfigPtr->version < NCCL_VERSION(2, 17, 0)) {\n      internalConfigPtr->cgaClusterSize = defaultConfig.cgaClusterSize;\n      internalConfigPtr->minCTAs = defaultConfig.minCTAs;\n      internalConfigPtr->maxCTAs = defaultConfig.maxCTAs;\n      internalConfigPtr->netName = defaultConfig.netName;\n    }\n  }\n\n  /* check input config attributes, -1 means user-undefined and we should use default value from NCCL. */\n  if (internalConfigPtr->blocking != NCCL_CONFIG_UNDEF_INT && internalConfigPtr->blocking != 0 && internalConfigPtr->blocking != 1) {\n    WARN(\"Invalid config blocking attribute value %d\", internalConfigPtr->blocking);\n    ret = ncclInvalidArgument;\n    goto fail;\n  }\n\n  if (internalConfigPtr->cgaClusterSize != NCCL_CONFIG_UNDEF_INT && internalConfigPtr->cgaClusterSize < 0) {\n    WARN(\"Invalid config cgaClusterSize attribute value %d\", internalConfigPtr->cgaClusterSize);\n    ret = ncclInvalidArgument;\n    goto fail;\n  }\n\n  if ((internalConfigPtr->minCTAs != NCCL_CONFIG_UNDEF_INT &&\n    internalConfigPtr->minCTAs <= 0) ||\n    (internalConfigPtr->maxCTAs != NCCL_CONFIG_UNDEF_INT &&\n      internalConfigPtr->maxCTAs <= 0) ||\n    (internalConfigPtr->minCTAs > internalConfigPtr->maxCTAs)) {\n    WARN(\"Invalid config min/max channels attribute value %d/%d\", internalConfigPtr->minCTAs, internalConfigPtr->maxCTAs);\n    ret = ncclInvalidArgument;\n    goto fail;\n  }\n\n  if (internalConfigPtr->splitShare != NCCL_CONFIG_UNDEF_INT && internalConfigPtr->splitShare != 0 && internalConfigPtr->splitShare != 1) {\n    WARN(\"Invalid config splitShare attribute value %d\", internalConfigPtr->splitShare);\n    ret = ncclInvalidArgument;\n    goto fail;\n  }\n\n  /* default config value can be tuned on different platform. */\n  NCCL_CONFIG_DEFAULT(internalConfigPtr, blocking, NCCL_CONFIG_UNDEF_INT, 1, \"Blocking\", \"%d\");\n  NCCL_CONFIG_DEFAULT(internalConfigPtr, cgaClusterSize, NCCL_CONFIG_UNDEF_INT, 4, \"CGA cluster size\", \"%d\");\n  NCCL_CONFIG_DEFAULT(internalConfigPtr, minCTAs, NCCL_CONFIG_UNDEF_INT, 1, \"Min CTAs\", \"%d\");\n  NCCL_CONFIG_DEFAULT(internalConfigPtr, maxCTAs, NCCL_CONFIG_UNDEF_INT, MAXCHANNELS, \"Max CTAs\", \"%d\");\n  NCCL_CONFIG_DEFAULT(internalConfigPtr, netName, NCCL_CONFIG_UNDEF_PTR, NULL, \"Net name\", \"%s\");\n  NCCL_CONFIG_DEFAULT(internalConfigPtr, splitShare, NCCL_CONFIG_UNDEF_INT, 0, \"Split share\", \"%d\");\n\n  /* assign config to communicator */\n  comm->config.blocking = internalConfigPtr->blocking;\n  comm->config.cgaClusterSize = internalConfigPtr->cgaClusterSize;\n  comm->config.minCTAs = internalConfigPtr->minCTAs;\n  comm->config.maxCTAs = internalConfigPtr->maxCTAs;\n  comm->config.netName = internalConfigPtr->netName;\n  comm->config.splitShare = internalConfigPtr->splitShare;\n\n  NCCLCHECKGOTO(envConfigOverride(comm), ret, fail);\n\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nstatic ncclResult_t ncclCommInitRankDev(ncclComm_t* newcomm, int nranks, ncclUniqueId commId, int myrank, int cudaDev, ncclConfig_t *config) {\n  ncclResult_t res = ncclSuccess;\n  ncclComm_t comm = NULL;\n  struct ncclCommInitRankAsyncJob *job = NULL;\n  const char* env = ncclGetEnv(\"NCCL_COMM_ID\");\n  if (env && myrank == 0) {\n    INFO(NCCL_ENV, \"NCCL_COMM_ID set by environment to %s\", env);\n    NCCLCHECKGOTO(bootstrapCreateRoot((struct ncclBootstrapHandle*)&commId, true), res, fail);\n  }\n\n  NCCLCHECKGOTO(ncclInit(), res, fail);\n  if (myrank == 0) showVersion();\n\n  // Make sure the CUDA runtime is initialized.\n  CUDACHECKGOTO(cudaFree(NULL), res, fail);\n\n  NCCLCHECKGOTO(PtrCheck(newcomm, \"CommInitRank\", \"newcomm\"), res, fail);\n  NCCLCHECKGOTO(PtrCheck(config, \"CommInitRank\", \"config\"), res, fail);\n  if (nranks < 1 || myrank < 0 || myrank >= nranks) {\n    WARN(\"Invalid rank requested : %d/%d\", myrank, nranks);\n    res = ncclInvalidArgument;\n    goto fail;\n  }\n\n  NCCLCHECKGOTO(ncclCalloc(&comm, 1), res, fail);\n  comm->startMagic = comm->endMagic = NCCL_MAGIC; // Used to detect comm corruption.\n  NCCLCHECKGOTO(ncclCudaHostCalloc((uint32_t**)&comm->abortFlag, 1), res, fail);\n  NCCLCHECKGOTO(ncclCalloc((uint32_t**)&comm->abortFlagRefCount, 1), res, fail);\n  *comm->abortFlagRefCount = 1;\n  NCCLCHECKGOTO(parseCommConfig(comm, config), res, fail);\n  /* start with ncclInternalError and will be changed to ncclSuccess if init succeeds. */\n  comm->initState = ncclInternalError;\n  *newcomm = comm;\n\n  NCCLCHECKGOTO(ncclCalloc(&job, 1), res, fail);\n  job->comm = comm;\n  job->nranks = nranks;\n  job->commId = commId; // C++ struct assignment\n  job->myrank = myrank;\n  job->cudaDev = cudaDev;\n  NCCLCHECKGOTO(ncclAsyncLaunch(&job->base, ncclCommInitRankFunc, NULL, free, comm), res, fail);\n\nexit:\n  return ncclGroupErrCheck(res);\nfail:\n  if (comm) {\n    if (comm->abortFlag) ncclCudaHostFree((void *)comm->abortFlag);\n    if (comm->abortFlagRefCount) free(comm->abortFlagRefCount);\n    free(comm);\n  }\n  if (newcomm) *newcomm = NULL;\n  goto exit;\n}\n\nstruct NvtxParamsCommInitRank\n{\n  int rank;\n  int nranks;\n  int cudaDev;\n};\nconstexpr nvtxPayloadSchemaEntry_t CommInitRankSchema[] = {\n  {0, NVTX_PAYLOAD_ENTRY_TYPE_INT, \"Rank\"},\n  {0, NVTX_PAYLOAD_ENTRY_TYPE_INT, \"No. of ranks\", nullptr, 0, offsetof(NvtxParamsCommInitRank, nranks)},\n  {0, NVTX_PAYLOAD_ENTRY_TYPE_INT, \"CUDA device\", nullptr, 0, offsetof(NvtxParamsCommInitRank, cudaDev)},\n};\n\nNCCL_API(ncclResult_t, ncclCommInitRank, ncclComm_t* newcomm, int nranks, ncclUniqueId commId, int myrank);\nncclResult_t ncclCommInitRank(ncclComm_t* newcomm, int nranks, ncclUniqueId commId, int myrank) {\n  // Load the CUDA driver and dlsym hooks (can fail on old drivers)\n  (void)ncclCudaLibraryInit();\n\n  int cudaDev;\n  ncclConfig_t config = NCCL_CONFIG_INITIALIZER;\n  CUDACHECK(cudaGetDevice(&cudaDev));\n\n  NvtxParamsCommInitRank payload{myrank, nranks, cudaDev};\n  NVTX3_FUNC_WITH_PARAMS(CommInitRank, CommInitRankSchema, payload)\n\n  NCCLCHECK(ncclCommInitRankDev(newcomm, nranks, commId, myrank, cudaDev, &config));\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommInitAll, ncclComm_t* comms, int ndev, const int* devlist);\nncclResult_t ncclCommInitAll(ncclComm_t* comms, int ndev, const int* devlist) {\n  ncclResult_t ret = ncclSuccess;\n  int totalnDev;\n  int *gpuFlags = NULL;\n  ncclConfig_t config = NCCL_CONFIG_INITIALIZER;\n\n  constexpr nvtxPayloadSchemaEntry_t CommInitAllSchema[] = {\n    {0, NVTX_PAYLOAD_ENTRY_TYPE_INT, \"No. of devices\"}\n  };\n  NVTX3_FUNC_WITH_PARAMS(CommInitAll, CommInitAllSchema, ndev)\n\n  // Load the CUDA driver and dlsym hooks (can fail on old drivers)\n  (void)ncclCudaLibraryInit();\n\n  NCCLCHECKGOTO(PtrCheck(comms, \"CommInitAll\", \"comms\"), ret, fail);\n  if (ndev < 0) {\n    WARN(\"Invalid device count requested : %d\", ndev);\n    ret = ncclInvalidArgument;\n    goto fail;\n  }\n\n  CUDACHECKGOTO(cudaGetDeviceCount(&totalnDev), ret, fail);\n  if (devlist) {\n    NCCLCHECKGOTO(ncclCalloc(&gpuFlags, totalnDev), ret, fail);\n    for (int i = 0; i < ndev; ++i) {\n      /* invalid device check. */\n      if (devlist[i] < 0 || devlist[i] >= totalnDev) {\n        ret = ncclUnhandledCudaError;\n        goto fail;\n      }\n\n      /* duplicate device check. */\n      if (gpuFlags[devlist[i]] != 0) {\n        ret = ncclInvalidUsage;\n        goto fail;\n      }\n\n      gpuFlags[devlist[i]] = 1;\n    }\n    free(gpuFlags);\n    gpuFlags = nullptr;\n  }\n\n  ncclUniqueId uniqueId;\n  NCCLCHECKGOTO(ncclGetUniqueId(&uniqueId), ret, fail);\n  NCCLCHECKGOTO(ncclGroupStart(), ret, fail);\n  for (int i=0; i<ndev; i++) {\n    // Ignore return codes .. we need to call ncclGroupEnd to clean up anyway\n    ncclCommInitRankDev(comms+i, ndev, uniqueId, i, devlist ? devlist[i] : i, &config);\n  }\n  NCCLCHECKGOTO(ncclGroupEnd(), ret, fail);\n\nfail:\n  free(gpuFlags);\n  return ret;\n}\n\nncclResult_t ncclCommSetAsyncError(ncclComm_t comm, ncclResult_t nextState) {\n  if (nextState < 0 || nextState >= ncclNumResults || comm == NULL) {\n    WARN(\"ncclCommSetAsyncError: error comm %p sets state %d\", comm, nextState);\n    return ncclInvalidArgument;\n  }\n\n  __atomic_store_n(&comm->asyncResult, nextState, __ATOMIC_RELEASE);\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommInitRankConfig, ncclComm_t* comm, int nranks, ncclUniqueId commId, int myrank, ncclConfig_t *config);\nncclResult_t ncclCommInitRankConfig(ncclComm_t *newcomm, int nranks, ncclUniqueId commId, int myrank, ncclConfig_t *config) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n  int cudaDev;\n  ncclResult_t ret = ncclSuccess;\n  ncclConfig_t internalConfig = NCCL_CONFIG_INITIALIZER;\n  ncclConfig_t *internalConfigPtr = NULL;\n  NCCLCHECK(ncclGroupStartInternal());\n\n  (void)ncclCudaLibraryInit();\n  CUDACHECKGOTO(cudaGetDevice(&cudaDev), ret, fail);\n\n  if (config == NULL)\n    internalConfigPtr = &internalConfig;\n  else\n    internalConfigPtr = config;\n  NCCLCHECKGOTO(ncclCommInitRankDev(newcomm, nranks, commId, myrank, cudaDev, internalConfigPtr), ret, fail);\n\nexit:\n  ncclGroupErrCheck(ret);\n  NCCLCHECK(ncclGroupEndInternal());\n  if (newcomm && *newcomm && !(*newcomm)->config.blocking) (void) ncclCommGetAsyncError(*newcomm, &ret);\n  return ret;\nfail:\n  if (newcomm && *newcomm && !(*newcomm)->config.blocking) (void) ncclCommSetAsyncError(*newcomm, ret);\n  goto exit;\n}\n\nstatic ncclResult_t commDestroySync(struct ncclAsyncJob* job_) {\n  struct ncclCommFinalizeAsyncJob* job = (struct ncclCommFinalizeAsyncJob*) job_;\n  ncclComm_t comm = job->comm;\n  int savedDevice;\n  int commDevice = comm->cudaDev;\n  ncclResult_t ret = ncclSuccess;\n\n  CUDACHECKGOTO(cudaGetDevice(&savedDevice), ret, fail);\n  if (savedDevice != commDevice) {\n    CUDACHECKGOTO(cudaSetDevice(commDevice), ret, fail);\n  }\n\n  TRACE(NCCL_INIT, \"Destroying comm %p rank %d abortFlag %d asyncResult %d\", comm, comm->rank, *comm->abortFlag, comm->asyncResult);\n\n  if (comm->initState == ncclSuccess) {\n    NCCLCHECKGOTO(ncclStrongStreamSynchronize(&comm->sharedRes->hostStream), ret, fail);\n    NCCLCHECKGOTO(ncclStrongStreamSynchronize(&comm->sharedRes->deviceStream), ret, fail);\n  }\n  NCCLCHECKGOTO(ncclCommPollCallbacks(comm, false), ret, fail);\n  // And keep polling until all graphs referencing us die.\n  while (comm->persistentRefs != 0) {\n    NCCLCHECKGOTO(ncclCommPollCallbacks(comm, /*waitSome=*/true), ret, fail);\n  }\n\n  if (savedDevice != commDevice) {\n    CUDACHECKGOTO(cudaSetDevice(savedDevice), ret, fail);\n  }\n\n  comm->finalizeCalled = true;\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nstatic ncclResult_t commCleanup(ncclComm_t comm) {\n  int savedDevice;\n  int commDevice = comm->cudaDev;\n\n  CUDACHECK(cudaGetDevice(&savedDevice));\n  if (savedDevice != commDevice) {\n    CUDACHECK(cudaSetDevice(commDevice));\n  }\n\n  if (comm->tuner != NULL) {\n    NCCLCHECK(comm->tuner->destroy(comm->tunerContext));\n    NCCLCHECK(ncclTunerPluginUnload(&comm->tuner));\n  }\n\n  NCCLCHECK(commFree(comm));\n\n  if (savedDevice != commDevice) {\n    CUDACHECK(cudaSetDevice(savedDevice));\n  }\n\n  return ncclSuccess;\n}\n\nstatic ncclResult_t commFinalize(ncclComm_t comm, bool userCalled) {\n  ncclResult_t ret = ncclSuccess;\n  struct ncclCommFinalizeAsyncJob *job = NULL;\n\n  /* launch async thread to finalize comm. */\n  NCCLCHECKGOTO(ncclCalloc(&job, 1), ret, fail);\n  job->comm = comm;\n\n  if (userCalled) {\n    NCCLCHECKGOTO(ncclAsyncLaunch(&job->base, commDestroySync, NULL, free, comm), ret, fail);\n  } else {\n    NCCLCHECKGOTO(commDestroySync(&job->base), ret, fail);\n    free(job);\n  }\n\nexit:\n  return ncclGroupErrCheck(ret);\nfail:\n  goto exit;\n}\n\nNCCL_API(ncclResult_t, ncclCommFinalize, ncclComm_t comm);\nncclResult_t ncclCommFinalize(ncclComm_t comm) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n  ncclResult_t ret = ncclSuccess;\n\n  NCCLCHECK(ncclGroupStartInternal());\n  if (comm == NULL) goto exit;\n\n  /* wait comm ready before finalize. */\n  NCCLCHECKGOTO(ncclCommEnsureReady(comm), ret, fail);\n\n  /* prevent double finalize. */\n  if (comm->finalizeCalled) {\n    ret = ncclInvalidArgument;\n    goto fail;\n  }\n\n  /* finalize comm. */\n  ret = commFinalize(comm, true);\n\nexit:\n  ncclGroupErrCheck(ret);\n  NCCLCHECK(ncclGroupEndInternal());\n  if (comm && !comm->config.blocking) { NCCLCHECK(ncclCommGetAsyncError(comm, &ret)) };\n  return ret;\nfail:\n  if (comm && !comm->config.blocking) (void) ncclCommSetAsyncError(comm, ret);\n  goto exit;\n}\n\nstatic ncclResult_t commReclaim(ncclComm_t comm) {\n  ncclResult_t ret = ncclSuccess;\n  ncclResult_t state;\n  int curRank; /* Debug info */\n\n  NCCLCHECKGOTO(ncclCommGetAsyncError(comm, &state), ret, fail);\n  TRACE(NCCL_INIT, \"commReclaim: reclaim comm %p rank %d state %d\", comm, comm->rank, state);\n  if (state == ncclSuccess && __atomic_load_n(comm->abortFlag, __ATOMIC_RELAXED) == 0 && comm->finalizeCalled == false) {\n    /* user does not call ncclCommFinalize and this is a normal comm destroy. ncclCommDestroy\n     * should be nonblocking until last call of ncclCommDestroy. */\n    NCCLCHECKGOTO(commFinalize(comm, false), ret, fail);\n  }\n\n  if (comm->intraComm0 != NULL) {\n    int curRankCnt;\n    int intraRanks = comm->intraRanks;\n    ncclComm_t intracomm0 = comm->intraComm0;\n    int *finalizeRankCnt = &intracomm0->finalizeRankCnt;\n\n    assert(intracomm0 != NULL && finalizeRankCnt != NULL);\n    curRankCnt = __atomic_add_fetch(finalizeRankCnt, 1, __ATOMIC_ACQ_REL);\n    if (curRankCnt == intraRanks) {\n      ncclComm_t curIntraComm;\n      ncclComm_t nextIntraComm = intracomm0;\n\n      /* this is  the last call to ncclCommDestroy/Abort, we need to make sure all comms\n       * in the process have been finalized before we free local resources. */\n      while (nextIntraComm) {\n        curIntraComm = nextIntraComm;\n        curRank = curIntraComm->rank;\n        nextIntraComm = nextIntraComm->intraNext;\n\n        if (curIntraComm->finalizeCalled == false) {\n          struct ncclCommFinalizeAsyncJob job;\n          job.comm = curIntraComm;\n          /* every comm aborts, commDestroySync should not be blocked. */\n          if ((ret = commDestroySync((struct ncclAsyncJob*) &job)) != ncclSuccess)\n            WARN(\"commReclaim: comm %p (rank = %d) in abort, error %d\", curIntraComm, curRank, ret);\n        }\n      }\n\n      /* ncclProxyStop() loop must be put after commDestroySync() loop. Namely, you cannot do:\n       *  while(...) {\n       *     commDestroySync(...);\n       *     ncclProxyStop(...);\n       *  }\n       * Considering one process multi-gpu case, we must guarantee all kernels are complete before\n       * we free proxy resources; otherwise, we will face invalid memory issues where proxy connection\n       * and related intermediate memory from one rank are freed but other ranks are still using it.\n       * This is not a problem for multi-process case, since intermediate memory is opened by CUDA IPC\n       * or mmap where memory free is guarded by CUDA driver and operating system, so we will not have\n       * invalid memory access issue. */\n      nextIntraComm = intracomm0;\n      while (nextIntraComm) {\n        curIntraComm = nextIntraComm;\n        curRank = curIntraComm->rank;\n        nextIntraComm = nextIntraComm->intraNext;\n\n        /* free intraprocess proxy resources. */\n        if ((ret = ncclProxyStop(curIntraComm)) != ncclSuccess) {\n          WARN(\"commReclaim: comm %p (rank = %d) destroys proxy resource error %d\", curIntraComm, curRank, ret);\n        }\n      }\n\n      /* free local resources. */\n      nextIntraComm = intracomm0;\n      while (nextIntraComm) {\n        curIntraComm = nextIntraComm;\n        curRank = curIntraComm->rank;\n        nextIntraComm = nextIntraComm->intraNext;\n\n        if ((ret = commCleanup(curIntraComm)) != ncclSuccess) {\n          WARN(\"commReclaim: cleanup comm %p rank %d failed in destroy/abort, error %d\", curIntraComm, curRank, ret);\n        }\n      }\n    }\n  }\n\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nNCCL_API(ncclResult_t, ncclCommDestroy, ncclComm_t comm);\nncclResult_t ncclCommDestroy(ncclComm_t comm) {\n  if (comm == NULL) {\n    NVTX3_FUNC_RANGE_IN(nccl_domain);\n    return ncclSuccess;\n  }\n\n  int rank = comm->rank, nranks = comm->nRanks, cudaDev = comm->cudaDev;\n\n  NvtxParamsCommInitRank payload{rank, nranks, cudaDev};\n  NVTX3_FUNC_WITH_PARAMS(CommDestroy, CommInitRankSchema, payload)\n\n  int64_t busId = comm->busId;\n  TRACE(NCCL_INIT, \"comm %p rank %d nRanks %d cudaDev %d busId %lx\", comm, rank, nranks, cudaDev, busId);\n  // Try and prevent a double free of the comm struct (user error)\n  if (comm->rank == -1 || comm->nRanks == -1 || comm->cudaDev == -1 || comm->busId == -1) {\n    WARN(\"comm %p has already been destroyed\", comm);\n    return ncclInvalidArgument;\n  }\n\n  /* init thread must be joined before we destroy the comm. */\n  NCCLCHECK(ncclCommEnsureReady(comm));\n\n  NCCLCHECK(commReclaim(comm));\n  INFO(NCCL_INIT,\"comm %p rank %d nranks %d cudaDev %d busId %lx - Destroy COMPLETE\", comm, rank, nranks, cudaDev, busId);\n\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommAbort, ncclComm_t comm);\nncclResult_t ncclCommAbort(ncclComm_t comm) {\n  if (comm == NULL) {\n    NVTX3_FUNC_RANGE_IN(nccl_domain);\n    return ncclSuccess;\n  }\n\n  volatile uint32_t* childAbortFlag;\n  int rank = comm->rank, nranks = comm->nRanks, cudaDev = comm->cudaDev;\n\n  NvtxParamsCommInitRank payload{rank, nranks, cudaDev};\n  NVTX3_FUNC_WITH_PARAMS(CommAbort, CommInitRankSchema, payload)\n\n  int64_t busId = comm->busId;\n  TRACE(NCCL_INIT, \"comm %p rank %d nRanks %d cudaDev %d busId %lx\", comm, rank, nranks, cudaDev, busId);\n\n  // Ask anything that might still be running on the device to quit\n  childAbortFlag = __atomic_load_n(&comm->childAbortFlag, __ATOMIC_ACQUIRE);\n  if (childAbortFlag != NULL) {\n    __atomic_store_n(childAbortFlag, 1, __ATOMIC_RELAXED);\n  }\n  __atomic_store_n(comm->abortFlag, 1, __ATOMIC_RELAXED);\n  /* init thread must be joined before we destroy the comm,\n   * and we should ignore the init error here. */\n  ncclCommEnsureReady(comm);\n\n  (void) commReclaim(comm);\n  INFO(NCCL_INIT,\"comm %p rank %d nranks %d cudaDev %d busId %lx - Abort COMPLETE\", comm, rank, nranks, cudaDev, busId);\n\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommSplit, ncclComm_t comm, int color, int key, ncclComm_t *newcomm, ncclConfig_t *config);\nncclResult_t ncclCommSplit(ncclComm_t comm, int color, int key, ncclComm_t *newcomm, ncclConfig_t *config) {\n  struct ncclCommInitRankAsyncJob *job = NULL;\n  struct ncclComm* childComm = NCCL_COMM_NULL;\n  ncclResult_t res = ncclSuccess;\n\n  NCCLCHECK(ncclGroupStartInternal());\n  NCCLCHECKGOTO(CommCheck(comm, \"CommSplit\", \"comm\"), res, fail);\n  NCCLCHECKGOTO(PtrCheck(newcomm, \"CommSplit\", \"newcomm\"), res, fail);\n  NCCLCHECKGOTO(ncclCommEnsureReady(comm), res, fail);\n\n  /* *newcomm should be NCCL_COMM_NULL until comm split fully complete. */\n  *newcomm = NCCL_COMM_NULL;\n  if (color == NCCL_SPLIT_NOCOLOR) {\n    INFO(NCCL_INIT, \"Rank %d has color with NCCL_SPLIT_NOCOLOR, not creating a new communicator\", comm->rank);\n  } else {\n    NCCLCHECKGOTO(ncclCalloc(&childComm, 1), res, fail);\n    childComm->startMagic = childComm->endMagic = NCCL_MAGIC;\n    if (comm->config.splitShare) {\n      childComm->abortFlag = comm->abortFlag;\n      childComm->abortFlagRefCount = comm->abortFlagRefCount;\n      comm->childAbortFlag = NULL;\n      ncclAtomicRefCountIncrement(comm->abortFlagRefCount);\n    } else {\n      NCCLCHECKGOTO(ncclCudaHostCalloc((uint32_t**)&childComm->abortFlag, 1), res, fail);\n      NCCLCHECKGOTO(ncclCalloc((uint32_t**)&childComm->abortFlagRefCount, 1), res, fail);\n      /* temporarily used to abort everything during child comm init. */\n      comm->childAbortFlag = childComm->abortFlag;\n      *childComm->abortFlagRefCount = 1;\n    }\n    if (config == NULL) {\n      NCCLCHECKGOTO(copyCommConfig(childComm, comm), res, fail);\n    } else {\n      NCCLCHECKGOTO(parseCommConfig(childComm, config), res, fail);\n    }\n\n    /* start with ncclInternalError and will be changed to ncclSuccess if init succeeds. */\n    childComm->initState = ncclInternalError;\n  }\n\n  NCCLCHECKGOTO(ncclCalloc(&job, 1), res, fail);\n  job->comm = childComm;\n  job->newcomm = newcomm;\n  job->parent = comm;\n  job->color = color;\n  job->key = key;\n  job->cudaDev = comm->cudaDev;\n  NCCLCHECKGOTO(ncclAsyncLaunch(&job->base, ncclCommInitRankFunc, NULL, free, comm), res, fail);\n\nexit:\n  ncclGroupErrCheck(res);\n  NCCLCHECK(ncclGroupEndInternal());\n  return res;\nfail:\n  if (childComm) {\n    if (comm && !comm->config.splitShare) {\n      if (childComm->abortFlag) ncclCudaHostFree((void*)childComm->abortFlag);\n      if (childComm->abortFlagRefCount) free(childComm->abortFlagRefCount);\n    }\n    free(childComm);\n  }\n  if (newcomm) *newcomm = NULL;\n  goto exit;\n}\n\nNCCL_API(const char*, ncclGetErrorString, ncclResult_t code);\nconst char* ncclGetErrorString(ncclResult_t code) {\n  switch (code) {\n    case ncclSuccess                : return \"no error\";\n    case ncclUnhandledCudaError     : return \"unhandled cuda error (run with NCCL_DEBUG=INFO for details)\";\n    case ncclSystemError            : return \"unhandled system error (run with NCCL_DEBUG=INFO for details)\";\n    case ncclInternalError          : return \"internal error - please report this issue to the NCCL developers\";\n    case ncclInvalidArgument        : return \"invalid argument (run with NCCL_DEBUG=WARN for details)\";\n    case ncclInvalidUsage           : return \"invalid usage (run with NCCL_DEBUG=WARN for details)\";\n    case ncclRemoteError            : return \"remote process exited or there was a network error\";\n    case ncclInProgress             : return \"NCCL operation in progress\";\n    default                         : return \"unknown result code\";\n  }\n}\n\n/* Returns a human-readable message of the last error that occurred.\n * comm is currently unused and can be set to NULL\n */\nNCCL_API(const char*, ncclGetLastError, const ncclComm_t comm);\nconst char* ncclGetLastError(ncclComm_t comm) {\n  return ncclLastError;\n}\n\nNCCL_API(ncclResult_t, ncclCommGetAsyncError, ncclComm_t comm, ncclResult_t *asyncError);\nncclResult_t ncclCommGetAsyncError(ncclComm_t comm, ncclResult_t *asyncError) {\n  NCCLCHECK(CommCheck(comm, \"ncclGetAsyncError\", \"comm\"));\n  NCCLCHECK(PtrCheck(asyncError, \"ncclGetAsyncError\", \"asyncError\"));\n\n  *asyncError = __atomic_load_n(&comm->asyncResult, __ATOMIC_ACQUIRE);\n  if (*asyncError == ncclSuccess && comm->proxyState) *asyncError = __atomic_load_n(&comm->proxyState->asyncResult, __ATOMIC_ACQUIRE);\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommCount, const ncclComm_t comm, int* count);\nncclResult_t ncclCommCount(const ncclComm_t comm, int* count) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n\n  NCCLCHECK(CommCheck(comm, \"CommCount\", \"comm\"));\n  NCCLCHECK(PtrCheck(count, \"CommCount\", \"count\"));\n\n  /* init thread must be joined before we access the attributes of comm. */\n  NCCLCHECK(ncclCommEnsureReady(comm));\n\n  *count = comm->nRanks;\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommCuDevice, const ncclComm_t comm, int* devid);\nncclResult_t ncclCommCuDevice(const ncclComm_t comm, int* devid) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n\n  NCCLCHECK(CommCheck(comm, \"CommCuDevice\", \"comm\"));\n  NCCLCHECK(PtrCheck(devid, \"CommCuDevice\", \"devid\"));\n\n  NCCLCHECK(ncclCommEnsureReady(comm));\n\n  *devid = comm->cudaDev;\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclCommUserRank, const ncclComm_t comm, int* rank);\nncclResult_t ncclCommUserRank(const ncclComm_t comm, int* rank) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n\n  NCCLCHECK(CommCheck(comm, \"CommUserRank\", \"comm\"));\n  NCCLCHECK(PtrCheck(rank, \"CommUserRank\", \"rank\"));\n\n  NCCLCHECK(ncclCommEnsureReady(comm));\n\n  *rank = comm->rank;\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclMemAlloc, void **ptr, size_t size);\nncclResult_t  ncclMemAlloc(void **ptr, size_t size) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n  ncclResult_t ret = ncclSuccess;\n\n#if CUDART_VERSION >= 12010\n  size_t memGran = 0;\n  size_t mcGran = 0;\n  CUdevice currentDev;\n  CUmemAllocationProp memprop = {};\n  CUmulticastObjectProp mcprop = {};\n  CUmemAccessDesc accessDesc = {};\n  CUmemGenericAllocationHandle handle;\n  int cudaDev;\n  int flag = 0;\n  int dcnt;\n  int mcSupport = 0;\n\n  if (ptr == NULL || size == 0) goto fallback;\n\n  if (ncclCudaLibraryInit() != ncclSuccess) goto fallback;\n\n  CUDACHECK(cudaGetDevice(&cudaDev));\n  CUCHECK(cuDeviceGet(&currentDev, cudaDev));\n  if (CUPFN(cuMulticastCreate) != NULL)\n    CUCHECK(cuDeviceGetAttribute(&mcSupport, CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED, currentDev));\n\n  if (mcSupport) {\n    memprop.type = CU_MEM_ALLOCATION_TYPE_PINNED;\n    memprop.location.type = CU_MEM_LOCATION_TYPE_DEVICE;\n    memprop.requestedHandleTypes = ncclCuMemHandleType;\n    memprop.location.id = currentDev;\n    // Query device to see if RDMA support is available\n    CUCHECK(cuDeviceGetAttribute(&flag, CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED, currentDev));\n    if (flag) memprop.allocFlags.gpuDirectRDMACapable = 1;\n    CUCHECK(cuMemGetAllocationGranularity(&memGran, &memprop, CU_MEM_ALLOC_GRANULARITY_RECOMMENDED));\n\n    /* mc property */\n    CUDACHECK(cudaGetDeviceCount(&dcnt));\n    mcprop.size = size;\n    /* device cnt is a dummy value right now, it might affect mc granularity in the future. */\n    mcprop.numDevices = dcnt;\n    mcprop.handleTypes = ncclCuMemHandleType;\n    mcprop.flags = 0;\n    CUCHECK(cuMulticastGetGranularity(&mcGran, &mcprop, CU_MULTICAST_GRANULARITY_RECOMMENDED));\n\n    /* only size needs to be aligned to mcGran */\n    ALIGN_SIZE(size, mcGran);\n    /* Allocate the physical memory on the device */\n    CUCHECK(cuMemCreate(&handle, size, &memprop, 0));\n    /* Reserve a virtual address range */\n    CUCHECK(cuMemAddressReserve((CUdeviceptr*)ptr, size, memGran, 0, 0));\n    /* Map the virtual address range to the physical allocation */\n    CUCHECK(cuMemMap((CUdeviceptr)*ptr, size, 0, handle, 0));\n    /* Now allow RW access to the newly mapped memory */\n    for (int i = 0; i < dcnt; ++i) {\n      int p2p = 0;\n      if (i == cudaDev || ((cudaDeviceCanAccessPeer(&p2p, cudaDev, i) == cudaSuccess) && p2p)) {\n        accessDesc.location.type = CU_MEM_LOCATION_TYPE_DEVICE;\n        accessDesc.location.id = i;\n        accessDesc.flags = CU_MEM_ACCESS_FLAGS_PROT_READWRITE;\n        CUCHECK(cuMemSetAccess((CUdeviceptr)*ptr, size, &accessDesc, 1));\n      }\n    }\n    goto exit;\n  }\n\nfallback:\n#endif\n  CUDACHECKGOTO(cudaMalloc(ptr, size), ret, fail);\n\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nNCCL_API(ncclResult_t, ncclMemFree, void *ptr);\nncclResult_t  ncclMemFree(void *ptr) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n  ncclResult_t ret = ncclSuccess;\n  int saveDevice;\n\n  CUDACHECK(cudaGetDevice(&saveDevice));\n#if CUDART_VERSION >= 12010\n  CUdevice ptrDev = 0;\n  int mcSupport = 0;\n\n  if (ptr == NULL) goto fallback;\n\n  if (ncclCudaLibraryInit() != ncclSuccess) goto fallback;\n\n  CUCHECKGOTO(cuPointerGetAttribute((void*)&ptrDev, CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL, (CUdeviceptr)ptr), ret, fail);\n  if (CUPFN(cuMulticastCreate) != NULL)\n    CUCHECKGOTO(cuDeviceGetAttribute(&mcSupport, CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED, ptrDev), ret, fail);\n\n  CUDACHECKGOTO(cudaSetDevice((int)ptrDev), ret, fail);\n  if (mcSupport) {\n    NCCLCHECKGOTO(ncclCuMemFree(ptr), ret, fail);\n    goto exit;\n  }\n\nfallback:\n#endif\n  CUDACHECKGOTO(cudaFree(ptr), ret, fail);\n\nexit:\n  cudaSetDevice(saveDevice);\n  return ret;\nfail:\n  goto exit;\n}\n","uri":"file:///root/code/nccl-trace/src/init.cc","version":1}}}

I[15:12:27.183] <-- textDocument/didOpen
V[15:12:27.184] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"/*************************************************************************\n * Copyright (c) 2016-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#ifndef NCCL_TOPO_H_\n#define NCCL_TOPO_H_\n\n#include \"graph.h\"\n#include \"core.h\"\n\n#define LOC_BW 5000.0\n#define SM60_NVLINK_BW 18.0\n#define SM70_NVLINK_BW 20.0\n#define SM80_NVLINK_BW 20.0\n#define SM90_NVLINK_BW 20.6\n#define SM86_NVLINK_BW 12.0\n#define PCI_BW 12.0           // PCI Gen3 x16\n#define QPI_BW 6.0\n#define AMD_BW 16.0\n#define SKL_QPI_BW 10.0\n#define ZPI_BW 6.0\n#define YONGFENG_ZPI_BW 9.0\n#define P9_BW 32.0\n#define ARM_BW 6.0\n#define NET_BW 12.0           // 100Gbit\n\n// Intel CPU convert GPU P2P traffic into 64B PCI TLPs, so GPU\n// to GPU traffic consumes more PCI bandwidth.\n#define INTEL_P2P_OVERHEAD(bw) (bw*6/5)\n\n#define NCCL_TOPO_NODE_TYPES 7\n#define GPU 0\n#define PCI 1\n#define NVS 2\n#define CPU 3 // Actually NUMA domains\n#define NIC 4\n#define NET 5\nextern const char* topoNodeTypeStr[];\n\n// We want link types and path types to match as much as possible\n#define LINK_LOC 0\n#define LINK_NVL 1\n// Skipping 2 for PATH_NVB\n#define LINK_PCI 3\n// Skipping 4 for PATH_PXB\n// Skipping 5 for PATH_PXN\n// Skipping 6 for PATH_PHB\n#define LINK_SYS 7\n#define LINK_NET 8\nextern const char* topoLinkTypeStr[];\n\n// Local (myself)\n#define PATH_LOC 0\n\n// Connection traversing NVLink\n#define PATH_NVL 1\n\n// Connection through NVLink using an intermediate GPU\n#define PATH_NVB 2\n\n// Connection traversing at most a single PCIe bridge\n#define PATH_PIX 3\n\n// Connection traversing multiple PCIe bridges (without traversing the PCIe Host Bridge)\n#define PATH_PXB 4\n\n// Connection between a GPU and a NIC using an intermediate GPU. Used to enable rail-local, aggregated network send/recv operations.\n#define PATH_PXN 5\n\n// Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)\n#define PATH_PHB 6\n\n// Connection traversing PCIe as well as the SMP interconnect between NUMA nodes (e.g., QPI/UPI)\n#define PATH_SYS 7\n\n// Connection through the network\n#define PATH_NET 8\n\n// Disconnected\n#define PATH_DIS 9\nextern const char* topoPathTypeStr[];\n\nstruct ncclTopoNode;\nstruct ncclTopoLink {\n  int type;\n  float bw;\n  struct ncclTopoNode* remNode;\n};\n#define NCCL_TOPO_MAX_LINKS 128\n#define NCCL_TOPO_MAX_HOPS (NCCL_TOPO_MAX_NODES*NCCL_TOPO_NODE_TYPES)\n\nstruct ncclTopoLinkList {\n  struct ncclTopoLink* list[NCCL_TOPO_MAX_HOPS];\n  int count;\n  float bw;\n  int type;\n};\n\n#define NCCL_TOPO_CPU_INTEL_BDW 1\n#define NCCL_TOPO_CPU_INTEL_SKL 2\n\n#define NCCL_TOPO_UNDEF (-1)\n\n#define NCCL_TOPO_ID_SYSTEM_ID(id) (id >> 56)\n#define NCCL_TOPO_ID_LOCAL_ID(id) (id & 0x00ffffffffffffff)\n#define NCCL_TOPO_ID(systemid, localid) (((int64_t)systemid << 56) + localid)\n\nstruct ncclTopoNode {\n  int type;\n  int64_t id;\n  // Type specific data\n  union {\n    struct {\n      int dev; // NVML dev number\n      int rank;\n      int cudaCompCap;\n      int gdrSupport;\n    }gpu;\n    struct {\n      int dev; // Plugin dev number\n      uint64_t asic;\n      int port;\n      float bw;\n      float latency;\n      int gdrSupport;\n      int collSupport;\n      int maxChannels;\n    }net;\n    struct {\n      int arch;\n      int vendor;\n      int model;\n      cpu_set_t affinity;\n    }cpu;\n    struct {\n      uint64_t device;\n    }pci;\n  };\n  int nlinks;\n  struct ncclTopoLink links[NCCL_TOPO_MAX_LINKS];\n  // Pre-computed paths to GPUs and NICs\n  struct ncclTopoLinkList* paths[NCCL_TOPO_NODE_TYPES];\n  // Used during search\n  uint64_t used;\n};\n\nstruct ncclTopoNodeSet {\n  int count;\n  struct ncclTopoNode nodes[NCCL_TOPO_MAX_NODES];\n};\n\nstruct ncclTopoSystem {\n  int systemId;\n  uint64_t hostHashes[NCCL_TOPO_MAX_NODES];\n  int nHosts;\n  struct ncclTopoNodeSet nodes[NCCL_TOPO_NODE_TYPES];\n  float maxBw;\n  float totalBw;\n};\n\nncclResult_t ncclTopoGetNode(struct ncclTopoSystem* system, struct ncclTopoNode** node, int type, uint64_t id);\nncclResult_t ncclTopoCreateNode(struct ncclTopoSystem* system, struct ncclTopoNode** node, int type, uint64_t id);\nncclResult_t ncclTopoRemoveNode(struct ncclTopoSystem* system, int type, int id);\nncclResult_t ncclTopoConnectNodes(struct ncclTopoNode* node, struct ncclTopoNode* remNode, int type, float bw);\nncclResult_t ncclTopoPrintPaths(struct ncclTopoSystem* system);\nncclResult_t ncclTopoLoadSystem(const char* xmlTopoFile, struct ncclTopoSystem* system);\nncclResult_t ncclTopoGetIntermediateRank(struct ncclTopoSystem* system, int rank, int64_t netId, int* intermediateRank);\n\n#define NCCL_TOPO_XML_MAX_NODES 256\n#define NCCL_GRAPH_XML_MAX_NODES 4096\nncclResult_t ncclTopoGetSystemFromXml(struct ncclXml* xml, struct ncclTopoSystem** topoSystem, uint64_t localHostHash);\nncclResult_t ncclTopoGetGraphFromXml(struct ncclXmlNode *xmlGraphs, struct ncclTopoSystem* system, struct ncclTopoGraph* graph, int* nChannels);\nncclResult_t ncclTopoGetXmlFromGraphs(int ngraphs, struct ncclTopoGraph** graphs, struct ncclTopoSystem* system, struct ncclXml *xml);\n\nncclResult_t ncclTopoGetCompCap(struct ncclTopoSystem* system, int* ccMin, int* ccMax);\n\nstatic ncclResult_t ncclTopoIdToIndex(struct ncclTopoSystem* system, int type, int64_t id, int* index) {\n  *index = -1;\n  for (int i=0; i<system->nodes[type].count; i++) {\n    if (system->nodes[type].nodes[i].id == id) {\n      *index = i;\n      return ncclSuccess;\n    }\n  }\n  return ncclInternalError;\n}\n\nstatic ncclResult_t ncclTopoRankToIndex(struct ncclTopoSystem* system, int rank, int* index) {\n  *index = -1;\n  for (int i=0; i<system->nodes[GPU].count; i++) {\n    if (system->nodes[GPU].nodes[i].gpu.rank == rank) {\n      *index = i;\n      return ncclSuccess;\n    }\n  }\n  return ncclInternalError;\n}\n\nstatic ncclResult_t ncclTopoDevToRank(struct ncclTopoSystem* system, int dev, int* rank) {\n  *rank = -1;\n  for (int i=0; i<system->nodes[GPU].count; i++) {\n    if (NCCL_TOPO_ID_SYSTEM_ID(system->nodes[GPU].nodes[i].id) != system->systemId) continue; // Only consider GPUs on our node\n    if (system->nodes[GPU].nodes[i].gpu.dev == dev) {\n      *rank = system->nodes[GPU].nodes[i].gpu.rank;\n      return ncclSuccess;\n    }\n  }\n  return ncclInternalError;\n}\n\nstatic ncclResult_t ncclTopoIdToNetDev(struct ncclTopoSystem* system, int64_t id, int* netDev) {\n  *netDev = -1;\n  for (int i=0; i<system->nodes[NET].count; i++) {\n    if (system->nodes[NET].nodes[i].id == id) {\n      *netDev = system->nodes[NET].nodes[i].net.dev;\n      return ncclSuccess;\n    }\n  }\n  WARN(\"Could not find NET with id %lx\\n\", id);\n  return ncclInternalError;\n}\n\n// Returns NVLink bw in GB/s\nstatic float ncclTopoNVLinkBw(int cudaCompCap) {\n  return\n    cudaCompCap >= 90 ? SM90_NVLINK_BW :\n    cudaCompCap == 86 ? SM86_NVLINK_BW :\n    cudaCompCap >= 80 ? SM80_NVLINK_BW :\n    cudaCompCap >= 70 ? SM70_NVLINK_BW :\n    cudaCompCap >= 60 ? SM60_NVLINK_BW :\n    SM80_NVLINK_BW;\n}\n\n// Mirror bits\nstatic bool isPow2(int val) {\n  return (val & (val-1)) == 0;\n}\nstatic int mirrorBits(int val, int pow2) {\n  int mirror = 0;\n  for (int b=1, mb=(pow2>>1); b<pow2; b<<=1, mb>>=1) if (val & b) mirror |= mb;\n  return mirror;\n}\n#endif\n","uri":"file:///root/code/nccl-trace/src/graph/topo.h","version":1}}}

I[15:12:27.184] <-- textDocument/didOpen
V[15:12:27.184] config note at /root/code/nccl-trace/.clangd:1:0: Parsing config fragment
V[15:12:27.184] config note at /root/code/nccl-trace/.clangd:1:0: Parsed 1 fragments from file
V[15:12:27.184] Config fragment: compiling /root/code/nccl-trace/.clangd:1 -> 0x00007FB004002010 (trusted=false)
V[15:12:27.184] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"#undef TRACEPOINT_PROVIDER\n#define TRACEPOINT_PROVIDER nccl\n\n#undef TRACEPOINT_INCLUDE\n#define TRACEPOINT_INCLUDE \"/root/code/nccl-trace/src/include/nccl_tp.h\"\n\n#if !defined(_NCCL_TP_H) || defined(TRACEPOINT_HEADER_MULTI_READ)\n#define _NCCL_TP_H\n\n#include \"lttng/tracepoint.h\"\n\n\nTRACEPOINT_EVENT(nccl, startTrace, TP_ARGS(const char*, hostname, int64_t, cpuFreq, int64_t, startTsc, int64_t, startTimeNs),\n                 TP_FIELDS(ctf_string(hostname, hostname)\n                            ctf_integer(int64_t, cpuFreq, cpuFreq)\n                            ctf_integer(int64_t, startTsc, startTsc)\n                            ctf_integer(int64_t, startTimeNs, startTimeNs)))\n\nTRACEPOINT_EVENT(nccl, devFunc, TP_ARGS(int, funcIndex, const char*, funcName),\n                 TP_FIELDS(ctf_integer(int, funcIndex, funcIndex)\n                            ctf_string(funcName, funcName)))\n\nTRACEPOINT_EVENT(nccl, enterFunc, TP_ARGS(int64_t, groupDepth, const char*, funcName),\n                 TP_FIELDS(ctf_integer(int64_t, groupDepth, groupDepth)\n                            ctf_string(funcName, funcName)))\n\nTRACEPOINT_EVENT(nccl, exitFunc, TP_ARGS(int64_t, groupDepth, const char*, funcName),\n                 TP_FIELDS(ctf_integer(int64_t, groupDepth, groupDepth)\n                            ctf_string(funcName, funcName)))\n\nTRACEPOINT_EVENT(nccl, commInit, TP_ARGS(uint64_t, commHash, int, localRanks, int, rankCount, int, channelCount, int, p2pChannelCount, int, p2pChannelCountPerPeer),\n                 TP_FIELDS(ctf_integer(uint64_t, commHash, commHash)\n                            ctf_integer(int, localRanks, localRanks)\n                            ctf_integer(int, rankCount, rankCount)\n                            ctf_integer(int, channelCount, channelCount)\n                            ctf_integer(int, p2pChannelCount, p2pChannelCount)\n                            ctf_integer(int, p2pChannelCountPerPeer, p2pChannelCountPerPeer)))\n\nTRACEPOINT_EVENT(nccl, commChannel, TP_ARGS(uint64_t, commHash, int, rank, int, channelCount, const int*, ringChannels, const int*, treeChannels),\n                 TP_FIELDS(ctf_integer(uint64_t, commHash, commHash)\n                            ctf_integer(int, rank, rank)\n                            ctf_sequence(int, ringChannels, ringChannels, unsigned int, channelCount)\n                            ctf_sequence(int, treeChannels, treeChannels, unsigned int, channelCount*4/*up+down[3]*/)))\n\nTRACEPOINT_EVENT(nccl, allocKr, TP_ARGS(int64_t, kernelId, uint64_t, commHash, uint64_t, launchOrder, int, rank, int, funcIndex, int, channelCount, int, channelUbound, uint64_t, channelMask),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                            ctf_integer(uint64_t, commHash, commHash)\n                            ctf_integer(uint64_t, launchOrder, launchOrder)\n                            ctf_integer(int, rank, rank)\n                            ctf_integer(int, funcIndex, funcIndex)\n                            ctf_integer(int, channelCount, channelCount)\n                            ctf_integer(int, channelUbound, channelUbound)\n                            ctf_integer(uint64_t, channelMask, channelMask)))\n\nTRACEPOINT_EVENT(nccl, scanKr, TP_ARGS(int64_t, kernelId, int, startedChannels, int, endedChannels),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                            ctf_integer(int, startedChannels, startedChannels)\n                            ctf_integer(int, endedChannels, endedChannels)))\n\nTRACEPOINT_EVENT(nccl, warnKrRing, TP_ARGS(int64_t, kernelId, const int*, prevPeers, const int*, nextPeers, const int*, receivedSlices, const int*, sentSlices, const int*, cpuReceivedSlices, const int*, cpuSentSlices, int, channelCount),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                            ctf_sequence(int, prevPeers, prevPeers, unsigned int, channelCount)\n                            ctf_sequence(int, nextPeers, nextPeers, unsigned int, channelCount)\n                            ctf_sequence(int, receivedSlices, receivedSlices, unsigned int, channelCount)\n                            ctf_sequence(int, sentSlices, sentSlices, unsigned int, channelCount)\n                            ctf_sequence(int, cpuReceivedSlices, cpuReceivedSlices, unsigned int, channelCount)\n                            ctf_sequence(int, cpuSentSlices, cpuSentSlices, unsigned int, channelCount)))\n\nTRACEPOINT_EVENT(nccl, warnKrP2p, TP_ARGS(int64_t, kernelId, const int*, receivePeers, const int*, sendPeers, const int*, receivedSlices, const int*, sentSlices, int, channelCount),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                            ctf_sequence(int, receivePeers, receivePeers, unsigned int, channelCount*8)\n                            ctf_sequence(int, sendPeers, sendPeers, unsigned int, channelCount*8)\n                            ctf_sequence(int, receivedSlices, receivedSlices, unsigned int, channelCount*8)\n                            ctf_sequence(int, sentSlices, sentSlices, unsigned int, channelCount*8)))\n\nTRACEPOINT_EVENT(nccl, moveKr, TP_ARGS(int64_t, startKernelId),\n                 TP_FIELDS(ctf_integer(int64_t, startKernelId, startKernelId)))\n\nTRACEPOINT_EVENT(nccl, startChannel, TP_ARGS(int64_t, kernelId, int, channelId, int64_t, startGpuCycles, int64_t, collBytes),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                            ctf_integer(int, channelId, channelId)\n                            ctf_integer(int64_t, startGpuCycles, startGpuCycles)\n                            ctf_integer(int64_t, collBytes, collBytes)))\n\nTRACEPOINT_EVENT(nccl, endChannel, TP_ARGS(int64_t, kernelId, int, channelId, int64_t, elapsedGpuCycles),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                            ctf_integer(int, channelId, channelId)\n                            ctf_integer(int64_t, elapsedGpuCycles, elapsedGpuCycles)))\n\n#ifdef ENABLE_SLOW\nTRACEPOINT_EVENT(nccl, reduceCopy, TP_ARGS(int64_t, kernelId, const int64_t*, costGpuCycles, int, channelCount),\n                 TP_FIELDS(ctf_integer(int64_t, kernelId, kernelId)\n                           ctf_sequence(int64_t, costGpuCycles, costGpuCycles, unsigned int, channelCount)))\n\nTRACEPOINT_EVENT(nccl, netSendCost, TP_ARGS(int, rank, uint64_t, kernelId, int, realPeer, int, ncclPattern, unsigned int, sliceCount, int, channelId, const uint64_t*, beginCycles, const uint64_t*, endCycles),\n                 TP_FIELDS(ctf_integer(int, rank, rank)\n                            ctf_integer(uint64_t, kernelId, kernelId)\n                            ctf_integer(int, realPeer, realPeer)\n                            ctf_integer(int, ncclPattern, ncclPattern)\n                            ctf_integer(int, channelId, channelId)\n                            ctf_sequence(uint64_t, beginCycles, beginCycles, unsigned int, sliceCount)\n                            ctf_sequence(uint64_t, endCycles, endCycles, unsigned int, sliceCount)))\n\nTRACEPOINT_EVENT(nccl, shmSendCost, TP_ARGS(int, rank, uint64_t, kernelId, int, realPeer, int, ncclPattern, unsigned int, sliceCount, int, channelId, const uint64_t*, beginCycles, const uint64_t*, endCycles),\n                 TP_FIELDS(ctf_integer(int, rank, rank)\n                            ctf_integer(uint64_t, kernelId, kernelId)\n                            ctf_integer(int, realPeer, realPeer)\n                            ctf_integer(int, ncclPattern, ncclPattern)\n                            ctf_integer(int, channelId, channelId)\n                            ctf_sequence(uint64_t, beginCycles, beginCycles, unsigned int, sliceCount)\n                            ctf_sequence(uint64_t, endCycles, endCycles, unsigned int, sliceCount)))\n\nTRACEPOINT_EVENT(nccl, shmRecvCost, TP_ARGS(int, rank, uint64_t, kernelId, int, realPeer, int, ncclPattern, unsigned int, sliceCount, int, channelId, const uint64_t*, beginCycles, const uint64_t*, endCycles),\n                 TP_FIELDS(ctf_integer(int, rank, rank)\n                            ctf_integer(uint64_t, kernelId, kernelId)\n                            ctf_integer(int, realPeer, realPeer)\n                            ctf_integer(int, ncclPattern, ncclPattern)\n                            ctf_integer(int, channelId, channelId)\n                            ctf_sequence(uint64_t, beginCycles, beginCycles, unsigned int, sliceCount)\n                            ctf_sequence(uint64_t, endCycles, endCycles, unsigned int, sliceCount)))\n\nTRACEPOINT_EVENT(nccl, p2pSendCost, TP_ARGS(int, rank, uint64_t, kernelId, int, realPeer, int, ncclPattern, unsigned int, sliceCount, int, channelId, const uint64_t*, beginCycles, const uint64_t*, endCycles),\n                 TP_FIELDS(ctf_integer(int, rank, rank)\n                            ctf_integer(uint64_t, kernelId, kernelId)\n                            ctf_integer(int, realPeer, realPeer)\n                            ctf_integer(int, ncclPattern, ncclPattern)\n                            ctf_integer(int, channelId, channelId)\n                            ctf_sequence(uint64_t, beginCycles, beginCycles, unsigned int, sliceCount)\n                            ctf_sequence(uint64_t, endCycles, endCycles, unsigned int, sliceCount)))\n\n#endif /* ENABLE_SLOW */\n\n#endif /* _NCCL_TP_H */\n\n#include \"lttng/tracepoint-event.h\"\n\n\n","uri":"file:///root/code/nccl-trace/src/include/nccl_tp.h","version":1}}}

I[15:12:27.184] <-- textDocument/didOpen
V[15:12:27.185] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"#include <lttng/tracelog.h>\n#include <sys/time.h>\n#include <x86intrin.h>\n\n#include \"nccl.h\"\n#include \"alloc.h\"\n#include \"checks.h\"\n#include \"nccl_tp.h\"\n\nextern const char* ncclDevFuncTableStr[];\nextern size_t ncclDevFuncTableStrCount;\nstatic __thread int64_t ncclGroupDepthTrace = 0; // depth of ncclGroupStart nesting for trace\n\nvoid getAllDevFuncStr() {\n  int i;\n  for(i=0; i<ncclDevFuncTableStrCount; i++) {\n    if (ncclDevFuncTableStr[i]) {\n      tracepoint(nccl, devFunc, i, ncclDevFuncTableStr[i]);\n    }\n  }\n}\n\nstatic ncclKrRing_t* ncclKrRing = NULL;\nstatic pthread_t ncclScanKernelThread;\nstatic void* scanKrRing(void* args);\nvoid getAllDevFuncStr();\n\nstatic pthread_mutex_t initLock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool initialized = false;\n\nstatic int64_t cpuFreq = -1;\nstatic int64_t startTsc = -1;\nstatic int64_t statTimeNs = -1;\nstatic void calibrateCpuTsc() {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    uint64_t tsc = __rdtsc();\n    double time = - tv.tv_sec*1E6 - tv.tv_usec;\n    uint64_t total = 0ULL;\n    for (int i=0; i<10000; i++) total += __rdtsc();\n    gettimeofday(&tv, NULL);\n    tsc = __rdtsc() - tsc;\n    time += tv.tv_sec*1E6 + tv.tv_usec;\n    cpuFreq = int64_t(tsc*1E6/time);\n    gettimeofday(&tv, NULL);\n    startTsc = __rdtsc();\n    statTimeNs = (tv.tv_sec*1E6 + tv.tv_usec)*1000;\n}\n\nstatic void initKernelRecord() {\n  char hostname[1024];\n  if (gethostname(hostname, sizeof(hostname)) != 0) {\n    strncpy(hostname, \"unknown\", sizeof(hostname));\n  }\n  int cudaDev = -1;\n  cudaGetDevice(&cudaDev);\n  tracepoint(nccl, startTrace, hostname, cpuFreq, startTsc, statTimeNs);\n\n  getAllDevFuncStr();\n  ncclResult_t res = ncclCudaHostCalloc(&ncclKrRing, 1);\n  assert(res==ncclSuccess);\n  int rc = pthread_mutex_init(&ncclKrRing->mutex, nullptr);\n  assert(rc==0);\n  pthread_create(&ncclScanKernelThread, NULL, scanKrRing, NULL);\n}\n\nstatic void initKr(ncclKernelRecord_t *slot) {\n  memset(slot, 0, sizeof(ncclKernelRecord_t));\n  slot->lastDumpCycles = __rdtsc();\n  for (int i=0; i<TRACE_MAXCHANNELS; i++) {\n    slot->channels[i].ring.prevPeer = -1;\n    slot->channels[i].ring.nextPeer = -1;\n    for (int j=0; j<8; j++) {\n      slot->channels[i].p2p.receivePeers[j] = -1;\n      slot->channels[i].p2p.sendPeers[j] = -1;\n    }\n  }\n}\n\nncclKernelRecord_t * allocKrRingSlot(uint64_t commHash, uint64_t launchedKernels, int rank, int funcIndex, int channelCount, int channelUbound, uint64_t channelMask) {\n  long long start;\n  long long end;\n  pthread_mutex_lock(&ncclKrRing->mutex);\n  start = ncclKrRing->start;\n  end = ncclKrRing->end;\n  if (end - start == ncclKrRingSize) {\n    pthread_mutex_unlock(&ncclKrRing->mutex);\n    lttng_ust_tracelog(LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO, \\\n      \"KernelRecord Alloc Failed: No slot to alloc for funcIndex=%d, channelCount=%d, start=%lld, end=%lld\", funcIndex, channelCount, start, end);\n    return NULL;\n  }\n  pthread_mutex_unlock(&ncclKrRing->mutex);\n\n  ncclKernelRecord_t *slot = &ncclKrRing->records[end%ncclKrRingSize];\n  initKr(slot);\n  slot->rank = rank;\n  slot->funcIndex = funcIndex;\n  slot->channelCount = channelCount;\n  slot->channelUbound = channelUbound;\n  slot->channelMask = channelMask;\n  slot->kernelId = end;\n  tracepoint(nccl, allocKr, slot->kernelId, commHash, launchedKernels, rank, funcIndex, channelCount, channelUbound, channelMask);\n\n  pthread_mutex_lock(&ncclKrRing->mutex);\n  ncclKrRing->end++;\n  pthread_mutex_unlock(&ncclKrRing->mutex);\n  return slot;\n}\n\nstatic void* scanKrRing(void* args) {\n  while(true) {\n    long long start;\n    long long end;\n    long long ix;\n    long long doneIx;\n    pthread_mutex_lock(&ncclKrRing->mutex);\n    start = ncclKrRing->start;\n    end = ncclKrRing->end;\n    pthread_mutex_unlock(&ncclKrRing->mutex);\n    doneIx=start-1;\n    for(ix=start; ix<end; ix++) {\n      ncclKernelRecord_t *slot = &ncclKrRing->records[ix%ncclKrRingSize];\n      int startedChannels=0;\n      int endedChannels=0;\n      int c=0;\n      for(c=0; c<slot->channelUbound; c++) {\n        if(!(slot->channelMask & (1ull<<c))) {\n          continue;\n        }\n        if(slot->channels[c].startGpuCycles!=0) {\n          startedChannels++;\n        }\n        if(slot->channels[c].endGpuCycles!=0) {\n          endedChannels++;\n        }\n        if(slot->channels[c].startGpuCycles>0) {\n          tracepoint(nccl, startChannel, slot->kernelId, c, slot->channels[c].startGpuCycles, slot->channels[c].collBytes);\n          slot->channels[c].startGpuCycles = 0-slot->channels[c].startGpuCycles; // Avoid duplicate output.\n        }\n        if(slot->channels[c].endGpuCycles>0) {\n          tracepoint(nccl, endChannel, slot->kernelId, c, slot->channels[c].endGpuCycles-(0-slot->channels[c].startGpuCycles));\n          slot->channels[c].endGpuCycles = 0-slot->channels[c].endGpuCycles; // Avoid duplicate output.\n        }\n      }\n\n      int64_t tsc = __rdtsc();\n      if (tsc - slot->lastDumpCycles > TRACE_WARN_HANG_INTERVAL_IN_CYCLES) {\n        // Maybe hang, report its state.\n        if (slot->channelType == ringChannelType) {\n          int prevPeers[TRACE_MAXCHANNELS];\n          int nextPeers[TRACE_MAXCHANNELS];\n          int sentSlices[TRACE_MAXCHANNELS];\n          int receivedSlices[TRACE_MAXCHANNELS];\n          int cpuSentSlices[TRACE_MAXCHANNELS];\n          int cpuReceivedSlices[TRACE_MAXCHANNELS];\n          for(c=0; c<slot->channelUbound; c++) {\n            if(!(slot->channelMask & (1ull<<c))) {\n              continue;\n            }\n            prevPeers[c] = slot->channels[c].ring.prevPeer;\n            nextPeers[c] = slot->channels[c].ring.nextPeer;\n            receivedSlices[c] = slot->channels[c].ring.receivedSlices;\n            sentSlices[c] = slot->channels[c].ring.sentSlices;\n            if (slot->hasRecvProxyMask & (1ull<<c)) {\n              cpuReceivedSlices[c] = slot->channels[c].ring.cpuReceivedSlices;\n            }\n            if (slot->hasSendProxyMask & (1ull<<c)) {\n              cpuSentSlices[c] = slot->channels[c].ring.cpuSentSlices;\n            }\n          }\n          tracepoint(nccl, warnKrRing, slot->kernelId, prevPeers, nextPeers, receivedSlices, sentSlices, cpuReceivedSlices, cpuSentSlices, slot->channelUbound);\n        } else if (slot->channelType == p2pChannelType) {\n          int receivePeers[TRACE_MAXCHANNELS*8];\n          int sendPeers[TRACE_MAXCHANNELS*8];\n          int sentSlices[TRACE_MAXCHANNELS*8];\n          int receivedSlices[TRACE_MAXCHANNELS*8];\n          for(c=0; c<slot->channelUbound; c++) {\n            if(!(slot->channelMask & (1ull<<c))) {\n              continue;\n            }\n            memcpy(receivePeers+c*8, slot->channels[c].p2p.receivePeers, sizeof(int)*8);\n            memcpy(sendPeers+c*8, slot->channels[c].p2p.sendPeers, sizeof(int)*8);\n            memcpy(receivedSlices+c*8, slot->channels[c].p2p.receivedSlices, sizeof(int)*8);\n            memcpy(sentSlices+c*8, slot->channels[c].p2p.sentSlices, sizeof(int)*8);\n          }\n          tracepoint(nccl, warnKrP2p, slot->kernelId, receivePeers, sendPeers, receivedSlices, sentSlices, slot->channelUbound);\n        } else if (slot->channelType == treeChannelType) {\n          // Not implemented.\n        }\n\n        slot->lastDumpCycles = tsc;\n      }\n\n      if (slot->startedChannels != startedChannels || slot->endedChannels != endedChannels) {\n        tracepoint(nccl, scanKr, slot->kernelId, startedChannels, endedChannels);\n        slot->startedChannels = startedChannels;\n        slot->endedChannels = endedChannels;\n      }\n      \n      if(doneIx==ix-1 && endedChannels==slot->channelCount) {\n#ifdef ENABLE_SLOW\n        tracepoint(nccl, reduceCopy, slot->kernelId, slot->rsRecord.redcopyCost, slot->channelUbound);\n#endif\n        doneIx = ix;\n        initKr(slot);\n      }\n    }\n\n    if(doneIx!=start-1) {\n      pthread_mutex_lock(&ncclKrRing->mutex);\n      ncclKrRing->start = doneIx+1;\n      pthread_mutex_unlock(&ncclKrRing->mutex);\n      tracepoint(nccl, moveKr, doneIx+1);\n    }\n\n    usleep(10*1000);\n  }\n  return nullptr;\n}\n\nvoid initProfileOnce() {\n  if (__atomic_load_n(&initialized, __ATOMIC_ACQUIRE)) return;\n  pthread_mutex_lock(&initLock);\n  if (!initialized) {\n    calibrateCpuTsc();\n    initKernelRecord();\n    __atomic_store_n(&initialized, true, __ATOMIC_RELEASE);\n  }\n  pthread_mutex_unlock(&initLock);\n}\n\n#define KWAI_NCCL_API(ret, func, args...) \\\n    __attribute__ ((visibility(\"default\"))) \\\n    ret func (args); \\\n    __attribute__ ((visibility(\"default\"))) \\\n    ret func (args) {  \\\n            initProfileOnce(); \\\n            tracepoint(nccl, enterFunc, ncclGroupDepthTrace, #func); \\\n            ret res = p##func(\n\n#define KWAI_NCCL_API2(func, args...) \\\n            args); \\\n            tracepoint(nccl, exitFunc, ncclGroupDepthTrace, #func); \\\n            return res; \\\n    }\n\n#define KWAI_NCCL_API_GROUP_START(ret, func, args...) \\\n    __attribute__ ((visibility(\"default\"))) \\\n    ret func (args); \\\n    __attribute__ ((visibility(\"default\"))) \\\n    ret func (args) {  \\\n            initProfileOnce(); \\\n            tracepoint(nccl, enterFunc, ncclGroupDepthTrace, #func); \\\n            ret res = p##func(\n\n#define KWAI_NCCL_API_GROUP_START2(func, args...) \\\n            args); \\\n            tracepoint(nccl, exitFunc, ncclGroupDepthTrace, #func); \\\n            ncclGroupDepthTrace += 1; \\\n            return res; \\\n    }\n\n#define KWAI_NCCL_API_GROUP_END(ret, func, args...) \\\n    __attribute__ ((visibility(\"default\"))) \\\n    ret func (args); \\\n    __attribute__ ((visibility(\"default\"))) \\\n    ret func (args) {  \\\n            initProfileOnce(); \\\n            ncclGroupDepthTrace -= 1; \\\n            tracepoint(nccl, enterFunc, ncclGroupDepthTrace, #func); \\\n            ret res = p##func(\n\n#define KWAI_NCCL_API_GROUP_END2(func, args...) \\\n            args); \\\n            tracepoint(nccl, exitFunc, ncclGroupDepthTrace, #func); \\\n            return res; \\\n    }\n\n\nextern \"C\" {\n\n/*\nKWAI_NCCL_API(ncclResult_t, ncclRedOpCreatePreMulSum, ncclRedOp_t *op, void *scalar, ncclDataType_t datatype, ncclScalarResidence_t residence, ncclComm_t comm)\nKWAI_NCCL_API2(op, scalar, datatype, residence, comm);\n\nKWAI_NCCL_API(ncclResult_t, ncclRedOpDestroy, ncclRedOp_t op, ncclComm_t comm)\nKWAI_NCCL_API2(op, comm);\n*/\n\nKWAI_NCCL_API(ncclResult_t, ncclReduce, const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype,\n    ncclRedOp_t op, int root, ncclComm_t comm, cudaStream_t stream)\nKWAI_NCCL_API2(ncclReduce, sendbuff, recvbuff, count, datatype, op, root, comm, stream);\n\n\nKWAI_NCCL_API(ncclResult_t, ncclBroadcast, const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype, int root,\n    ncclComm_t comm, cudaStream_t stream)\nKWAI_NCCL_API2(ncclBroadcast, sendbuff, recvbuff, count, datatype, root, comm, stream);\n\nKWAI_NCCL_API(ncclResult_t, ncclAllReduce, const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype, ncclRedOp_t op, ncclComm* comm, cudaStream_t stream)\nKWAI_NCCL_API2(ncclAllReduce, sendbuff,  recvbuff,  count,  datatype,  op,  comm,  stream);\n\nKWAI_NCCL_API(ncclResult_t, ncclReduceScatter, const void* sendbuff, void* recvbuff, size_t recvcount, ncclDataType_t datatype, ncclRedOp_t op, ncclComm_t comm, cudaStream_t stream)\nKWAI_NCCL_API2(ncclReduceScatter, sendbuff, recvbuff, recvcount, datatype, op, comm, stream);\n\nKWAI_NCCL_API(ncclResult_t, ncclAllGather, const void* sendbuff, void* recvbuff, size_t sendcount,\n    ncclDataType_t datatype, ncclComm_t comm, cudaStream_t stream)\nKWAI_NCCL_API2(ncclAllGather, sendbuff, recvbuff, sendcount, datatype, comm, stream);\n\n/*\nKWAI_NCCL_API(ncclResult_t, ncclSend, const void* sendbuff, size_t count, ncclDataType_t datatype, int peer,\n    ncclComm_t comm, cudaStream_t stream)\nKWAI_NCCL_API2(sendbuff, count, datatype, peer, comm, stream);\n\nKWAI_NCCL_API(ncclResult_t, ncclRecv, void* recvbuff, size_t count, ncclDataType_t datatype, int peer,\n    ncclComm_t comm, cudaStream_t stream)\nKWAI_NCCL_API2(recvbuff, count, datatype, peer, comm, stream);\n*/\n\n\nKWAI_NCCL_API_GROUP_START(ncclResult_t, ncclGroupStart)\nKWAI_NCCL_API_GROUP_START2(ncclGroupStart);\n\nKWAI_NCCL_API_GROUP_END(ncclResult_t, ncclGroupEnd)\nKWAI_NCCL_API_GROUP_END2(ncclGroupEnd);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommRegister, const ncclComm_t comm, void* buff, size_t size, void** handle)\nKWAI_NCCL_API2(ncclCommRegister, comm, buff, size, handle);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommDeregister, const ncclComm_t comm, void* handle)\nKWAI_NCCL_API2(ncclCommDeregister, comm, handle);\n\nKWAI_NCCL_API(ncclResult_t, ncclGetVersion, int* version)\nKWAI_NCCL_API2(ncclGetVersion, version);\n\nKWAI_NCCL_API(ncclResult_t, ncclGetUniqueId, ncclUniqueId* out)\nKWAI_NCCL_API2(ncclGetUniqueId, out);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommInitRank, ncclComm_t* newcomm, int nranks, ncclUniqueId commId, int myrank)\nKWAI_NCCL_API2(ncclCommInitRank, newcomm,  nranks,  commId,  myrank);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommInitAll, ncclComm_t* comms, int ndev, const int* devlist)\nKWAI_NCCL_API2(ncclCommInitAll, comms,  ndev,  devlist);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommInitRankConfig, ncclComm_t* comm, int nranks, ncclUniqueId commId, int myrank, ncclConfig_t *config)\nKWAI_NCCL_API2(ncclCommInitRankConfig, comm, nranks,  commId,  myrank,  config);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommFinalize, ncclComm_t comm)\nKWAI_NCCL_API2(ncclCommFinalize, comm);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommDestroy, ncclComm_t comm)\nKWAI_NCCL_API2(ncclCommDestroy, comm);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommAbort, ncclComm_t comm)\nKWAI_NCCL_API2(ncclCommAbort, comm);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommSplit, ncclComm_t comm, int color, int key, ncclComm_t *newcomm, ncclConfig_t *config)\nKWAI_NCCL_API2(ncclCommSplit, comm,  color,  key, newcomm, config);\n\nKWAI_NCCL_API(const char*, ncclGetErrorString, ncclResult_t code)\nKWAI_NCCL_API2(ncclGetErrorString, code);\n\nKWAI_NCCL_API(const char*, ncclGetLastError, const ncclComm_t comm)\nKWAI_NCCL_API2(ncclGetLastError, comm);\n\n//KWAI_NCCL_API(ncclResult_t, ncclCommGetAsyncError, ncclComm_t comm, ncclResult_t *asyncError)\n//KWAI_NCCL_API2( comm, asyncError);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommCount, const ncclComm_t comm, int* count)\nKWAI_NCCL_API2(ncclCommCount, comm,  count);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommCuDevice, const ncclComm_t comm, int* devid)\nKWAI_NCCL_API2(ncclCommCuDevice, comm,  devid);\n\nKWAI_NCCL_API(ncclResult_t, ncclCommUserRank, const ncclComm_t comm, int* rank)\nKWAI_NCCL_API2(ncclCommUserRank, comm,  rank);\n\n}\n","uri":"file:///root/code/nccl-trace/src/profile.cc","version":1}}}

I[15:12:27.185] <-- textDocument/didOpen
V[15:12:27.186] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"/*************************************************************************\n * Copyright (c) 2017-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#include \"enqueue.h\"\n#include \"argcheck.h\"\n#include \"coll_net.h\"\n#include \"gdrwrap.h\"\n#include \"bootstrap.h\"\n#include \"channel.h\"\n#include \"cudawrap.h\"\n#include \"transport.h\"\n#include <cassert>\n#include <cstring> // std::memcpy\n#include <cinttypes> // PRIx64\n#include <lttng/tracelog.h>\n\nNCCL_PARAM(L1SharedMemoryCarveout, \"L1_SHARED_MEMORY_CARVEOUT\", 0);\n\nstatic ncclResult_t initCollWorkElem(struct ncclInfo* collInfo, struct ncclWorkElem* work);\nstatic ncclResult_t setCollWorkElem(uint64_t workCount, uint64_t workOffset, size_t lastChunkCount, struct ncclWorkElem* work);\nstatic ncclResult_t initCollWorkElemReg(struct ncclComm* comm, struct ncclWorkElem* work, struct ncclChannel* channel, ncclRegBufferType regBufType, void* regBufSend[], void* regBufRecv[], struct ncclWorkElemReg* workElemReg);\nstatic ncclResult_t computeCollChunkInfo(struct ncclInfo* collInfo, size_t nBytes, int nChannels);\nstatic ncclResult_t initCollProxyOp(struct ncclInfo* collInfo, int channelId, uint64_t opCount, uint32_t nsteps, struct ncclProxyOp* proxyOp);\nstatic ncclResult_t getTunerInfo(struct ncclInfo* collInfo, int collNetSupport, int nvlsSupport, int numPipeOps);\nstatic ncclResult_t topoGetAlgoInfo(struct ncclInfo* collInfo, int collNetSupport, int nvlsSupport, int numPipeOps);\nstatic ncclResult_t getChannnelThreadInfo(struct ncclInfo* collInfo);\nstatic ncclResult_t computeCollWorkFunc(struct ncclInfo* collInfo);\nstatic ncclResult_t getPatternInfo(struct ncclInfo* collInfo);\nstatic ncclResult_t getLoopInfo(struct ncclInfo* collInfo);\nstatic ncclResult_t getCollNetSupport(struct ncclInfo* info, int* collNetSupport);\n\n// Returns maximum kernel stack size of all CUDA kernels\nncclResult_t ncclInitKernelsForDevice(int cudaArch, size_t* maxStackSize) {\n  ncclResult_t result = ncclSuccess;\n\n  if (maxStackSize) *maxStackSize = 0;\n  int carveout = ncclParamL1SharedMemoryCarveout();\n\n  for (int k=0; k < ncclDevKernelCount; k++) {\n    void* fn = ncclDevKernelList[k];\n    if (fn == nullptr) continue;\n\n    if (maxStackSize) {\n      cudaFuncAttributes attr = {0};\n      CUDACHECKGOTO(cudaFuncGetAttributes(&attr, fn), result, ignore0);\n      if (attr.localSizeBytes > *maxStackSize) *maxStackSize = attr.localSizeBytes;\n    ignore0:;\n    }\n    if (carveout) {\n      CUDACHECKGOTO(cudaFuncSetAttribute(fn,\n        cudaFuncAttributePreferredSharedMemoryCarveout, carveout),\n        result, ignore1);\n    ignore1:;\n    }\n    if (ncclShmemDynamicSize(cudaArch) != 0) {\n      CUDACHECKGOTO(cudaFuncSetAttribute(fn,\n        cudaFuncAttributeMaxDynamicSharedMemorySize, ncclShmemDynamicSize(cudaArch)),\n        result, next_kernel);\n    }\n  next_kernel:;\n  }\n  return result;\n}\n\n/*****************************************************************************/\n/*       Launch system : synchronization and CUDA kernel launch              */\n/*****************************************************************************/\n\nstatic void appendWorkElemColl(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int channelId,\n    int funcIndex, struct ncclWorkElem const *elem) {\n  struct ncclKernelPlan::Channel* chan = &plan->channels[channelId];\n  struct ncclWorkList* q = ncclIntruQueueTail(&chan->workQueue);\n  if (q && funcIndex == q->work.header.funcIndex\n        && elem->nWarps == q->work.elems[0].nWarps\n        && chan->nWorkElem < NCCL_MAX_WORK_ELEMENTS\n        && ncclWorkTypeColl == q->work.header.type) {\n    int e = chan->nWorkElem++;\n    q->work.elems[e] = *elem; // C++ struct assignment\n    return;\n  }\n  q = ncclMemoryStackAlloc<struct ncclWorkList>(&comm->memScoped);\n  q->work.header.type = ncclWorkTypeColl;\n  q->work.header.funcIndex = funcIndex;\n  q->work.elems[0] = *elem; // C++ struct assignment\n  chan->nWorkElem = 1;\n  chan->nWork += 1;\n  ncclIntruQueueEnqueue(&chan->workQueue, q);\n}\n\nstatic void appendWorkElemColl(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int channelId,\n    int funcIndex, struct ncclWorkElemReg const *elem) {\n  struct ncclKernelPlan::Channel* chan = &plan->channels[channelId];\n  struct ncclWorkList* q = ncclIntruQueueTail(&chan->workQueue);\n  if (q && funcIndex == q->work.header.funcIndex\n        && elem->elem.nWarps == q->work.regElems[0].elem.nWarps\n        && chan->nWorkElem < NCCL_MAX_WORK_ELEMENTS_REG\n        && ncclWorkTypeRegColl == q->work.header.type) {\n    int e = chan->nWorkElem++;\n    q->work.regElems[e] = *elem; // C++ struct assignment\n    q->work.regElems[e].elem.isUsed = 1;\n    return;\n  }\n  q = ncclMemoryStackAlloc<struct ncclWorkList>(&comm->memScoped);\n  q->work.header.type = ncclWorkTypeRegColl;\n  q->work.header.funcIndex = funcIndex;\n  q->work.regElems[0] = *elem; // C++ struct assignment\n  q->work.regElems[0].elem.isUsed = 1;\n  chan->nWorkElem = 1;\n  chan->nWork += 1;\n  ncclIntruQueueEnqueue(&chan->workQueue, q);\n}\n\nstatic void finishWorkP2p(struct ncclWork* work) {\n  int nElem = 0;\n  for (int e=0; e < NCCL_MAX_WORK_ELEMENTS_P2P; e++) {\n    if (work->p2pElems[e].p2pType != ncclWorkP2pTypeUnused)\n      nElem = e+1;\n  }\n  int nGroup = 1;\n  while (nGroup < nElem) nGroup *= 2;\n  int nWarp = 1;\n  while (nWarp*nGroup <= (NCCL_MAX_NTHREADS/WARP_SIZE)/2) nWarp *= 2;\n  for (int i=0; i < nGroup; i++) {\n    work->p2pElems[i].ngroups = nGroup;\n    work->p2pElems[i].warpStart = i*(NCCL_MAX_NTHREADS/WARP_SIZE)/nGroup;\n    int extraWarp = nWarp >= 2 ? i%2 : 0;\n    work->p2pElems[i].nWarps = nWarp + extraWarp;\n  }\n}\n\nstatic void finishWork(struct ncclWork* work) {\n  if (work->header.type == ncclWorkTypeP2p) {\n    finishWorkP2p(work);\n  }\n}\n\nstatic void appendWorkElemP2p(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int channelId,\n    struct ncclWorkElemP2p const *elem, bool fuseOk\n  ) {\n  int funcIndex = ncclDevFuncId_P2p();\n  struct ncclKernelPlan::Channel* chan = &plan->channels[channelId];\n  struct ncclWorkList* q = ncclIntruQueueTail(&chan->workQueue);\n  if (q && funcIndex == q->work.header.funcIndex) {\n    if (!fuseOk) goto NewWork;\n    if (chan->p2pTailElem[elem->p2pType-1] < NCCL_MAX_WORK_ELEMENTS_P2P) {\n      for (int e = -2 + chan->p2pTailElem[elem->p2pType-1]; e >= 0; e -= 2) {\n        // Can't have multiple elements of the same ncclWork communicate with the\n        // same peer otherwise they would attempt to use that connection concurrently.\n        if (q->work.p2pElems[e].peer == elem->peer)\n          goto NewWork;\n      }\n      int e = chan->p2pTailElem[elem->p2pType-1];\n      q->work.p2pElems[e] = *elem; // C++ struct assignment\n      chan->p2pTailElem[elem->p2pType-1] += 2;\n      return;\n    }\n  NewWork:\n    finishWorkP2p(&q->work);\n  }\n  q = ncclMemoryStackAlloc<struct ncclWorkList>(&comm->memScoped);\n  q->work.header.type = ncclWorkTypeP2p;\n  q->work.header.funcIndex = ncclDevFuncId_P2p();\n  chan->p2pTailElem[ncclWorkP2pTypeRecv-1] = 0;\n  chan->p2pTailElem[ncclWorkP2pTypeSend-1] = 1;\n  q->work.p2pElems[chan->p2pTailElem[elem->p2pType-1]] = *elem; // C++ struct assignment\n  chan->p2pTailElem[elem->p2pType-1] += 2;\n  chan->nWork += 1;\n  ncclIntruQueueEnqueue(&chan->workQueue, q);\n}\n\nstatic ncclResult_t addProxyOpIfNeeded(struct ncclComm* comm, struct ncclKernelPlan* plan, struct ncclProxyOp* op) {\n  bool needed = true;\n  NCCLCHECK(ncclProxySaveOp(comm, op, &needed));\n  if (needed) {\n    struct ncclProxyOp* q = ncclMemoryPoolAlloc<struct ncclProxyOp>(&comm->memPool_ncclProxyOp, &comm->memPermanent);\n    *q = *op; // C++ struct assignment\n    ncclIntruQueueEnqueue(&plan->channels[op->channelId].proxyOpQueue, q);\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t computeCollSteps(struct ncclInfo* collInfo, size_t workCount, uint32_t* steps) {\n  struct ncclComm* comm = collInfo->comm;\n  if (collInfo->coll == ncclFuncAllReduce) {\n    if (collInfo->algorithm == NCCL_ALGO_RING)\n      *steps = DIVUP(workCount, comm->nRanks * collInfo->chunkCount) * (comm->nRanks - 1) * 2 * collInfo->chunkSteps;\n    else if (collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT)\n      *steps = DIVUP(workCount, comm->channels[0].collnetDirect.nHeads * collInfo->chunkCount) * collInfo->chunkSteps;\n    else if (collInfo->algorithm == NCCL_ALGO_NVLS || collInfo->algorithm == NCCL_ALGO_NVLS_TREE)\n      *steps = DIVUP(workCount, comm->channels[0].nvls.nHeads * collInfo->chunkCount) * collInfo->chunkSteps;\n    else\n      *steps = DIVUP(workCount, collInfo->chunkCount) * collInfo->chunkSteps;\n  } else if (collInfo->coll == ncclFuncReduceScatter) {\n    if (collInfo->algorithm == NCCL_ALGO_RING)\n      *steps = DIVUP(workCount, collInfo->chunkCount) * (comm->nRanks - 1) * collInfo->chunkSteps;\n    else\n      *steps = DIVUP(workCount, collInfo->chunkCount) * collInfo->chunkSteps;\n  } else if (collInfo->coll == ncclFuncAllGather) {\n    if (collInfo->algorithm == NCCL_ALGO_RING)\n      *steps = DIVUP(workCount, collInfo->chunkCount) * (comm->nRanks - 1) * collInfo->chunkSteps;\n    else\n      *steps = DIVUP(workCount, collInfo->chunkCount) * collInfo->chunkSteps;\n  } else {\n    *steps = DIVUP(workCount, collInfo->chunkCount) * collInfo->chunkSteps;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t computeCollAlignCount(struct ncclInfo* collInfo, size_t* alignCount) {\n  if (collInfo->protocol == NCCL_PROTO_SIMPLE) {\n    *alignCount = NCCL_SIMPLE_ALIGNMENT / ncclTypeSize(collInfo->datatype);\n  } else if (collInfo->protocol == NCCL_PROTO_LL128) {\n    *alignCount = NCCL_LL128_ALIGNMENT_PER_WARP / ncclTypeSize(collInfo->datatype) * (collInfo->nThreads / WARP_SIZE);\n  } else {\n    *alignCount = NCCL_LL_ALIGNMENT_PER_THREAD / ncclTypeSize(collInfo->datatype) * collInfo->nThreads;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t computeCollLastChunkInfo(struct ncclInfo* collInfo, size_t workCount, size_t alignCount, size_t* lastChunkCount) {\n  struct ncclComm* comm = collInfo->comm;\n\n  if (collInfo->coll == ncclFuncAllReduce) {\n    if (collInfo->algorithm == NCCL_ALGO_RING) {\n      size_t remCount = workCount % (comm->nRanks * collInfo->chunkCount);\n      *lastChunkCount = DIVUP(DIVUP(remCount, comm->nRanks), alignCount) * alignCount;\n    } else if (collInfo->algorithm == NCCL_ALGO_NVLS || collInfo->algorithm == NCCL_ALGO_NVLS_TREE) {\n      size_t remCount = workCount % (comm->channels[0].nvls.nHeads * collInfo->chunkCount);\n      *lastChunkCount = DIVUP(DIVUP(remCount, comm->channels[0].nvls.nHeads), alignCount) * alignCount;\n    } else if (collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT) {\n      size_t remCount = workCount % (comm->channels[0].collnetDirect.nHeads * collInfo->chunkCount);\n      *lastChunkCount = DIVUP(DIVUP(remCount, comm->channels[0].collnetDirect.nHeads), alignCount) * alignCount;\n    } else {\n      *lastChunkCount = collInfo->chunkCount;\n    }\n  } else {\n    *lastChunkCount = collInfo->chunkCount;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t getCollnetLoopInfo(struct ncclInfo* collInfo, int* nstepsPerLoop, int* nchunksPerLoop) {\n  switch (collInfo->pattern) {\n    case ncclPatternCollnetChain:\n      *nstepsPerLoop = *nchunksPerLoop = 1; break;\n    case ncclPatternNvls:\n      *nstepsPerLoop = 1; *nchunksPerLoop = collInfo->comm->channels[0].nvls.nHeads; break;\n    case ncclPatternCollnetDirect:\n      *nstepsPerLoop = 1; *nchunksPerLoop = collInfo->comm->channels[0].collnetDirect.nHeads; break;\n    default:\n      WARN(\"Unknown collnet pattern %d\", collInfo->pattern);\n      return ncclInternalError;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t addCollnetCollToPlan(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int usableChannels,\n    struct ncclInfo* collInfo, int* nWorkBudget\n  ) {\n  ncclResult_t ret = ncclSuccess;\n  struct ncclKernelPlan::Channel *chans = plan->channels;\n  struct ncclWorkElem workElem;\n  uint64_t opCount = uint64_t(plan->collOpCount++) << 1 | 0;\n  ncclRegBufferType regBufType = collInfo->regBufType;\n  int nChannels = std::min(collInfo->nChannels, usableChannels);\n  size_t countPerChannel = DIVUP(collInfo->count, nChannels);\n  uint32_t typeSize = ncclTypeSize(collInfo->datatype);\n  int steps, nchunksPerLoop, nstepsPerLoop, nLoop;\n\n  NCCLCHECK(computeCollChunkInfo(collInfo, collInfo->nBytes, collInfo->nChannels));\n  NCCLCHECKGOTO(initCollWorkElem(collInfo, &workElem), ret, fail);\n  workElem.nChannels = nChannels;\n\n  NCCLCHECKGOTO(getCollnetLoopInfo(collInfo, &nstepsPerLoop, &nchunksPerLoop), ret, fail);\n  nLoop = (int)DIVUP(collInfo->nBytes, (size_t)nChannels * nchunksPerLoop * collInfo->chunkSize);\n  steps = nstepsPerLoop * nLoop * collInfo->chunkSteps;\n\n  for (int bid = 0; bid < nChannels; bid++) {\n    workElem.bid = bid;\n    // Add work elem\n    *nWorkBudget += chans[bid].nWork;\n    if (regBufType == NCCL_REGULAR_BUFFER) {\n      appendWorkElemColl(comm, plan, bid, collInfo->workFuncIndex, &workElem);\n    } else {\n      struct ncclWorkElemReg workElemReg;\n      NCCLCHECKGOTO(initCollWorkElemReg(comm, &workElem, &comm->channels[bid], regBufType, collInfo->regBufSend, collInfo->regBufRecv, &workElemReg), ret, fail);\n      appendWorkElemColl(comm, plan, bid, collInfo->workFuncIndex, &workElemReg);\n    }\n    *nWorkBudget -= chans[bid].nWork; // subtract delta of chans[c].nWork\n\n    // Add proxy task. Empty collectives do not make it to the proxy thread\n    // since they don't imply synchronization for the user like p2p.\n    if (collInfo->nBytes != 0) {\n      struct ncclProxyOp proxyOp;\n      NCCLCHECKGOTO(initCollProxyOp(collInfo, bid, opCount, steps, &proxyOp), ret, fail);\n      NCCLCHECKGOTO(addProxyOpIfNeeded(comm, plan, &proxyOp), ret, fail);\n    }\n\n    chans[bid].collBytes += countPerChannel * typeSize;\n  }\n\n  plan->threadPerBlock = std::max(plan->threadPerBlock, collInfo->nThreads);\n  if (!plan->kernelSpecialized) {\n    plan->kernelFn = ncclDevKernelForFunc[collInfo->workFuncIndex];\n    plan->kernelSpecialized = ncclDevKernelForFuncIsSpecialized[collInfo->workFuncIndex];\n  }\n\n  if (comm->rank == 0) {\n    TRACE(NCCL_COLL, \"collnetColl enqueue coll %s(%s, %s, %s, %s), nChannels %d, count %ld (nbytes %ld), usableChannel %d, chunkCount %d, funcIndex %d, nThreads %d\", collInfo->opName, ncclOpToString(collInfo->op), ncclDatatypeToString(collInfo->datatype), ncclAlgoToString(collInfo->algorithm), ncclProtoToString(collInfo->protocol), collInfo->nChannels, collInfo->count, collInfo->workBytes, usableChannels, collInfo->chunkCount, collInfo->workFuncIndex, collInfo->nThreads);\n  }\n\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nstatic ncclResult_t addTunedCollToPlan(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int usableChannels,\n    struct ncclInfo* collInfo, int* nWorkBudget\n  ) {\n  ncclResult_t ret = ncclSuccess;\n  struct ncclKernelPlan::Channel *chans = plan->channels;\n  struct ncclWorkElem workElem;\n  uint64_t opCount = uint64_t(plan->collOpCount++) << 1 | 0;\n  uint64_t workCount;\n  uint64_t workOffset = 0;\n  uint32_t typeSize = ncclTypeSize(collInfo->datatype);\n  ncclRegBufferType regBufType = collInfo->regBufType;\n  size_t alignCount, lastChunkCount;\n  int least[/*nBid*/MAXCHANNELS];\n  int maxIndexInLeast;\n  size_t maxBytesInLeast;\n  int nChannels = std::min(collInfo->nChannels, usableChannels);\n  int rnChannels = 0;\n  size_t countPerChannels;\n  size_t remCount = collInfo->count;\n\n  NCCLCHECKGOTO(computeCollAlignCount(collInfo, &alignCount), ret, fail);\n  countPerChannels = DIVUP(DIVUP(collInfo->count, nChannels), alignCount) * alignCount;\n  nChannels = DIVUP(collInfo->count, countPerChannels);\n  NCCLCHECKGOTO(computeCollChunkInfo(collInfo, collInfo->nBytes, nChannels), ret, fail);\n  NCCLCHECKGOTO(initCollWorkElem(collInfo, &workElem), ret, fail);\n\n  // Choose the `nBid` least loaded channels to do the work. This ensures\n  // all bids go to different channels in case they need to synchronize.\n  least[0] = 0;\n  maxIndexInLeast = 0;\n  maxBytesInLeast = chans[0].collBytes;\n  // Initialize least[] such that the first nBid channels are accounted for.\n  for (int b = 1; b < nChannels; b++) {\n    least[b] = b;\n    if (maxBytesInLeast < chans[b].collBytes) {\n      maxIndexInLeast = b;\n      maxBytesInLeast = chans[b].collBytes;\n    }\n  }\n  // Sort in the rest of the channels. If a channel has less work than the max\n  // member of least[], replace that member and compute the new max. We only\n  // sort channels when coll algo is not collnet.\n  for (int c = nChannels; c < usableChannels; c++) {\n    if (chans[c].collBytes < maxBytesInLeast) {\n      least[maxIndexInLeast] = c;\n      maxBytesInLeast = chans[least[0]].collBytes;\n      maxIndexInLeast = 0;\n      for (int b = 1; b < nChannels; b++) {\n        if (maxBytesInLeast < chans[least[b]].collBytes) {\n          maxIndexInLeast = b;\n          maxBytesInLeast = chans[least[b]].collBytes;\n        }\n      }\n    }\n  }\n\n  for (int bid = 0; bid < nChannels && remCount > 0; bid++) {\n    int c = least[bid];\n\n    workCount = std::min(countPerChannels, remCount);\n    NCCLCHECKGOTO(computeCollLastChunkInfo(collInfo, workCount, alignCount, &lastChunkCount), ret, fail);\n    NCCLCHECKGOTO(setCollWorkElem(workCount, workOffset, lastChunkCount, &workElem), ret, fail);\n\n    // Add work elem\n    *nWorkBudget += chans[c].nWork;\n    if (regBufType == NCCL_REGULAR_BUFFER) {\n      appendWorkElemColl(comm, plan, c, collInfo->workFuncIndex, &workElem);\n    } else {\n      struct ncclWorkElemReg workElemReg;\n      NCCLCHECKGOTO(initCollWorkElemReg(comm, &workElem, &comm->channels[c], regBufType, collInfo->regBufSend, collInfo->regBufRecv, &workElemReg), ret, fail);\n      appendWorkElemColl(comm, plan, c, collInfo->workFuncIndex, &workElemReg);\n    }\n    *nWorkBudget -= chans[c].nWork; // subtract delta of chans[c].nWork\n\n    // Add proxy task. Empty collectives do not make it to the proxy thread\n    // since they don't imply synchronization for the user like p2p.\n    if (collInfo->nBytes != 0) {\n      uint32_t steps;\n      struct ncclProxyOp proxyOp;\n      NCCLCHECKGOTO(computeCollSteps(collInfo, workCount, &steps), ret, fail);\n      NCCLCHECKGOTO(initCollProxyOp(collInfo, c, opCount, steps, &proxyOp), ret, fail);\n      NCCLCHECKGOTO(addProxyOpIfNeeded(comm, plan, &proxyOp), ret, fail);\n    }\n\n    remCount -= workCount;\n    chans[c].collBytes += workCount * typeSize;\n    workOffset += workCount;\n    rnChannels++;\n  }\n\n  plan->threadPerBlock = std::max(plan->threadPerBlock, collInfo->nThreads);\n  if (!plan->kernelSpecialized) {\n    plan->kernelFn = ncclDevKernelForFunc[collInfo->workFuncIndex];\n    plan->kernelSpecialized = ncclDevKernelForFuncIsSpecialized[collInfo->workFuncIndex];\n  }\n\n  if (comm->rank == 0) {\n    TRACE(NCCL_COLL, \"tunedColl enqueue coll %s(%s, %s, %s, %s), nChannels %d, count %ld (nbytes %ld), usableChannel %d, chunkCount %d, lastChunkCount %ld, funcIndex %d, nThreads %d\", collInfo->opName, ncclOpToString(collInfo->op), ncclDatatypeToString(collInfo->datatype), ncclAlgoToString(collInfo->algorithm), ncclProtoToString(collInfo->protocol), rnChannels, collInfo->count, collInfo->workBytes, usableChannels, collInfo->chunkCount, lastChunkCount, collInfo->workFuncIndex, collInfo->nThreads);\n  }\n\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nstatic ncclResult_t addCBDCollToPlan(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int usableChannels,\n    struct ncclInfo* collInfo, int* nWorkBudget\n  ) {\n  ncclResult_t ret = ncclSuccess;\n  struct ncclKernelPlan::Channel *chans = plan->channels;\n  size_t enqBytes;\n  uint64_t opCount = uint64_t(plan->collOpCount++) << 1 | 0;\n  size_t typeSize = ncclTypeSize(collInfo->datatype);\n  size_t workBytesTotal = collInfo->count * typeSize;\n  size_t workCountTotal = collInfo->count;\n  struct ncclWorkElem workElem;\n  size_t workOffset = 0;\n  size_t workCount;\n  ncclRegBufferType regBufType = collInfo->regBufType;\n  size_t alignCount;\n  size_t lastChunkCount;\n  int rnChannel = 0;\n\n  NCCLCHECKGOTO(computeCollChunkInfo(collInfo, collInfo->aggnBytes, collInfo->nChannels), ret, fail);\n  NCCLCHECKGOTO(computeCollAlignCount(collInfo, &alignCount), ret, fail);\n  NCCLCHECKGOTO(initCollWorkElem(collInfo, &workElem), ret, fail);\n  for (int c = 0; c < usableChannels; c++) {\n    if (plan->maxBytesPerChannel <= chans[c].collBytes) continue;\n    if (workBytesTotal == 0) break;\n    enqBytes = std::min(plan->maxBytesPerChannel - chans[c].collBytes, workBytesTotal);\n    workCount = std::min(DIVUP(DIVUP(enqBytes, typeSize), alignCount) * alignCount, workCountTotal);\n    enqBytes = workCount * typeSize;\n\n    NCCLCHECKGOTO(computeCollLastChunkInfo(collInfo, workCount, alignCount, &lastChunkCount), ret, fail);\n    NCCLCHECKGOTO(setCollWorkElem(workCount, workOffset, lastChunkCount, &workElem), ret, fail);\n\n    // Add work elem\n    *nWorkBudget += chans[c].nWork;\n    if (regBufType == NCCL_REGULAR_BUFFER) {\n      appendWorkElemColl(comm, plan, c, collInfo->workFuncIndex, &workElem);\n    } else {\n      struct ncclWorkElemReg workElemReg;\n      NCCLCHECKGOTO(initCollWorkElemReg(comm, &workElem, &comm->channels[c], regBufType, collInfo->regBufSend, collInfo->regBufRecv, &workElemReg), ret, fail);\n      appendWorkElemColl(comm, plan, c, collInfo->workFuncIndex, &workElemReg);\n    }\n    *nWorkBudget -= chans[c].nWork; // subtract delta of chans[c].nWork\n\n    // Add proxy task. Empty collectives do not make it to the proxy thread\n    // since they don't imply synchronization for the user like p2p.\n    if (collInfo->nBytes != 0) {\n      uint32_t steps;\n      struct ncclProxyOp proxyOp;\n      NCCLCHECKGOTO(computeCollSteps(collInfo, workCount, &steps), ret, fail);\n      NCCLCHECKGOTO(initCollProxyOp(collInfo, c, opCount, steps, &proxyOp), ret, fail);\n      NCCLCHECKGOTO(addProxyOpIfNeeded(comm, plan, &proxyOp), ret, fail);\n    }\n\n    workBytesTotal -= enqBytes;\n    workCountTotal -= workCount;\n    chans[c].collBytes += enqBytes;\n    workOffset += workCount;\n    rnChannel++;\n  }\n\n  plan->threadPerBlock = std::max(plan->threadPerBlock, collInfo->nThreads);\n  if (!plan->kernelSpecialized) {\n    plan->kernelFn = ncclDevKernelForFunc[collInfo->workFuncIndex];\n    plan->kernelSpecialized = ncclDevKernelForFuncIsSpecialized[collInfo->workFuncIndex];\n  }\n\n  if (comm->rank == 0) {\n    TRACE(NCCL_COLL, \"CBDColl enqueue coll %s(%s, %s, %s, %s), nChannels %d, count %ld (nbytes %ld), usableChannel %d, maxBytesPerChannel %ld, chunkCount %d, lastChunkCount %ld, funcIndex %d, nThreads %d\", collInfo->opName, ncclOpToString(collInfo->op), ncclDatatypeToString(collInfo->datatype), ncclAlgoToString(collInfo->algorithm), ncclProtoToString(collInfo->protocol), rnChannel, collInfo->count, collInfo->workBytes, usableChannels, plan->maxBytesPerChannel, collInfo->chunkCount, lastChunkCount, collInfo->workFuncIndex, collInfo->nThreads);\n  }\n\nexit:\n  return ret;\nfail:\n  goto exit;\n}\n\nNCCL_PARAM(P2pLLThreshold, \"P2P_LL_THRESHOLD\", 16384);\n\n// Put p2p op in plan assuming there is space in nWorkBudget, so you must\n// ensure *nWorkBudget >= 1 upon entry.\nstatic ncclResult_t addP2pToPlan(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int* nWorkBudget,\n    bool isSendNotRecv, int peer, int chunk, void *addr, size_t bytes, bool fuseOk\n  ) {\n  struct ncclInfo info = {\n    isSendNotRecv ? ncclFuncSend : ncclFuncRecv,\n    isSendNotRecv ? \"Send\" : \"Recv\",\n    nullptr, addr, bytes, ncclInt8, ncclSum, peer, comm, (cudaStream_t)0,\n    /*Args*/1, 1\n  };\n\n  int channelId;\n  NCCLCHECK(ncclChannelCompute(comm, peer, chunk%comm->p2pnChannelsPerPeer, info.coll, &channelId));\n  info.channelId = channelId;\n\n  // 1 is connIndex\n  struct ncclConnInfo* conn = isSendNotRecv ?\n    &comm->channels[channelId].peers[peer]->send[1].conn : &comm->channels[channelId].peers[peer]->recv[1].conn;\n  info.protocol = ((conn->buffs[NCCL_PROTO_LL] != nullptr) && bytes <= ncclParamP2pLLThreshold()) ? NCCL_PROTO_LL : NCCL_PROTO_SIMPLE;\n\n  int reg = 0;\n  if (info.protocol == NCCL_PROTO_SIMPLE) {\n    struct ncclReg* regRecord;\n    NCCLCHECK(ncclRegFind(comm, addr, bytes, &regRecord));\n    reg = regRecord && regRecord->nDevs ? 1 : 0;\n  }\n\n  struct ncclProxyOp proxyOp = {};\n  // May tune chunksize and set proxyOp.reg=0 if not using the network.\n  NCCLCHECK(ncclProxyComputeP2p(&info, &proxyOp, reg));\n\n  struct ncclWorkElemP2p elem = {0};\n  elem.proto = info.protocol;\n  elem.peer = peer;\n  elem.nWarps = NCCL_MAX_NTHREADS/WARP_SIZE;\n  elem.reg = proxyOp.reg;\n  elem.p2pType = isSendNotRecv ? ncclWorkP2pTypeSend : ncclWorkP2pTypeRecv;\n  elem.buffLo32 = uint32_t(reinterpret_cast<uintptr_t>(addr));\n  elem.buffHi32 = reinterpret_cast<uintptr_t>(addr)>>32;\n  elem.countLo32 = uint32_t(bytes);\n  elem.countHi32 = bytes>>32;\n  elem.chunkSize = info.chunkSize; // computed by ncclProxyComputeP2p\n\n  *nWorkBudget += plan->channels[channelId].nWork;\n  appendWorkElemP2p(comm, plan, channelId, &elem, fuseOk);\n  *nWorkBudget -= plan->channels[channelId].nWork;\n\n  // Calculate the opCount after appendWorkElemP2p since it will always return\n  // with channel->nWork equal to one plus the work index this p2p settled in.\n  proxyOp.opCount = uint64_t(plan->channels[channelId].nWork)<<1 | 1;\n  NCCLCHECK(addProxyOpIfNeeded(comm, plan, &proxyOp));\n  return ncclSuccess;\n}\n\nstatic void finishPlan(struct ncclKernelPlan* plan) {\n  int channelUbound = 0;\n  int channelCount = 0;\n  uint64_t channelMask = 0;\n  bool hasProxyOps = false;\n  for (int c=0; c < MAXCHANNELS; c++) {\n    struct ncclWorkList* tail = ncclIntruQueueTail(&plan->channels[c].workQueue);\n    if (tail != nullptr) {\n      channelUbound = c+1;\n      channelCount += 1;\n      channelMask |= 1ull<<c;\n      tail->work.header.isLast = 1;\n      finishWork(&tail->work);\n    }\n    hasProxyOps |= !ncclIntruQueueEmpty(&plan->channels[c].proxyOpQueue);\n  }\n  plan->channelUbound = channelUbound;\n  plan->channelCount = channelCount;\n  plan->channelMask = channelMask;\n  plan->hasProxyOps = hasProxyOps;\n  plan->threadPerBlock = std::max(plan->threadPerBlock, 3*WARP_SIZE);\n}\n\nint64_t ncclParamLocalRegister();\nNCCL_PARAM(GraphRegister, \"GRAPH_REGISTER\", 1);\n\nstatic ncclResult_t registerIntraNodeBuffers(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, struct ncclInfo* info\n  ) {\n  ncclResult_t result = ncclSuccess;\n\n  info->regBufType = NCCL_REGULAR_BUFFER;\n#if CUDART_VERSION >= 11030\n  if ((info->algorithm == NCCL_ALGO_NVLS || info->algorithm == NCCL_ALGO_NVLS_TREE) && comm->nvlsRegSupport) {\n    bool regBufUsed = false;\n    const void *sendbuff = info->sendbuff;\n    void *recvbuff = info->recvbuff;\n\n    if (info->coll == ncclFuncAllGather)\n      sendbuff = NULL;\n    else if (info->coll == ncclFuncReduceScatter)\n      recvbuff = NULL;\n\n    /* first try local registration. */\n    if (ncclParamLocalRegister()) {\n      ncclNvlsLocalRegisterBuffer(comm, sendbuff, recvbuff, info->sendbuffSize, info->recvbuffSize, &regBufUsed, info->regBufSend, info->regBufRecv);\n    }\n\n    if (regBufUsed == false && plan->persistent && ncclParamGraphRegister()) {\n      ncclNvlsGraphRegisterBuffer(comm, plan, sendbuff, recvbuff, info->sendbuffSize, info->recvbuffSize, &regBufUsed, info->regBufSend, info->regBufRecv);\n    }\n\n    if (regBufUsed) {\n      /* tweak NVLS channels usage; for registered NVLS buffer, we only need 4/5 channels to\n       * saturate bandwidth. */\n      if (comm->nNodes == 1) {\n        if (info->coll == ncclFuncReduceScatter)\n          info->nChannels = std::max(comm->config.minCTAs, std::min(comm->config.maxCTAs, 5));\n        else\n          info->nChannels = std::max(comm->config.minCTAs, std::min(comm->config.maxCTAs, 4));\n      } else {\n        info->nChannels = std::max(comm->config.minCTAs, std::min(comm->config.maxCTAs, 6));\n      }\n\n      info->regBufType = NCCL_NVLS_REG_BUFFER;\n    }\n  } else if (info->algorithm == NCCL_ALGO_COLLNET_DIRECT &&   // limited to CollNetDirect for now\n    comm->intraHighestTransportType == TRANSPORT_P2P && // only when all ranks can p2p each other\n    comm->intraRanks < comm->localRanks &&  // only with inter-process & intra-node peers\n    plan->persistent && 0) {\n    /* Disable CollnetDirect registration since it does not support cuMem* allocated memory. */\n    int localRank = comm->localRank;\n    cudaPointerAttributes sattr, rattr;\n\n    CUDACHECK(cudaPointerGetAttributes(&sattr, info->sendbuff));\n    CUDACHECK(cudaPointerGetAttributes(&rattr, info->recvbuff));\n    if (sattr.type != cudaMemoryTypeDevice || rattr.type != cudaMemoryTypeDevice) return ncclSuccess;\n\n    if (CUPFN(cuMemGetAddressRange) == nullptr) return ncclSuccess;\n\n    struct HandlePair {\n      cudaIpcMemHandle_t ipc[2]; // {send, recv}\n      size_t offset[2]; // {send, recv}\n    };\n    struct HandlePair handles[NCCL_MAX_LOCAL_RANKS];\n\n    CUDACHECKGOTO(cudaIpcGetMemHandle(&handles[localRank].ipc[0], (void*)info->sendbuff), result, fallback);\n    CUDACHECKGOTO(cudaIpcGetMemHandle(&handles[localRank].ipc[1], (void*)info->recvbuff), result, fallback);\n\n    void *baseSend, *baseRecv;\n    size_t size;\n    CUCHECK(cuMemGetAddressRange((CUdeviceptr *)&baseSend, &size, (CUdeviceptr)info->sendbuff));\n    handles[localRank].offset[0] = (char*)info->sendbuff - (char*)baseSend;\n    CUCHECK(cuMemGetAddressRange((CUdeviceptr *)&baseRecv, &size, (CUdeviceptr)info->recvbuff));\n    handles[localRank].offset[1] = (char*)info->recvbuff - (char*)baseRecv;\n\n    NCCLCHECK(bootstrapIntraNodeAllGather(comm->bootstrap, comm->localRankToRank, comm->localRank, comm->localRanks, handles, sizeof(struct HandlePair)));\n\n    // Open handles locally\n    for (int i=0; i < comm->localRanks; i++) {\n      if (i == localRank) { // Skip self\n        info->regBufSend[i] = nullptr;\n        info->regBufRecv[i] = nullptr;\n      } else {\n        for (int sr=0; sr < 2; sr++) {\n          // Get base address of mapping\n          void* base;\n          CUDACHECK(cudaIpcOpenMemHandle(&base, handles[i].ipc[sr], cudaIpcMemLazyEnablePeerAccess));\n          // Get real buffer address by adding offset in the mapping\n          (sr == 0 ? info->regBufSend : info->regBufRecv)[i] = (char*)base + handles[i].offset[sr];\n          // Enqueue reminder to close memory handle\n          struct ncclPointerList* q = ncclMemoryPoolAlloc<struct ncclPointerList>(&comm->memPool_ncclPointerList, &comm->memPermanent);\n          q->ptr = base;\n          ncclIntruQueueEnqueue(&plan->ipcMemQueue, q);\n        }\n      }\n    }\n    info->regBufType = NCCL_IPC_REG_BUFFER;\n  } else if ((info->algorithm == NCCL_ALGO_COLLNET_DIRECT || info->algorithm == NCCL_ALGO_COLLNET_CHAIN) && comm->collNetRegSupport && info->opFull.op != ncclDevPreMulSum && info->opFull.op != ncclDevSumPostDiv) {\n    int sendRegBufFlag = 0;\n    int recvRegBufFlag = 0;\n    void *sendHandle, *recvHandle;\n\n    if (ncclParamLocalRegister()) {\n      ncclCollnetLocalRegisterBuffer(comm, info->sendbuff, info->sendbuffSize, collNetSend, &sendRegBufFlag, &sendHandle);\n      info->sendMhandle = sendHandle;\n      if (sendRegBufFlag) {\n        ncclCollnetLocalRegisterBuffer(comm, info->recvbuff, info->recvbuffSize, collNetRecv, &recvRegBufFlag, &recvHandle);\n        info->recvMhandle = recvHandle;\n      }\n    }\n\n    if ((sendRegBufFlag == 0 || recvRegBufFlag == 0) && plan->persistent && ncclParamGraphRegister()) {\n      ncclCollnetGraphRegisterBuffer(comm, plan, info->sendbuff, info->sendbuffSize, collNetSend, &sendRegBufFlag, &sendHandle);\n      info->sendMhandle = sendHandle;\n      if (sendRegBufFlag) {\n        ncclCollnetGraphRegisterBuffer(comm, plan, info->recvbuff, info->recvbuffSize, collNetRecv, &recvRegBufFlag, &recvHandle);\n        info->recvMhandle = recvHandle;\n      }\n    }\n\n    if (sendRegBufFlag && recvRegBufFlag) {\n      info->nChannels = std::max(comm->config.minCTAs, std::min(comm->config.maxCTAs, 1));\n      info->regBufType = NCCL_COLLNET_REG_BUFFER;\n      if (sendRegBufFlag == 1 && recvRegBufFlag == 1) {\n        INFO(NCCL_REG, \"rank %d successfully registered collNet sendbuff %p (handle %p), sendbuff size %ld, recvbuff %p (handle %p), recvbuff size %ld\", comm->rank, info->sendbuff, sendHandle, info->sendbuffSize, info->recvbuff, recvHandle, info->recvbuffSize);\n      }\n    }\n  }\nfallback:\n#endif\n  return result;\n}\n\nstatic ncclResult_t getCBDCollnChannel(struct ncclKernelPlan* plan, struct ncclInfo* collInfo, int usableChannels) {\n  size_t firstEnqBytes;\n  size_t workBytesTotal = collInfo->workBytes;\n  struct ncclKernelPlan::Channel *chans = plan->channels;\n  int typeSize = ncclTypeSize(collInfo->datatype);\n  size_t maxCount = DIVUP(plan->maxBytesPerChannel, typeSize);\n\n  if (workBytesTotal == 0) {\n    collInfo->nChannels = 1;\n    goto exit;\n  }\n\n  for (int c = 0; c < usableChannels; c++) {\n    if (plan->maxBytesPerChannel <= chans[c].collBytes) continue;\n    firstEnqBytes = std::min(plan->maxBytesPerChannel - chans[c].collBytes, workBytesTotal);\n    firstEnqBytes = DIVUP(firstEnqBytes, typeSize) * typeSize;\n    collInfo->nChannels = 1 + DIVUP((workBytesTotal - firstEnqBytes) / typeSize, maxCount);\n    break;\n  }\n\nexit:\n  return ncclSuccess;\n}\n\nstatic ncclResult_t scheduleCollTasksToPlan(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int* nWorkBudget\n  ) {\n  struct ncclTasks* tasks = &comm->tasks;\n  size_t totalCBDBytes = tasks->workBytesTotal;\n  struct ncclInfo* collInfo;\n\n  if (!ncclIntruQueueEmpty(&tasks->collQueue)) {\n    int usableChannels = 0, accChannels = 0;\n\n    tasks->usableChannels = 1;\n    while (!ncclIntruQueueEmpty(&tasks->collQueue)) {\n      collInfo = ncclIntruQueueDequeue(&tasks->collQueue);\n      if (collInfo->count == 0) continue;\n      if (collInfo->algorithm == NCCL_ALGO_UNDEF) {\n        struct ncclInfo* aggInfo = ncclMemoryStackAlloc<struct ncclInfo>(&comm->memScoped);\n        struct ncclInfo* nextInfo = collInfo->next;\n        int nvlsSupport;\n        int collNetSupport;\n\n        memcpy(aggInfo, collInfo, sizeof(struct ncclInfo));\n        while (nextInfo) {\n          if (nextInfo->coll == aggInfo->coll && nextInfo->opFull.op == aggInfo->opFull.op && nextInfo->datatype == aggInfo->datatype) {\n            aggInfo->count += nextInfo->count;\n            nextInfo = nextInfo->next;\n          } else {\n            break;\n          }\n        }\n\n        nvlsSupport = comm->nvlsSupport && ncclNvlsSupported(aggInfo->opFull.op, aggInfo->datatype);\n        NCCLCHECK(getCollNetSupport(aggInfo, &collNetSupport));\n        NCCLCHECK(ncclInfoSetDerived(aggInfo, comm->nRanks));\n        NCCLCHECK(getTunerInfo(aggInfo, collNetSupport, nvlsSupport, 1));\n        NCCLCHECK(topoGetAlgoInfo(aggInfo, collNetSupport, nvlsSupport, 1));\n        NCCLCHECK(getChannnelThreadInfo(aggInfo));\n        NCCLCHECK(computeCollWorkFunc(aggInfo));\n        NCCLCHECK(getPatternInfo(aggInfo));\n\n        // Try to assign algo and proto to all possible collectives\n        nextInfo = collInfo;\n        while (nextInfo) {\n          if (nextInfo->coll == aggInfo->coll && nextInfo->opFull.op == aggInfo->opFull.op && nextInfo->datatype == aggInfo->datatype) {\n            NCCLCHECK(ncclInfoSetDerived(nextInfo, comm->nRanks));\n            NCCLCHECK(getTunerInfo(nextInfo, collNetSupport, nvlsSupport, 1));\n            nextInfo->algorithm = aggInfo->algorithm;\n            nextInfo->protocol = aggInfo->protocol;\n            nextInfo->nThreads = aggInfo->nThreads;\n            nextInfo->pattern = aggInfo->pattern;\n            nextInfo->workFuncIndex = aggInfo->workFuncIndex;\n            nextInfo->aggnBytes = aggInfo->nBytes;\n\n            NCCLCHECK(getChannnelThreadInfo(nextInfo));\n            // if possible, start registration\n            registerIntraNodeBuffers(comm, plan, nextInfo);\n            // accumulate channels\n            accChannels += nextInfo->nChannels;\n            nextInfo = nextInfo->next;\n          } else {\n            break;\n          }\n        }\n      } // end of aggInfo\n\n      if (collInfo->algorithm == NCCL_ALGO_NVLS || collInfo->algorithm == NCCL_ALGO_NVLS_TREE) {\n        usableChannels = std::max(usableChannels, comm->nvlsChannels);\n      } else {\n        usableChannels = std::max(usableChannels, comm->collChannels);\n      }\n\n      if (collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT || collInfo->algorithm == NCCL_ALGO_COLLNET_CHAIN || (collInfo->algorithm == NCCL_ALGO_NVLS && comm->nNodes > 1)) {\n        // substract collective which needs to be executed separately\n        totalCBDBytes -= collInfo->workBytes;\n        tasks->workBytesTotal -= collInfo->workBytes;\n        ncclIntruQueueEnqueue(&tasks->collnetQueue, collInfo);\n      } else if (collInfo->userTuned) {\n        // substract collective which needs to be executed separately\n        totalCBDBytes -= collInfo->workBytes;\n        tasks->workBytesTotal -= collInfo->workBytes;\n        ncclIntruQueueEnqueue(&tasks->collTunedQueue, collInfo);\n      } else {\n        ncclIntruQueueEnqueue(&tasks->collCBDQueue, collInfo);\n      }\n    }\n\n    tasks->usableChannels = std::min(usableChannels, accChannels);\n  }\n\n  /* Calculate maxBytesPerChannel for CBD colls and it should be 16 bytes aligned\n   * Note: it it not hard upper bound for maxBytes, we can relax it if any optimization\n   * is needed */\n  plan->maxBytesPerChannel = DIVUP(DIVUP(totalCBDBytes, tasks->usableChannels), NCCL_BYTES_ALIGNMENT) * NCCL_BYTES_ALIGNMENT;\n  // First enqueue CBD colls\n  while (!ncclIntruQueueEmpty(&tasks->collCBDQueue)) {\n    // Get nChannels and peek whether the budget allows before we enqueue\n    collInfo = ncclIntruQueueHead(&tasks->collCBDQueue);\n    collInfo->nChannels = DIVUP(collInfo->workBytes * tasks->usableChannels, totalCBDBytes);\n    // Haven't got nChannels info yet, relax the budget boundary a bit.\n    if (*nWorkBudget < collInfo->nChannels) return ncclSuccess;\n\n    collInfo = ncclIntruQueueDequeue(&tasks->collCBDQueue);\n    NCCLCHECK(addCBDCollToPlan(comm, plan, tasks->usableChannels, collInfo, nWorkBudget));\n    tasks->nTasksColl -= 1;\n    tasks->workBytesTotal -= collInfo->count * ncclTypeSize(collInfo->datatype);\n  }\n\n  // Then enqueue collnet colls\n  while (!ncclIntruQueueEmpty(&tasks->collnetQueue)) {\n    collInfo = ncclIntruQueueHead(&tasks->collnetQueue);\n    if (*nWorkBudget < collInfo->nChannels) return ncclSuccess;\n\n    collInfo = ncclIntruQueueDequeue(&tasks->collnetQueue);\n    NCCLCHECK(addCollnetCollToPlan(comm, plan, tasks->usableChannels, collInfo, nWorkBudget));\n    tasks->nTasksColl -= 1;\n  }\n\n  // Finally enqueue user-tuned colls\n  while (!ncclIntruQueueEmpty(&tasks->collTunedQueue)) {\n    collInfo = ncclIntruQueueHead(&tasks->collTunedQueue);\n    if (*nWorkBudget < collInfo->nChannels) return ncclSuccess;\n\n    collInfo = ncclIntruQueueDequeue(&tasks->collTunedQueue);\n    NCCLCHECK(addTunedCollToPlan(comm, plan, tasks->usableChannels, collInfo, nWorkBudget));\n    tasks->nTasksColl -= 1;\n  }\n\n  return ncclSuccess;\n}\n\nstatic size_t calcP2pChunkSize(size_t totalSize, int minChannels, int maxChannels, size_t minSize, size_t maxSize) {\n  size_t size = std::max(minSize, divUp(totalSize, minChannels));\n  int nChannels = minChannels;\n  while (size > maxSize && nChannels <= maxChannels/2) {\n    nChannels *= 2;\n    size = divUp(totalSize, nChannels);\n  }\n  return alignUp(size, minSize);\n}\n\nstatic ncclResult_t scheduleP2pTasksToPlan(\n    struct ncclComm* comm, struct ncclKernelPlan* plan, int* nWorkBudget\n  ) {\n  struct ncclTasks* tasks = &comm->tasks;\n  int nRanks = comm->nRanks;\n  struct ncclTasks::Peer* peers = tasks->peers;\n  int const *sendOrder = tasks->p2pSendOrder;\n  int const *recvOrder = tasks->p2pRecvOrder;\n\n  plan->threadPerBlock = std::max(plan->threadPerBlock, NCCL_MAX_NTHREADS);\n  if (!plan->kernelSpecialized) {\n    plan->kernelFn = ncclDevKernelForFunc[ncclDevFuncId_P2p()];\n    plan->kernelSpecialized = ncclDevKernelForFuncIsSpecialized[ncclDevFuncId_P2p()];\n  }\n\n  // Compute how much to split operations\n  // Natural step size matching buffer steps.\n  ssize_t stepSize = comm->p2pChunkSize;\n  // Try to use all channels\n  int nChannelsMax = comm->p2pnChannelsPerPeer;\n  int nChannelsMin = nChannelsMax;\n  // Try to use all channels, but one channel per operation.\n  while (nChannelsMin*nRanks > comm->p2pnChannels && nChannelsMin > 1) nChannelsMin /= 2;\n\n  bool fuseOk = false;\n  // We can perform 8 send/recv per round per CTA. Make sure we jump between fused blocks at node boundaries.\n  while (tasks->nTasksP2p != 0) {\n    for (int i=0; i < tasks->p2pOrderSteps; i++) {\n      int sendPeer = sendOrder[i];\n      int recvPeer = recvOrder[i];\n      struct ncclTaskP2p* send = sendPeer != -1 ? ncclIntruQueueHead(&peers[sendPeer].sendQueue) : NULL;\n      struct ncclTaskP2p* recv = recvPeer != -1 ? ncclIntruQueueHead(&peers[recvPeer].recvQueue) : NULL;\n      if (sendPeer == comm->rank) {\n        if (recvPeer != comm->rank) {\n          WARN(\"Sendrecv plan not aligned for self\");\n          return ncclInternalError;\n        }\n        if (send && recv == nullptr) {\n          WARN(\"Trying to send to self without a matching recv\");\n          return ncclInvalidUsage;\n        }\n        if (send == nullptr && recv) {\n          WARN(\"Trying to recv to self without a matching send\");\n          return ncclInvalidUsage;\n        }\n      }\n      if (send != nullptr || recv != nullptr) {\n        char* recvPtr = recv ? (char*)recv->buff : nullptr;\n        char* sendPtr = send ? (char*)send->buff : nullptr;\n        ssize_t recvBytes = recv ? recv->bytes : 0;\n        ssize_t sendBytes = send ? send->bytes : 0;\n        ssize_t minSize = comm->nNodes > 1 ? stepSize/2 : stepSize/8;\n        ssize_t maxSize = comm->nNodes > 1 ? stepSize : stepSize*32;\n        ssize_t recvChunkBytesMax = calcP2pChunkSize(recvBytes, nChannelsMin, nChannelsMax, minSize, maxSize);\n        ssize_t sendChunkBytesMax = calcP2pChunkSize(sendBytes, nChannelsMin, nChannelsMax, minSize, maxSize);\n        // Zero size send/recv are syncs, encode here with -1.\n        recvBytes = recv && recvBytes == 0 ? -1 : recvBytes;\n        sendBytes = send && sendBytes == 0 ? -1 : sendBytes;\n        // Advance to current chunk. Syncs will always have chunk=0 so no effect on the -1.\n        if (recv) recvPtr   += recv->chunk*recvChunkBytesMax;\n        if (recv) recvBytes -= recv->chunk*recvChunkBytesMax;\n        if (send) sendPtr   += send->chunk*sendChunkBytesMax;\n        if (send) sendBytes -= send->chunk*sendChunkBytesMax;\n\n        do {\n          if ((i % (NCCL_MAX_WORK_ELEMENTS_P2P/2)) == 0) fuseOk = false;\n          ssize_t recvChunkBytes = std::min(recvBytes, recvChunkBytesMax); // -1 preserved\n          ssize_t sendChunkBytes = std::min(sendBytes, sendChunkBytesMax);\n          if (recvChunkBytes != 0) {\n            if (recvChunkBytes == -1) recvChunkBytes = 0;\n            if (*nWorkBudget < 1) return ncclSuccess; // ensure room in budget\n            NCCLCHECK(addP2pToPlan(comm, plan, nWorkBudget, /*isSendNotRecv=*/false, recvPeer, recv->chunk, recvPtr, recvChunkBytes, fuseOk));\n            fuseOk = true;\n            recvPtr += recvChunkBytes;\n            recvBytes -= recvChunkBytes;\n            recv->chunk += 1;\n            if (recvBytes <= 0) {\n              recvBytes = 0; // in case still -1\n              ncclIntruQueueDequeue(&peers[recvPeer].recvQueue);\n              tasks->nTasksP2p -= 1;\n            }\n          }\n          if (sendChunkBytes != 0) {\n            if (sendChunkBytes == -1) sendChunkBytes = 0;\n            if (*nWorkBudget < 1) return ncclSuccess; // ensure room in budget\n            NCCLCHECK(addP2pToPlan(comm, plan, nWorkBudget, /*isSendNotRecv=*/true, sendPeer, send->chunk, sendPtr, sendChunkBytes, fuseOk));\n            fuseOk = true;\n            sendPtr += sendChunkBytes;\n            sendBytes -= sendChunkBytes;\n            send->chunk += 1;\n            if (sendBytes <= 0) {\n              sendBytes = 0; // in case still -1\n              ncclIntruQueueDequeue(&peers[sendPeer].sendQueue);\n              tasks->nTasksP2p -= 1;\n            }\n          }\n        } while (sendBytes != 0 || recvBytes != 0);\n      }\n    }\n  }\n  return ncclSuccess;\n}\n\n// Comparison of monotonic rolling counters.\nstatic inline bool rollingLess32(uint32_t a, uint32_t b) {\n  constexpr uint32_t PositiveMax = uint32_t(-1)>>1;\n  return a-b > PositiveMax;\n}\nstatic inline uint32_t rollingMin32(uint32_t a, uint32_t b) {\n  constexpr uint32_t PositiveMax = uint32_t(-1)>>1;\n  return (b-a <= PositiveMax) ? a : b;\n}\n\n// Spin until its safe to increase comm->workFifoSent to desiredSent.\nstatic void waitWorkFifoAvailable(struct ncclComm* comm, uint32_t desiredSent) {\n  if (__builtin_expect(rollingLess32(comm->workFifoAckdMin + comm->workFifoDepth, desiredSent), false)) {\n    while (1) {\n      // We have to poll for notifications from device.\n      uint32_t* doneLive = comm->workFifoDone;\n      uint32_t ackd[MAXCHANNELS];\n      for (int c=0; c < MAXCHANNELS; c++) {\n        ackd[c] = __atomic_load_n(&doneLive[c], __ATOMIC_RELAXED);\n      }\n      // Compiler-only fence to prevent fusion of loops to encourage dense loads.\n      __atomic_signal_fence(__ATOMIC_SEQ_CST);\n\n      uint32_t ackdAll = comm->workFifoSent;\n      for (int c=0; c < MAXCHANNELS; c++) {\n        // ackdAll is min over all non-quiesced channels\n        if (ackd[c] != comm->channels[c].workFifoSent)\n          ackdAll = rollingMin32(ackdAll, ackd[c]);\n      }\n\n      // Compiler only fence to prevent fusion of loops to encourage dense stores.\n      __atomic_signal_fence(__ATOMIC_SEQ_CST);\n\n      for (int c=0; c < MAXCHANNELS; c++) {\n        // Advance counter on quiesced channels so they don't lag behind\n        // too far where they could get lost in 32-bit wraparound.\n        if (ackd[c] == comm->channels[c].workFifoSent) {\n          comm->channels[c].workFifoSent = ackdAll;\n          __atomic_store_n(&doneLive[c], ackdAll, __ATOMIC_RELAXED);\n        }\n      }\n      comm->workFifoAckdMin = ackdAll;\n\n      // See if that was enough.\n      if (!rollingLess32(comm->workFifoAckdMin + comm->workFifoDepth, desiredSent)) break;\n      sched_yield();\n    }\n  }\n}\n\nstatic ncclResult_t uploadWork(struct ncclComm* comm, struct ncclKernelPlan* plan) {\n  bool persistent = plan->persistent;\n  int channelUbound = plan->channelUbound;\n  int nWork = 0;\n  for (int c=0; c < channelUbound; c++) nWork += plan->channels[c].nWork;\n\n  struct ncclWork* workHeap;\n  if (!persistent) {\n    workHeap = comm->workFifoHeap;\n  } else {\n    workHeap = ncclMemoryStackAlloc<struct ncclWork>(&comm->memScoped, nWork);\n  }\n  uint32_t ixMask = persistent ? ~uint32_t(0) : comm->workFifoDepth-1;\n  uint32_t ixSent;\n  if (persistent) {\n    ixSent = 0;\n  } else {\n    ixSent = comm->workFifoSent;\n    // First work for a channel has to be at workHeap+blockIdx.x which means\n    // we cannot tolerate fifo wraparound. So round up to the wrap boundary\n    // if not doing so would incur crossing it.\n    if (((ixSent + plan->channelCount-1) & ixMask) < (ixSent & ixMask)) {\n      ixSent = (ixSent + ixMask) & ~ixMask;\n      // Need to update workFifoSent so waitWorkFifoAvailable() knows we've\n      // skipped those elements. Consider if all the channels report quiesced,\n      // this way the skipped slots will be considered consumed as well.\n      comm->workFifoSent = ixSent;\n    }\n    waitWorkFifoAvailable(comm, ixSent + nWork);\n  }\n  uint32_t ixHead = ixSent;\n  ixSent += plan->channelCount;\n  int channelsWithWork = 0; // number of channels below `c` with work structs.\n  for (int c=0; c < channelUbound; c++) {\n    struct ncclWorkList* q = ncclIntruQueueHead(&plan->channels[c].workQueue);\n    // Offset of first work equals number of channels below with work.\n    uint32_t ix = ixHead + channelsWithWork;\n    channelsWithWork += q != nullptr ? 1 : 0;\n    while (q != nullptr) {\n      if (q->next != nullptr) {\n        q->work.header.workNext = int32_t(ixSent & ixMask) - int32_t(ixHead & ixMask);\n      } else {\n        q->work.header.inFifo = !persistent ? 1 : 0;\n        // Tell channel to ack us back ix+1 indicating that all slots up to and\n        // including ix have been consumed.\n        q->work.header.doneAcks = ix+1;\n        comm->channels[c].workFifoSent = ix+1;\n      }\n      workHeap[ix & ixMask] = q->work; // C++ struct assignment\n      q = q->next;\n      if (q != nullptr) ix = ixSent++;\n    }\n  }\n\n  if (!persistent) {\n    comm->workFifoSent = ixSent;\n    if (comm->workFifoHeapGdrHandle != nullptr) wc_store_fence();\n    plan->workHead = &comm->devWorkFifoHeap[ixHead & ixMask];\n  } else {\n    NCCLCHECK(ncclCudaMalloc(&plan->workHead, nWork));\n    NCCLCHECK(ncclCudaMemcpy(plan->workHead, workHeap, nWork));\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t uploadProxyOps(struct ncclComm* comm, struct ncclKernelPlan* plan) {\n  uint64_t collOpCount = comm->sharedRes->collOpCount;\n  // Advance comm's collOpCount by number of colls in this plan.\n  comm->sharedRes->collOpCount += plan->collOpCount;\n\n  uint64_t p2pOpBump[MAXCHANNELS];\n  struct ncclProxyOp* heads[MAXCHANNELS];\n  uint64_t headIds[MAXCHANNELS];\n  int nHeads = 0;\n  for (int c=0; c < plan->channelUbound; c++) {\n    p2pOpBump[c] = 0;\n    heads[c] = ncclIntruQueueHead(&plan->channels[c].proxyOpQueue);\n    nHeads += (heads[c] != nullptr) ? 1 : 0;\n    headIds[c] = (heads[c] != nullptr) ? heads[c]->opCount : uint64_t(-1);\n  }\n\n  while (nHeads != 0) {\n    int minChan = -1;\n    uint64_t minId = uint64_t(-1);\n    // We store the heads[c]->opCount in headIds[c] specifically to remove indirect\n    // loads from this loop which speeds it up considerably.\n    for (int c=0; c < plan->channelUbound; c++) {\n      uint64_t id = headIds[c];\n      id = (id>>1 | id<<63); // Move tag bit to order collectives before p2p's\n      if (id < minId) { minChan = c; minId = id; }\n    }\n\n    struct ncclProxyOp* q = heads[minChan];\n    uint64_t oldId = headIds[minChan]; // same as q->opCount\n    // Advance heads[c]\n    heads[minChan] = q->enqNext;\n    if (q->enqNext == nullptr) nHeads -= 1;\n    headIds[minChan] = (q->enqNext != nullptr) ? q->enqNext->opCount : uint64_t(-1);\n\n    // Ignoring the bottom tag bit, opCount's are zero-based within plan so\n    // translate them to the tip of the comm's history.\n    if (oldId & 1) { // p2p\n      // opCount is monotonic increasing within a plan's channel so just\n      // remember last value to compute max.\n      p2pOpBump[minChan] = (oldId>>1) + 1; // +1 to ensure next plan doesn't collide\n      q->opCount = (comm->sharedRes->p2pOpCount[minChan]<<1) + oldId;\n    } else { // coll\n      q->opCount = (collOpCount<<1) + oldId;\n    }\n\n    q->kr = plan->kr;\n    NCCLCHECK(ncclProxySaveOp(comm, q, nullptr));\n    q->opCount = oldId; // Restore for next uploadProxyOps()\n    if (!plan->persistent) {\n      // Non-persistent kernels upload ops only once so can be free'd here.\n      ncclMemoryPoolFree(&comm->memPool_ncclProxyOp, q);\n    }\n  }\n\n  for (int c=0; c < plan->channelUbound; c++) {\n    // Erase proxyOpQueue since all ops were free'd back to mempool.\n    if (!plan->persistent) ncclIntruQueueConstruct(&plan->channels[c].proxyOpQueue);\n    // Advance channel's p2pOpCount by number of p2p's in this plan channel.\n    comm->sharedRes->p2pOpCount[c] += p2pOpBump[c];\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t hostStreamPlanTask(struct ncclComm* comm, struct ncclKernelPlan* plan) {\n  NCCLCHECK(uploadProxyOps(comm, plan));\n  NCCLCHECK(ncclProxyStart(comm));\n  if (!plan->persistent) {\n    // Notify main thread of our reclaiming. This will reclaim plan concurrently.\n    ncclIntruQueueMpscEnqueue(&comm->callbackQueue, &plan->reclaimer);\n  }\n  return ncclSuccess;\n}\n\nstatic void CUDART_CB hostStreamPlanCallback(void *plan_) {\n  NVTX3_FUNC_RANGE_IN(nccl_domain);\n  struct ncclKernelPlan* plan = (struct ncclKernelPlan*)plan_;\n  ncclResult_t result = hostStreamPlanTask(plan->comm, plan);\n  if (result != ncclSuccess) {\n    WARN(\"hostStreamPlanCallback() failed : %s\", ncclGetErrorString(result));\n  }\n}\n\nstatic ncclResult_t reclaimPlan(struct ncclComm* comm, struct ncclCommCallback* me) {\n  struct ncclKernelPlan* plan = (struct ncclKernelPlan*)me; // cast from first member `reclaim`\n  if (plan->persistent) {\n    comm->persistentRefs -= 1;\n    NCCLCHECK(ncclCudaFree(plan->workHead));\n    for (int c=0; c < plan->channelUbound; c++) {\n      struct ncclProxyOp* q = ncclIntruQueueHead(&plan->channels[c].proxyOpQueue);\n      while (q != nullptr) {\n        struct ncclProxyOp* q1 = q->enqNext;\n        ncclMemoryPoolFree(&comm->memPool_ncclProxyOp, q);\n        q = q1;\n      }\n    }\n    while (!ncclIntruQueueEmpty(&plan->ipcMemQueue)) {\n      struct ncclPointerList* q = ncclIntruQueueDequeue(&plan->ipcMemQueue);\n      CUDACHECKIGNORE(cudaIpcCloseMemHandle(q->ptr));\n      ncclMemoryPoolFree(&comm->memPool_ncclPointerList, q);\n    }\n    /* free mcHandle */\n    while (!ncclIntruQueueEmpty(&plan->nvlsMcHandleQueue)) {\n      struct ncclNvlsMcHandleList* obj = ncclIntruQueueDequeue(&plan->nvlsMcHandleQueue);\n      NCCLCHECK(ncclNvlsDeregBuffer(&obj->mcHandle, obj->ptr, obj->dev, obj->size));\n      INFO(NCCL_NVLS, \"rank %d - deregistered buffer %p on device %d, size %ld\", comm->rank, (void*)obj->ptr, obj->dev, obj->size);\n      ncclMemoryPoolFree(&comm->memPool_ncclNvlsHandleList, obj);\n    }\n    while (!ncclIntruQueueEmpty(&plan->collnetHandleQueue)) {\n      struct ncclCollnetHandleList* obj = ncclIntruQueueDequeue(&plan->collnetHandleQueue);\n      NCCLCHECK(ncclCollnetDeregBuffer(comm, obj->proxyconn, obj->collnetHandle));\n      INFO(NCCL_REG, \"rank %d - deregistered collnet buffer handle %p, size %ld, buff %p\", comm->rank, obj->collnetHandle, obj->size, obj->buffer);\n      ncclMemoryPoolFree(&comm->memPool_ncclCollnetHandleList, obj);\n    }\n  }\n  ncclMemoryPoolFree(&comm->memPool_ncclKernelPlan, plan);\n  return ncclSuccess;\n}\n\nstatic void persistentDestructor(void* plans_) {\n  struct ncclKernelPlan* plan = (struct ncclKernelPlan*)plans_;\n  struct ncclComm* comm = plan->comm;\n  while (plan != nullptr) {\n    struct ncclKernelPlan* next = plan->next;\n    ncclIntruQueueMpscEnqueue(&comm->callbackQueue, &plan->reclaimer);\n    plan = next;\n  }\n}\n\nncclResult_t ncclLaunchPrepare(struct ncclComm* comm) {\n  ncclResult_t result = ncclSuccess;\n  struct ncclTasks* tasks = &comm->tasks;\n  bool persistent = ncclCudaGraphValid(tasks->capturingGraph);\n  int nPlans = 0;\n\n  // Poll for callbacks sent to us from other threads. Typically these free\n  // resources from to our memory pools.\n  NCCLCHECK(ncclCommPollCallbacks(comm, /*waitSome=*/false));\n\n  // We already have one frame present which holds all of our tasks (which we\n  // are about to schedule). Now push an additional frame for allocating\n  // work structs (see appendWorkElem() variants all use scoped allocation).\n  ncclMemoryStackPush(&comm->memScoped);\n\n  if (tasks->nTasksColl + tasks->nTasksP2p != 0) {\n    do {\n      struct ncclKernelPlan* plan = ncclMemoryPoolAlloc<struct ncclKernelPlan>(&comm->memPool_ncclKernelPlan, &comm->memPermanent);\n      ncclIntruQueueEnqueue(&comm->planQueue, plan);\n      nPlans += 1;\n      plan->comm = comm;\n      plan->reclaimer.fn = reclaimPlan;\n      plan->persistent = persistent;\n\n      // Non-persistent kernels fill up at most half of our fifo per kernel.\n      int nWorkBudget = plan->persistent ? INT_MAX : comm->workFifoDepth/2;\n      int nWorkBudgetOld = nWorkBudget;\n\n      // Drain coll tasks first. This is essential since we partition tasks based\n      // on the work budget and p2p work isn't collective. If we were to drain p2p\n      // first, the place where we cut the kernel could vary by rank which would\n      // cause the \"shortest channel first\" channel picker to have divergent results.\n      if (tasks->nTasksColl != 0) {\n        NCCLCHECKGOTO(scheduleCollTasksToPlan(comm, plan, &nWorkBudget), result, failure);\n      }\n      // And only drain p2p tasks once colls are depleted.\n      if (tasks->nTasksColl == 0 && tasks->nTasksP2p != 0) {\n        NCCLCHECKGOTO(scheduleP2pTasksToPlan(comm, plan, &nWorkBudget), result, failure);\n      }\n      if (nWorkBudget == nWorkBudgetOld) {\n        // We weren't able to fit any tasks into our budget which means now we're\n        // stuck in an infinite loop. We defer this check until here, instead of\n        // doing it in comm init, to permit testing with insanely shallow queues\n        // for cases where that's expected to still work (e.g. few channels).\n        WARN(\"'NCCL_WORK_FIFO_DEPTH=%d' is too small. Minimum value is %d\", comm->workFifoDepth, 2*MAXCHANNELS);\n        result = ncclInvalidUsage;\n        goto failure;\n      }\n      finishPlan(plan);\n    } while (tasks->nTasksColl + tasks->nTasksP2p != 0);\n\n    struct ncclKernelPlan* planHead = ncclIntruQueueHead(&comm->planQueue);\n    comm->unlaunchedPlansHead = planHead;\n\n    // Semantically we want these dependencies for the kernels launched:\n    //   1. Launch host task on hostStream.\n    //   2. Launch kernel, depends on all of {deviceStream, hostStream, userStream[i]...}\n    //   3. {deviceStream, userStream[i]...} depend on kernel.\n    // We achieve this by:\n    //   1. userStream[0] waits on deviceStream\n    //   2. deviceStream waits on each of userStream[1...]\n    //   3. host task launch on hostStream\n    //   4. userStream[0] waits on hostStream\n    //   5. kernel launch on userStream[0]\n    //   6. deviceStream waits on userStream[0]\n    //   7. userStream[1...] each waits on deviceStream\n    // The two-level fan-in fan-out is because ncclStrongStreamWaitStream() requires\n    // at least one of the two streams to be strong-stream.\n    cudaStream_t launchStream = tasks->streams->stream;\n    NCCLCHECKGOTO(ncclStrongStreamAcquire(tasks->capturingGraph, &comm->sharedRes->deviceStream), result, failure);\n\n    // Create dependency for device stream on user streams. First from extra user\n    // streams to deviceStream. Then deviceStream to first user stream.\n    for (struct ncclCudaStreamList* l=tasks->streams->next; l != nullptr; l = l->next) {\n      NCCLCHECKGOTO(ncclStrongStreamWaitStream(tasks->capturingGraph, &comm->sharedRes->deviceStream, l->stream), result, failure);\n    }\n    NCCLCHECKGOTO(ncclStrongStreamWaitStream(tasks->capturingGraph, launchStream, &comm->sharedRes->deviceStream), result, failure);\n\n    if (persistent || comm->persistentRefs != 0 || ncclCudaLaunchBlocking) {\n      // We have to launch host tasks to push proxy args. We are careful to only\n      // do this if necessary since host tasks impose a high performance cost in CUDA.\n      bool acquired = false;\n      for (struct ncclKernelPlan* plan=planHead; plan != nullptr; plan = plan->next) {\n        if (plan->hasProxyOps) {\n          if (!acquired) {\n            acquired = true;\n            NCCLCHECKGOTO(ncclStrongStreamAcquire(tasks->capturingGraph, &comm->sharedRes->hostStream), result, failure);\n          }\n          NCCLCHECKGOTO(ncclStrongStreamLaunchHost(tasks->capturingGraph, &comm->sharedRes->hostStream, hostStreamPlanCallback, plan), result, failure);\n        }\n      }\n      if (acquired) {\n        // Make to-be-launched kernels dependent on just-launched host stream tasks.\n        NCCLCHECKGOTO(ncclStrongStreamWaitStream(tasks->capturingGraph, launchStream, &comm->sharedRes->hostStream), result, failure);\n        NCCLCHECKGOTO(ncclStrongStreamRelease(tasks->capturingGraph, &comm->sharedRes->hostStream), result, failure);\n      }\n    }\n\n    if (persistent) {\n      comm->persistentRefs += nPlans;\n      NCCLCHECKGOTO(ncclCudaGraphAddDestructor(tasks->capturingGraph, persistentDestructor, (void*)planHead), result, failure);\n    }\n  }\n\n  if (false) {\n  failure:\n    ncclMemoryStackPop(&comm->memScoped); // deallocate ncclWork's\n  }\n  return result;\n}\n\nncclResult_t ncclLaunchKernelBefore_NoUncapturedCuda(struct ncclComm* comm, struct ncclKernelPlan* plan) {\n  // This code is called after we've checked in to the intra-process barrier\n  // but before launching the kernel. We are not allowed to call CUDA unless the\n  // kernel launch is captured.\n  NCCLCHECK(uploadWork(comm, plan));\n  return ncclSuccess;\n}\n\n#if CUDART_VERSION >= 12000\n// NCCL uses the \"Remote\" Mem Sync domain by default\nNCCL_PARAM(MemSyncDomain, \"MEM_SYNC_DOMAIN\", cudaLaunchMemSyncDomainRemote);\n#endif\n\nncclResult_t ncclLaunchKernel(struct ncclComm* comm, struct ncclKernelPlan* plan) {\n  struct ncclTasks* tasks = &comm->tasks;\n  void *fn = plan->kernelFn;\n  cudaStream_t launchStream = tasks->streams->stream;\n  dim3 grid = {(unsigned)plan->channelCount, 1, 1};\n  dim3 block = {(unsigned)plan->threadPerBlock, 1, 1};\n  size_t smem = ncclShmemDynamicSize(comm->cudaArch);\n  ncclKernelRecord_t * p = allocKrRingSlot(comm->commHash, comm->launchedKernels, comm->rank, plan->workHead->header.funcIndex, plan->channelCount, plan->channelUbound, plan->channelMask);\n  plan->kr = p;\n  comm->launchedKernels++;\n#ifdef ENABLE_HANG_DEBUG\n  for (int i=0; i<plan->channelUbound; i++) {\n    if (plan->channelMask & (1ull<<i)) {\n      p->channels[i].collBytes = plan->channels[i].collBytes;\n    }\n  }\n  lttng_ust_tracelog(LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO, \"tasks field: workBytesTotal=%lld, usableChannels=%d, nTasksColl=%d, nTasksP2p=%d, collOpCount=%d\", tasks->workBytesTotal, tasks->usableChannels, tasks->nTasksColl, tasks->nTasksP2p, plan->collOpCount);\n  for (int i=0; i<plan->channelUbound; i++) {\n    if (plan->channelMask & (1ull<<i)) {\n       lttng_ust_tracelog(LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO, \"channel %d, nWork=%d, collBytes=%lld\", i, plan->channels[i].nWork, plan->channels[i].collBytes);\n    }\n  }\n\n  for (int i=0; i<tasks->p2pOrderSteps; i++) {\n    lttng_ust_tracelog(LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO, \"p2pSendOrder[%d]=%d, p2pRecvOrder[%d]=%d\", i, tasks->p2pSendOrder[i], i, tasks->p2pRecvOrder[i]);\n  }\n\n  int works = 0;\n  for (int j=0; j<plan->channelUbound; j++) {\n    if (plan->channelMask & (1ull<<j)) {\n      auto work = plan->workHead+works;\n      works++;\n      while (true) {\n        lttng_ust_tracelog(LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO, \"channel %d: work=%p\", j, work);\n        if (work->header.type == ncclWorkTypeP2p) {\n          for (int i=0; i<NCCL_MAX_WORK_ELEMENTS_P2P; i++) {\n            auto elem = &work->p2pElems[i];\n            if (elem->p2pType != ncclWorkP2pTypeUnused) {\n              lttng_ust_tracelog(LTTNG_UST_TRACEPOINT_LOGLEVEL_INFO, \"channel %d: p2pElems[%d], count=%lld, peer=%d, proto=%d\", j, i, int64_t(elem->countHi32)<<32 | elem->countLo32, elem->peer, elem->proto);\n            }\n          }\n        }\n        if (work->header.isLast) break;\n        int workIxNext = work->header.workNext;\n        work = plan->workHead+workIxNext;\n      }\n    }\n  }\n#endif\n\n  void *args[4] = {&comm->devComm, &plan->channelMask, &plan->workHead, &p};\n\n  #if CUDART_VERSION >= 11080\n  int driverVersion;\n  NCCLCHECK(ncclCudaDriverVersion(&driverVersion));\n  if (driverVersion >= 11080) {\n    int compCap = comm->compCap;\n    unsigned int clusterSize = (compCap == 90) ? comm->config.cgaClusterSize : 0;\n\n    cudaLaunchConfig_t launchConfig = {0};\n    cudaLaunchAttribute launchAttrs[3];\n    int attrs = 0;\n    /* Cooperative Group Array (CGA)\n     * On sm90 and later we have an extra level of hierarchy where we\n     * can group together several blocks within the Grid, called\n     * Thread Block Clusters.\n     * Clusters enable multiple thread blocks running concurrently\n     * across multiple SMs to synchronize and collaboratively fetch\n     * and exchange data. A cluster of blocks are guaranteed to be\n     * concurrently scheduled onto a group of SMs.\n     * The maximum value is 8 and it must be divisible into the grid dimensions\n     */\n    if (clusterSize) {\n      // Grid dimension must be divisible by clusterSize\n      if (grid.x % clusterSize) clusterSize = 1;\n      launchAttrs[attrs].id = cudaLaunchAttributeClusterDimension;\n      launchAttrs[attrs++].val.clusterDim = {clusterSize, 1, 1};\n      launchAttrs[attrs].id = cudaLaunchAttributeClusterSchedulingPolicyPreference;\n      launchAttrs[attrs++].val.clusterSchedulingPolicyPreference = cudaClusterSchedulingPolicySpread;\n    }\n    #if CUDART_VERSION >= 12000\n    if (compCap >= 90 && driverVersion >= 12000) {\n      // Set the NCCL Mem Sync domain on CUDA 12.0 and later (sm90)\n      launchAttrs[attrs].id = cudaLaunchAttributeMemSyncDomain;\n      launchAttrs[attrs++].val.memSyncDomain = (cudaLaunchMemSyncDomain) ncclParamMemSyncDomain();\n    }\n    #endif\n    launchConfig.gridDim = grid;\n    launchConfig.blockDim = block;\n    launchConfig.dynamicSmemBytes = smem;\n    launchConfig.attrs = launchAttrs;\n    launchConfig.numAttrs = attrs;\n    launchConfig.stream = launchStream;\n\n    CUDACHECK(cudaLaunchKernelExC(&launchConfig, fn, args));\n    return ncclSuccess;\n  }\n  #endif\n  // Standard kernel launch\n  CUDACHECK(cudaLaunchKernel(fn, grid, block, args, smem, launchStream));\n  return ncclSuccess;\n}\n\nncclResult_t ncclLaunchKernelAfter_NoCuda(struct ncclComm* comm, struct ncclKernelPlan* plan) {\n  if (!(plan->persistent || comm->persistentRefs != 0 || ncclCudaLaunchBlocking)) {\n    // We are not using the host stream for proxy ops and reclaimation submission.\n    NCCLCHECK(hostStreamPlanTask(comm, plan));\n  } else {\n    // We are using the host stream for proxy ops and reclaimation submission.\n    // Only plans with proxy ops have a callback pushed by ncclLaunchPrepare.\n    // Since non-persistent plans also require reclaimation, we have to do it\n    // here.\n    if (!plan->persistent && !plan->hasProxyOps) {\n      ncclIntruQueueMpscEnqueue(&comm->callbackQueue, &plan->reclaimer);\n    }\n  }\n  return ncclSuccess;\n}\n\nncclResult_t ncclLaunchFinish(struct ncclComm* comm) {\n  ncclResult_t result = ncclSuccess;\n  struct ncclTasks* tasks = &comm->tasks;\n  tasks->workBytesTotal = 0; // Just in case subtraction during scheduleCollTasksToPlan() doesn't get to 0\n\n  // Deallocate ncclWork's. This frame exists so long as ncclLaunchPrepare\n  // succeeded, and if it ncclLaunchPrepare didn't succeed we wouldn't be here.\n  ncclMemoryStackPop(&comm->memScoped);\n\n  if (!ncclIntruQueueEmpty(&comm->planQueue)) {\n    // Reset queue to empty without destroying plans since those will be sent\n    // back to us for reclaiming via callbackQueue.\n    ncclIntruQueueConstruct(&comm->planQueue);\n    cudaStream_t launchStream = tasks->streams->stream; // First user stream gets launch\n    // Create dependency for deviceStream on launchStream. We know that deviceStream\n    // hasn't been modified since launchStream waited on it (in ncclLaunchPrepare),\n    // so we can say that launchStream subsumes it.\n    NCCLCHECKGOTO(ncclStrongStreamWaitStream(tasks->capturingGraph, &comm->sharedRes->deviceStream, launchStream, /*b_subsumes_a=*/true), result, resume1);\n  resume1:\n    // Create dependency for other user streams (skip launch stream) on deviceStream.\n    // Again, the user streams haven't been touched since deviceStream waited on them\n    // so we can say they are subsumed by deviceStream.\n    struct ncclCudaStreamList* sl = tasks->streams->next;\n    tasks->streams = nullptr; // Reset comm->tasks.streams to empty.\n    while (sl != nullptr) {\n      NCCLCHECKGOTO(ncclStrongStreamWaitStream(tasks->capturingGraph, sl->stream, &comm->sharedRes->deviceStream, /*b_subsumes_a=*/true), result, resume2);\n    resume2:\n      sl = sl->next;\n    }\n    // Release device stream as acquired in ncclLaunchPrepare()\n    NCCLCHECKGOTO(ncclStrongStreamRelease(tasks->capturingGraph, &comm->sharedRes->deviceStream), result, resume3);\n  resume3:;\n  }\n  return result;\n}\n\n/*****************************************************************************/\n/* Enqueueing system : computation of kernel and proxy operations parameters */\n/*****************************************************************************/\n\nstatic inline ncclResult_t getCollNetSupport(struct ncclInfo* info, int* collNetSupport) {\n  // Translate ncclAvg and PreMulSum\n  ncclRedOp_t netOp = info->op == ncclAvg || info->op >= ncclNumOps ? ncclSum : info->op;\n  *collNetSupport = info->comm->collNetSupport;\n  switch (info->coll) {\n  case ncclFuncAllReduce:\n  case ncclFuncReduce:\n  case ncclFuncReduceScatter:\n    *collNetSupport &= info->comm->collNetSupportMatrix[netOp][info->datatype];\n    break;\n  default:\n    break;\n  }\n  return ncclSuccess;\n}\n\n// numPipeOps: number of pipelined ops. Can be greater than 1 in aggregation mode. Used to adjust latency.\nstatic ncclResult_t topoGetAlgoInfo(struct ncclInfo* collInfo, int collNetSupport, int nvlsSupport, int numPipeOps) {\n  struct ncclComm* comm = collInfo->comm;\n  if (comm->nRanks == 1) {\n    collInfo->algorithm = NCCL_ALGO_RING;\n    collInfo->protocol = NCCL_PROTO_SIMPLE;\n  }\n  else if (collInfo->algorithm == NCCL_ALGO_UNDEF || collInfo->protocol == NCCL_PROTO_UNDEF) {\n    float minTime = 3600000000.0; // Hopefully no operation will take an hour to complete.\n    float backupMinTime = 3600000000.0;\n    bool backup = false;\n    int backupAlgo = NCCL_ALGO_UNDEF; // back up algo and proto if no algo/proto is picked up.\n    int backupProto = NCCL_PROTO_UNDEF;\n    // Find algorithm / protocol.\n    collInfo->algorithm = -1;\n    collInfo->protocol = -1;\n    int nAlgos = NCCL_NUM_ALGORITHMS;\n    for (int a=0; a<nAlgos; a++) {\n      if ((a == NCCL_ALGO_COLLNET_DIRECT || a == NCCL_ALGO_COLLNET_CHAIN) && collNetSupport != 1) continue;\n      if ((a == NCCL_ALGO_NVLS || a == NCCL_ALGO_NVLS_TREE) && nvlsSupport != 1) continue;\n      if (a == NCCL_ALGO_NVLS && collNetSupport != 1 && comm->nNodes > 1) continue;\n      /* now we only support single-node NVLS allgather and reducescatter */\n      if (a == NCCL_ALGO_NVLS && (collInfo->coll == ncclFuncAllGather || collInfo->coll == ncclFuncReduceScatter) && comm->nNodes > 1) continue;\n\n      for (int p=0; p<NCCL_NUM_PROTOCOLS; p++) {\n        float time;\n        NCCLCHECK(ncclTopoGetAlgoTime(collInfo, a, p, numPipeOps, &time, &backup));\n        if (!backup) {\n          if (time >= 0 && time < minTime) {\n            collInfo->algorithm = a;\n            collInfo->protocol = p;\n            minTime = time;\n          }\n        } else {\n          if (time >= 0 && time < backupMinTime) {\n            backupAlgo = a;\n            backupProto = p;\n            backupMinTime = time;\n          }\n        }\n      }\n    }\n\n    if (collInfo->algorithm == NCCL_ALGO_UNDEF || collInfo->protocol == NCCL_PROTO_UNDEF) {\n      if (backupAlgo == NCCL_ALGO_UNDEF || backupProto == NCCL_PROTO_UNDEF) {\n        WARN(\"Error : no algorithm/protocol available\");\n        return ncclInternalError;\n      }\n      collInfo->algorithm = backupAlgo;\n      collInfo->protocol = backupProto;\n    }\n    if (comm->rank == 0) INFO(NCCL_TUNING, \"%ld Bytes -> Algo %d proto %d time %f\", collInfo->nBytes, collInfo->algorithm, collInfo->protocol, minTime);\n    TRACE(NCCL_COLL, \"%ld Bytes -> Algo %d proto %d time %f\", collInfo->nBytes, collInfo->algorithm, collInfo->protocol, minTime);\n  }\n\n  return ncclSuccess;\n}\n\n// Use the default topo-based tuner if tuner plugin is not successful.\n// Call the plugin first. Let it set algo+proto, and/or nChannels.\n// Then, topoGetAlgoInfo will set algo/proto if not set, then nChannels and nThreads based on algo/proto.\n// Finally, nChannels will be overriden by the plugin setting.\nstatic ncclResult_t getTunerInfo(struct ncclInfo* collInfo, int collNetSupport, int nvlsSupport, int numPipeOps) {\n  collInfo->algorithm = NCCL_ALGO_UNDEF;\n  collInfo->protocol = NCCL_PROTO_UNDEF;\n  collInfo->nChannels = 0;\n  if (collInfo->comm->tuner != NULL) {\n    NCCLCHECK(collInfo->comm->tuner->getCollInfo(\n          collInfo->comm->tunerContext, collInfo->coll, collInfo->nBytes,\n          collNetSupport, nvlsSupport, numPipeOps,\n          &collInfo->algorithm, &collInfo->protocol, &collInfo->nChannels));\n  }\n\n  /* We only honor nChannels decision when user sets the nChannels by tuner plugin or the coll picks\n   * collnet algorithm. For other cases, we need to decide nChannels based on the maxBytesPerChannel */\n  if (collInfo->nChannels != 0)\n    collInfo->userTuned = true;\n  else\n    collInfo->userTuned = false;\n  return ncclSuccess;\n}\n\n/* Compute nChannels and nThreads. */\nstatic ncclResult_t getChannnelThreadInfo(struct ncclInfo* collInfo) {\n  struct ncclComm *comm = collInfo->comm;\n  int nc = comm->collChannels;\n  int nt = comm->maxThreads[collInfo->algorithm][collInfo->protocol];\n  int threadThreshold = comm->threadThresholds[collInfo->algorithm][collInfo->protocol];\n\n  if (collInfo->nChannels == 0) {\n    /* not preset by users */\n    if (collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT) {\n      // CollNet channel tuning\n      int ncSwitch = 16;\n      bool flag = true;\n      while (ncSwitch >= 1 && flag) {\n        while ((flag = collInfo->nBytes < nc * nt * collInfo->comm->channels[0].collnetDirect.nHeads * threadThreshold) && nc > ncSwitch) {\n          if (nc == ncSwitch + ncSwitch / 2) threadThreshold /= 2;\n          nc--;\n        }\n        ncSwitch /= 2;\n      }\n    } else if (collInfo->algorithm == NCCL_ALGO_NVLS || collInfo->algorithm == NCCL_ALGO_NVLS_TREE) {\n      // NVLS should not need more than 16 channels to get peak BW.\n      nc = comm->nvlsChannels;\n    } else {\n      // Ring/Tree channel tuning\n      while (collInfo->nBytes < nc * nt * threadThreshold) {\n        if (nc >= 2) nc--;\n        else break;\n      }\n    }\n    collInfo->nChannels = nc;\n  } else {\n    nc = collInfo->nChannels;\n  }\n\n  if (collInfo->nThreads == 0) {\n    if (collInfo->algorithm != NCCL_ALGO_NVLS && collInfo->algorithm != NCCL_ALGO_NVLS_TREE &&\n      collInfo->algorithm != NCCL_ALGO_COLLNET_DIRECT) {\n      while (collInfo->nBytes < nc * nt * threadThreshold) {\n        if (nt % 128 == 0) nt /= 2;\n        else break;\n      }\n    }\n\n    if (collInfo->protocol == NCCL_PROTO_SIMPLE) {\n      if (collInfo->algorithm == NCCL_ALGO_RING) nt += WARP_SIZE; // Extra warp for sync\n      // More threads or sync warps needed due to split thread model\n      if (collInfo->algorithm == NCCL_ALGO_TREE) nt += 4*WARP_SIZE;\n    }\n    nt = nt / WARP_SIZE < 3 ? 3 * WARP_SIZE : nt;\n    collInfo->nThreads = nt;\n  }\n\n  return ncclSuccess;\n}\n\nstatic ncclResult_t getPatternInfo(struct ncclInfo* collInfo) {\n  switch (collInfo->coll) {\n    case ncclFuncBroadcast:\n      collInfo->pattern = collInfo->algorithm == NCCL_ALGO_TREE ? ncclPatternTreeDown : ncclPatternPipelineFrom; break;\n    case ncclFuncReduce:\n      collInfo->pattern = collInfo->algorithm == NCCL_ALGO_TREE ? ncclPatternTreeUp : ncclPatternPipelineTo; break;\n    case ncclFuncReduceScatter:\n    case ncclFuncAllGather:\n      collInfo->pattern =\n        collInfo->algorithm == NCCL_ALGO_NVLS ? ncclPatternNvls :\n        collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT ? ncclPatternCollnetDirect :\n        ncclPatternRing; break;\n    case ncclFuncAllReduce:\n      collInfo->pattern =\n        collInfo->algorithm == NCCL_ALGO_NVLS ? ncclPatternNvls :\n        collInfo->algorithm == NCCL_ALGO_NVLS_TREE ? ncclPatternNvlsTree :\n        collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT ? ncclPatternCollnetDirect :\n        collInfo->algorithm == NCCL_ALGO_COLLNET_CHAIN ? ncclPatternCollnetChain :\n        collInfo->algorithm == NCCL_ALGO_TREE ? ncclPatternTreeUpDown :\n        ncclPatternRingTwice; break;\n    default:\n      WARN(\"Unknown pattern for collective %d algorithm %d\", collInfo->coll, collInfo->algorithm);\n      return ncclInternalError;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t computeCollWorkFunc(struct ncclInfo* collInfo) {\n  collInfo->workFuncIndex = ncclDevFuncId(collInfo->coll, collInfo->opFull.op, collInfo->datatype, collInfo->algorithm, collInfo->protocol);\n  return ncclSuccess;\n}\n\nstatic ncclResult_t initCollWorkElem(struct ncclInfo* collInfo, struct ncclWorkElem* work) {\n  work->sendbuff = collInfo->sendbuff;\n  work->recvbuff = collInfo->recvbuff;\n  work->root = collInfo->root;\n  work->count = collInfo->count;\n  work->nWarps = collInfo->nThreads / WARP_SIZE;\n  work->redOpArg = collInfo->opFull.scalarArg;\n  work->redOpArgIsPtr = collInfo->opFull.scalarArgIsPtr;\n  work->chunkCount = collInfo->chunkCount;\n  work->regUsed = 0;\n  work->isUsed = 1;\n\n  if (collInfo->comm->nNodes == 1)\n    work->oneNode = 1;\n  else\n    work->oneNode = 0;\n  if (collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT) {\n    // Set direct direction for broadcast-gather (read or write)\n    work->direct = (collInfo->nBytes / collInfo->nChannels <= 1024 * 1024) ? NCCL_DIRECT_WRITE : NCCL_DIRECT_READ;\n  } else {\n    work->direct = 0;\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t setCollWorkElem(uint64_t workCount, uint64_t workOffset, size_t lastChunkCount, struct ncclWorkElem* work) {\n  work->workCount = workCount;\n  work->workOffset = workOffset;\n  work->lastChunkCount = lastChunkCount;\n  return ncclSuccess;\n}\n\nstatic ncclResult_t initCollWorkElemReg(struct ncclComm* comm, struct ncclWorkElem* work, struct ncclChannel* channel, ncclRegBufferType regBufType, void* regBufSend[], void* regBufRecv[], struct ncclWorkElemReg* workElemReg) {\n  if (regBufType == NCCL_IPC_REG_BUFFER) {\n    workElemReg->elem = *work;\n    workElemReg->elem.regUsed = NCCL_IPC_REG_BUFFER;\n    for (int i = 0; i < NCCL_MAX_DIRECT_ARITY; i++) {\n      int peer = channel->collnetDirect.down[i];\n      if (peer == -1) break;\n      int j = comm->rankToLocalRank[peer]; // Get intra-node slot\n      workElemReg->dnInputs[i] = regBufSend[j]; // Input buffer of leaf peer\n      workElemReg->dnOutputs[i] = regBufRecv[j]; // Output buffer of leaf peer\n    }\n    for (int i = 0; i < NCCL_MAX_DIRECT_ARITY; i++) {\n      int peer = channel->collnetDirect.up[i];\n      if (peer == -1) break;\n      int j = comm->rankToLocalRank[peer];\n      // Output buffer of root peer\n      workElemReg->upOutputs[i] = regBufRecv[j];\n    }\n  } else if (regBufType == NCCL_NVLS_REG_BUFFER) {\n    workElemReg->elem = *work;\n    workElemReg->elem.regUsed = NCCL_NVLS_REG_BUFFER;\n    /* NVLS only has one send and recv buffer registered */\n    workElemReg->dnInputs[0] = regBufSend[0];\n    workElemReg->dnOutputs[0] = regBufRecv[0];\n  } else if (regBufType == NCCL_COLLNET_REG_BUFFER) {\n    workElemReg->elem = *work;\n    workElemReg->elem.regUsed = NCCL_COLLNET_REG_BUFFER;\n  } else {\n    /* impossible value */\n    WARN(\"Invalid regBufType %d\\n\", regBufType);\n    return ncclInvalidArgument;\n  }\n  return ncclSuccess;\n}\n\nNCCL_PARAM(NvlsTreeMaxChunkSize, \"NVLSTREE_MAX_CHUNKSIZE\", -2);\n\nstatic ncclResult_t computeCollChunkInfo(struct ncclInfo* collInfo, size_t nBytes, int nChannels) {\n  int stepSize = collInfo->comm->buffSizes[collInfo->protocol] / NCCL_STEPS;\n  int chunkSteps = (collInfo->protocol == NCCL_PROTO_SIMPLE && collInfo->algorithm == NCCL_ALGO_RING) ? collInfo->chunkSteps : 1;\n  int sliceSteps = (collInfo->protocol == NCCL_PROTO_SIMPLE && collInfo->algorithm == NCCL_ALGO_RING) ? collInfo->sliceSteps : 1;\n  int chunkSize = stepSize * chunkSteps;\n\n  if (collInfo->protocol == NCCL_PROTO_LL) chunkSize /= 2;\n  if (collInfo->protocol == NCCL_PROTO_LL128) chunkSize = (chunkSize / NCCL_LL128_LINEELEMS) * NCCL_LL128_DATAELEMS;\n\n  if (collInfo->algorithm == NCCL_ALGO_COLLNET_DIRECT) {\n    // Optimize chunkSize / nSteps\n    while (nBytes / (nChannels * collInfo->comm->channels[0].collnetDirect.nHeads * chunkSize) < collInfo->comm->channels[0].collnetDirect.depth * 64 && chunkSize > 131072) chunkSize /= 2;\n    while (nBytes / (nChannels * collInfo->comm->channels[0].collnetDirect.nHeads * chunkSize) < collInfo->comm->channels[0].collnetDirect.depth * 8 && chunkSize > 65536) chunkSize /= 2;\n    while (nBytes / (nChannels * collInfo->comm->channels[0].collnetDirect.nHeads * chunkSize) < collInfo->comm->channels[0].collnetDirect.depth * 8 && chunkSize > 32768) chunkSize /= 2;\n  } else if (collInfo->algorithm == NCCL_ALGO_COLLNET_CHAIN) {\n    stepSize = collInfo->comm->buffSizes[NCCL_PROTO_SIMPLE] / NCCL_STEPS;\n    chunkSize = std::min(256 * 1024, stepSize * chunkSteps);\n    while (nBytes / (nChannels * chunkSize) < collInfo->comm->channels[0].collnetChain.depth * 64 && chunkSize > 131072) chunkSize /= 2;\n    while (nBytes / (nChannels * chunkSize) < collInfo->comm->channels[0].collnetChain.depth * 8 && chunkSize > 65536) chunkSize /= 2;\n    while (nBytes / (nChannels * chunkSize) < collInfo->comm->channels[0].collnetChain.depth && chunkSize > 32768) chunkSize /= 2;\n  } else if (collInfo->algorithm == NCCL_ALGO_NVLS) {\n    int maxChunkSize = collInfo->comm->nvlsChunkSize;\n    if (collInfo->comm->nNodes > 1 && collInfo->comm->bandwidths[ncclFuncAllReduce][NCCL_ALGO_NVLS][NCCL_PROTO_SIMPLE] < 150) maxChunkSize = 32768;\n    if (chunkSize > maxChunkSize) chunkSize = maxChunkSize;\n    // Use uint64_t so that concurrentOps*chunkSize*X does not overflow\n    uint64_t concurrentOps = nChannels * collInfo->comm->channels[0].nvls.nHeads;\n    if ((nBytes < (64 * (concurrentOps * chunkSize))) && (chunkSize > 65536)) chunkSize = 65536;\n    if ((nBytes < (8 * (concurrentOps * chunkSize))) && (chunkSize > 32768)) chunkSize = 32768;\n    if ((nBytes < (2 * (concurrentOps * chunkSize))) && (chunkSize > 16384)) chunkSize = 16384;\n  } else if (collInfo->algorithm == NCCL_ALGO_NVLS_TREE) {\n    // Use uint64_t so that concurrentOps*chunkSize*X does not overflow\n    uint64_t concurrentOps = nChannels * collInfo->comm->channels[0].nvls.nHeads;\n    chunkSize = collInfo->comm->nvlsChunkSize;\n    int maxChunkSize = (int)ncclParamNvlsTreeMaxChunkSize();\n    if (maxChunkSize == -2) maxChunkSize = collInfo->comm->nNodes >= 4 ? 65536 : chunkSize;\n    chunkSize = std::min(chunkSize, maxChunkSize);\n    if ((nBytes < (32 * (concurrentOps * chunkSize))) && (chunkSize > 262144)) chunkSize = 262144;\n    if ((nBytes < (16 * (concurrentOps * chunkSize))) && (chunkSize > 131072)) chunkSize = 131072;\n    if ((nBytes < (4 * (concurrentOps * chunkSize))) && (chunkSize > 65536)) chunkSize = 65536;\n    if ((nBytes < (1 * (concurrentOps * chunkSize))) && (chunkSize > 32768)) chunkSize = 32768;\n  } else if (collInfo->algorithm == NCCL_ALGO_TREE && collInfo->protocol == NCCL_PROTO_LL128) {\n    int nNodes = collInfo->comm->nNodes;\n    float ppn = collInfo->comm->nRanks / (float)nNodes;\n    float nstepsLL128 = 1+log2i(nNodes) + 0.1*ppn;\n    while (nBytes / (nChannels*chunkSize) < nstepsLL128*64/ppn && chunkSize > 131072) chunkSize /= 2;\n    while (nBytes / (nChannels*chunkSize) < nstepsLL128*16/ppn && chunkSize > 32768) chunkSize /= 2;\n  }\n\n  collInfo->chunkSize = chunkSize;\n  collInfo->chunkCount = chunkSize / ncclTypeSize(collInfo->datatype);\n  collInfo->chunkSteps = chunkSteps;\n  collInfo->sliceSteps = sliceSteps;\n  collInfo->stepSize = stepSize;\n  return ncclSuccess;\n}\n\nstatic ncclResult_t initCollProxyOp(struct ncclInfo* collInfo, int channelId, uint64_t opCount, uint32_t nsteps, struct ncclProxyOp* proxyOp) {\n  proxyOp->nsteps = nsteps;\n  proxyOp->sliceSteps = collInfo->sliceSteps;\n  proxyOp->chunkSteps = collInfo->chunkSteps;\n  proxyOp->chunkSize = collInfo->chunkSize;\n  proxyOp->protocol = collInfo->protocol;\n  proxyOp->dtype = collInfo->datatype;\n  // Network sees avg as sum\n  proxyOp->redOp = collInfo->opFull.op == ncclDevPreMulSum || collInfo->opFull.op == ncclDevSumPostDiv ? ncclSum : collInfo->opFull.proxyOp;\n  proxyOp->pattern = collInfo->pattern;\n  proxyOp->coll = collInfo->coll;\n  proxyOp->root = collInfo->root;\n  // This is used by P2P to reduce the receive buffer size. We don't use it in collectives\n  // because some protocols need to transmit more than the total size, plus they sometimes\n  // round up\n  proxyOp->nbytes = collInfo->stepSize * proxyOp->sliceSteps;\n  if (collInfo->regBufType == NCCL_COLLNET_REG_BUFFER) {\n    proxyOp->reg = 1;\n    proxyOp->nsteps = DIVUP(collInfo->nBytes, NCCL_MAX_COLLNET_SIZE);\n    proxyOp->sendMhandle = collInfo->sendMhandle;\n    proxyOp->recvMhandle = collInfo->recvMhandle;\n    proxyOp->sendbuff = (uint8_t*)collInfo->sendbuff;\n    proxyOp->recvbuff = (uint8_t*)collInfo->recvbuff;\n    proxyOp->nbytes = collInfo->nBytes;\n  } else {\n    proxyOp->reg = 0;\n  }\n\n  proxyOp->channelId = channelId;\n  proxyOp->opCount = opCount;\n\n  if (collInfo->pattern == ncclPatternCollnetDirect) {\n    proxyOp->specifics.collnetDirect.nNodes = collInfo->comm->nNodes;\n    proxyOp->specifics.collnetDirect.node = collInfo->comm->node;\n    if (collInfo->coll == ncclFuncAllGather || collInfo->coll == ncclFuncReduceScatter) {\n      proxyOp->specifics.collnetDirect.sizePerRank = collInfo->count * ncclTypeSize(collInfo->datatype);\n    }\n  }\n  return ncclSuccess;\n}\n\nstatic ncclResult_t hostToDevRedOp(\n    ncclDevRedOpFull *opFull, ncclRedOp_t op, ncclDataType_t datatype, ncclComm *comm\n  ) {\n  union {\n    int8_t   i8; uint8_t   u8;\n    int32_t i32; uint32_t u32;\n    int64_t i64; uint64_t u64;\n    half f16; float f32; double f64;\n    #if defined(__CUDA_BF16_TYPES_EXIST__)\n      __nv_bfloat16 bf16;\n    #endif\n    void *ptr;\n  };\n  u64 = 0;\n  opFull->scalarArgIsPtr = false;\n  opFull->proxyOp = op;\n\n  int nbits = 8*ncclTypeSize(datatype);\n  uint64_t allBits = uint64_t(-1)>>(64-nbits);\n  uint64_t signBit = allBits^(allBits>>1);\n\n  switch (int(op)) {\n  case ncclSum:  opFull->op = ncclDevSum;  break;\n  case ncclProd: opFull->op = ncclDevProd; break;\n  case ncclMin:\n  case ncclMax:\n    opFull->op = ncclDevMinMax;\n    opFull->scalarArg = 0;\n    // The xormask used by ncclFuncMinMax<[u]int> is the XOR of the sign bit\n    // for signed (opposed to unsigned) types and all the bits for max (opposed to min).\n    if (datatype==ncclInt8 || datatype==ncclInt32 || datatype==ncclInt64) {\n      opFull->scalarArg ^= signBit;\n    }\n    opFull->scalarArg ^= (op == ncclMax) ? allBits : 0;\n    break;\n  case ncclAvg:\n    switch ((int)datatype) {\n    case ncclInt8:  case ncclInt32:  case ncclInt64:\n    case ncclUint8: case ncclUint32: case ncclUint64:\n      opFull->op = ncclDevSumPostDiv;\n      u64 = comm->nRanks;\n      break;\n    case ncclFloat16:\n      opFull->op = ncclDevPreMulSum;\n      f16 = __float2half(float(1.0/comm->nRanks)); // __double2half not supported pre CUDA 11.x\n      break;\n    #if defined(__CUDA_BF16_TYPES_EXIST__)\n    case ncclBfloat16:\n      opFull->op = ncclDevPreMulSum;\n      bf16 = __float2bfloat16(float(1.0/comm->nRanks));\n      break;\n    #endif\n    case ncclFloat32:\n      opFull->op = ncclDevPreMulSum;\n      f32 = float(1.0/comm->nRanks);\n      break;\n    case ncclFloat64:\n      opFull->op = ncclDevPreMulSum;\n      f64 = 1.0/comm->nRanks;\n      break;\n    }\n    opFull->scalarArgIsPtr = false;\n    opFull->scalarArg = u64;\n    break;\n  default: // user created\n    int ix = int(ncclUserRedOpMangle(comm, op)) - int(ncclNumOps);\n    ncclUserRedOp *user = &comm->userRedOps[ix];\n    if (datatype != user->datatype) {\n      WARN(\"Data type supplied to user-created ncclRedOp_t does not match type \"\n           \"given to reduction operation\");\n      return ncclInvalidArgument;\n    }\n    *opFull = user->opFull;\n    break;\n  }\n  return ncclSuccess;\n}\n\nstatic int collCmp(struct ncclInfo *a, struct ncclInfo *b) {\n  if (a->coll > b->coll)\n    return 1;\n  else if (a->coll == b->coll && a->datatype > b->datatype)\n    return 1;\n  else if (a->coll == b->coll && a->datatype == b->datatype && a->opFull.op > b->opFull.op)\n    return 1;\n  else if (a->coll == b->coll && a->datatype == b->datatype && a->opFull.op == b->opFull.op && a->count > b->count)\n    return 1;\n  else\n    return -1;\n}\n\n// Converts `info` to a task and adds it to `comm->tasks`. The exception is with\n// single rank communicators, collectives are issued as `ncclMemcpyAsync`s and\n// thus don't need a task.\nstatic ncclResult_t taskAppend(struct ncclComm* comm, struct ncclInfo* info) {\n  ncclTasks *tasks = &comm->tasks;\n\n  if (info->count == 0 && info->coll != ncclFuncSend && info->coll != ncclFuncRecv) return ncclSuccess;\n  if (info->coll == ncclFuncSend || info->coll == ncclFuncRecv) {\n    int peer = info->root;\n    ssize_t nBytes = info->count*ncclTypeSize(info->datatype);\n    bool isSendNotRecv = info->coll == ncclFuncSend;\n\n    // Must be in thread local group before tasks can be alloc'd in `comm->memScoped`.\n    ncclGroupCommJoin(info->comm);\n    struct ncclTaskP2p* p2p = ncclMemoryStackAlloc<struct ncclTaskP2p>(&comm->memScoped);\n    p2p->buff = (void*)info->recvbuff;\n    p2p->bytes = nBytes;\n    p2p->chunk = 0;\n    ncclIntruQueueEnqueue(\n      isSendNotRecv ? &tasks->peers[peer].sendQueue : &tasks->peers[peer].recvQueue,\n      p2p);\n    tasks->nTasksP2p += 1;\n\n    // Mark channels that need pre-connect\n    if (comm->rank != peer) {\n      int channelBaseId;\n      NCCLCHECK(ncclChannelComputeBase(comm, peer, info->coll, &channelBaseId));\n      if (!(isSendNotRecv ? tasks->peers[peer].sendSeen : tasks->peers[peer].recvSeen)) {\n        (isSendNotRecv ? tasks->peers[peer].sendSeen : tasks->peers[peer].recvSeen) = true;\n        for (int c=0; c < comm->p2pnChannelsPerPeer; c++) {\n          int channelId;\n          NCCLCHECK(ncclChannelComputeFromBase(comm, channelBaseId, c, &channelId));\n          if (isSendNotRecv) {\n            if (comm->channels[channelId].peers[peer]->send[1].connected == 0) { // P2P uses only 1 connector\n              comm->connectSend[peer] |= (1UL<<channelId);\n              ncclGroupCommPreconnect(comm);\n            }\n          } else {\n            if (comm->channels[channelId].peers[peer]->recv[1].connected == 0) { // P2P uses only 1 connector\n              comm->connectRecv[peer] |= (1UL<<channelId);\n              ncclGroupCommPreconnect(comm);\n            }\n          }\n        }\n      }\n    }\n  } else {\n    // Copy reduction op state from op handle into info struct here since the\n    // op handle may be destroyed before ncclGroupEnd().\n    NCCLCHECK(hostToDevRedOp(&info->opFull, info->op, info->datatype, comm));\n\n    if (comm->nRanks == 1) {\n      NCCLCHECK(ncclLaunchOneRank(info->recvbuff, info->sendbuff, info->count, info->opFull, info->datatype, info->stream));\n      return ncclSuccess;\n    } else {\n      // Must be in thread local group before tasks can be alloc'd in `comm->memScoped`.\n      ncclGroupCommJoin(info->comm);\n      struct ncclInfo* t = ncclMemoryStackAlloc<struct ncclInfo>(&comm->memScoped);\n      info->nChannels = 0;\n      info->nThreads = 0;\n      info->algorithm = NCCL_ALGO_UNDEF;\n      info->protocol = NCCL_PROTO_UNDEF;\n      info->userTuned = false;\n      memcpy(t, info, sizeof(struct ncclInfo));\n      ncclIntruQueueSortEnqueue(&tasks->collQueue, t, collCmp);\n      tasks->workBytesTotal += info->count * ncclTypeSize(info->datatype);\n      tasks->nTasksColl += 1;\n    }\n  }\n\n  if (info->stream != tasks->streamRecent || tasks->streams == nullptr) {\n    tasks->streamRecent = info->stream;\n    struct ncclCudaStreamList* l = tasks->streams;\n    while (true) {\n      if (l == nullptr) { // Got to the end, this must be a new stream.\n        struct ncclCudaGraph graph;\n        NCCLCHECK(ncclCudaGetCapturingGraph(&graph, info->stream))\n        if (tasks->streams != nullptr && !ncclCudaGraphSame(tasks->capturingGraph, graph)) {\n          WARN(\"Streams given to a communicator within a NCCL group must either be all uncaptured or all captured by the same graph.\");\n          return ncclInvalidUsage;\n        }\n        tasks->capturingGraph = graph; // C++ struct assignment\n        // Add stream to list\n        l = ncclMemoryStackAlloc<struct ncclCudaStreamList>(&comm->memScoped);\n        l->stream = info->stream;\n        l->next = tasks->streams;\n        tasks->streams = l;\n        break;\n      }\n      if (l->stream == info->stream)\n        break; // Already seen stream.\n      l = l->next;\n    }\n  }\n  return ncclSuccess;\n}\n\nncclResult_t ncclEnqueueCheck(struct ncclInfo* info) {\n  NCCLCHECK(ncclGroupStartInternal());\n  ncclResult_t ret = ncclSuccess;\n  int devOld = -1;\n\n  NCCLCHECKGOTO(CommCheck(info->comm, info->opName, \"comm\"), ret, fail);\n  // Check whether communicator is ready to communicate\n  NCCLCHECKGOTO(ncclCommEnsureReady(info->comm), ret, fail);\n\n  if (info->comm->checkPointers) {\n    CUDACHECKGOTO(cudaGetDevice(&devOld), ret, fail);\n    CUDACHECKGOTO(cudaSetDevice(info->comm->cudaDev), ret, fail);\n  }\n  NCCLCHECKGOTO(ArgsCheck(info), ret, fail);\n\n  INFO(NCCL_COLL,\"%s: opCount %lx sendbuff %p recvbuff %p count %zi datatype %d op %d root %d comm %p [nranks=%d] stream %p\",\n        info->opName, info->comm->opCount, info->sendbuff, info->recvbuff, info->count,\n        info->datatype, info->op, info->root, info->comm, info->comm->nRanks, info->stream);\n  TRACE_CALL(\"nccl%s(%\" PRIx64 \",%\" PRIx64 \",%zi,%d,%d,%d,%p,%p)\", info->opName, reinterpret_cast<int64_t>(info->sendbuff), reinterpret_cast<int64_t>(info->recvbuff), info->count, info->datatype, info->op, info->root, info->comm, info->stream);\n\n  NCCLCHECKGOTO(taskAppend(info->comm, info), ret, fail);\n\nexit:\n  if (devOld != -1) CUDACHECK(cudaSetDevice(devOld));\n  ncclGroupErrCheck(ret);\n  NCCLCHECK(ncclGroupEndInternal());\n  /* if depth is 1, ncclGroupEndInternal() will trigger group ops. The state can change\n   * so we have to check state here. */\n  if (info->comm && !info->comm->config.blocking) { NCCLCHECK(ncclCommGetAsyncError(info->comm, &ret)) };\n  return ret;\nfail:\n  if (info->comm && !info->comm->config.blocking) (void) ncclCommSetAsyncError(info->comm, ret);\n  goto exit;\n}\n\nNCCL_API(ncclResult_t, ncclRedOpCreatePreMulSum, ncclRedOp_t *op, void *scalar, ncclDataType_t datatype, ncclScalarResidence_t residence, ncclComm_t comm);\nncclResult_t ncclRedOpCreatePreMulSum(ncclRedOp_t *op, void *scalar, ncclDataType_t datatype, ncclScalarResidence_t residence, ncclComm_t comm) {\n  NCCLCHECK(CommCheck(comm, \"ncclRedOpCreatePreMulSum\", \"comm\"));\n  /* join init thread before creating PreMulSum op. */\n  NCCLCHECK(ncclCommEnsureReady(comm));\n\n  if (comm->userRedOpFreeHead == comm->userRedOpCapacity) {\n    // double capacity and resize\n    int cap = 2*comm->userRedOpCapacity;\n    if (cap < 4) cap = 4;\n    ncclUserRedOp *ops = new ncclUserRedOp[cap];\n    std::memcpy(ops, comm->userRedOps, comm->userRedOpCapacity*sizeof(ncclUserRedOp));\n    for(int ix=comm->userRedOpCapacity; ix < cap; ix++)\n      ops[ix].freeNext = ix + 1;\n    delete[] comm->userRedOps;\n    comm->userRedOps = ops;\n    comm->userRedOpCapacity = cap;\n  }\n  // pop from free list\n  int ix = comm->userRedOpFreeHead;\n  ncclUserRedOp *user = &comm->userRedOps[ix];\n  comm->userRedOpFreeHead = user->freeNext;\n\n  user->freeNext = -1; // allocated\n  user->datatype = datatype;\n  user->opFull.op = ncclDevPreMulSum;\n  if (residence == ncclScalarHostImmediate) {\n    user->opFull.scalarArgIsPtr = false;\n    std::memcpy(&user->opFull.scalarArg, scalar, ncclTypeSize(datatype));\n  } else {\n    user->opFull.scalarArgIsPtr = true;\n    user->opFull.scalarArg = reinterpret_cast<uint64_t>(scalar);\n  }\n  *op = ncclRedOp_t(int(ncclNumOps) + ix);\n  *op = ncclUserRedOpMangle(comm, *op);\n  TRACE_CALL(\"ncclRedOpCreatePreMulSum(%d,%p,%d,%d,%p)\", *op, scalar, datatype, residence, comm);\n  return ncclSuccess;\n}\n\nNCCL_API(ncclResult_t, ncclRedOpDestroy, ncclRedOp_t op, ncclComm_t comm);\nncclResult_t ncclRedOpDestroy(ncclRedOp_t op, ncclComm_t comm) {\n  if (0 <= int(op) && int(op) < int(ncclNumOps)) {\n    WARN(\"ncclRedOpDestroy : operator is a NCCL builtin.\");\n    return ncclInvalidArgument;\n  }\n  if (int(op) < 0 || int(ncclMaxRedOp) < int(op)) {\n    WARN(\"ncclRedOpDestroy :  operator is garbage.\");\n    return ncclInvalidArgument;\n  }\n  if (comm == NULL) {\n    WARN(\"ncclRedOpDestroy : invalid communicator passed.\");\n    return ncclInvalidArgument;\n  }\n\n  int ix = int(ncclUserRedOpMangle(comm, op)) - int(ncclNumOps);\n  if (comm->userRedOpCapacity <= ix || comm->userRedOps[ix].freeNext != -1) {\n    WARN(\"ncclRedOpDestroy : operator unknown to this communicator.\");\n    return ncclInvalidArgument;\n  }\n  // push to free list\n  comm->userRedOps[ix].freeNext = comm->userRedOpFreeHead;\n  comm->userRedOpFreeHead = ix;\n  TRACE_CALL(\"ncclRedOpDestroy(%d,%p)\", op, comm);\n  return ncclSuccess;\n}\n","uri":"file:///root/code/nccl-trace/src/enqueue.cc","version":1}}}

I[15:12:27.189] <-- textDocument/didOpen
I[15:12:27.186] --> textDocument/publishDiagnostics
V[15:12:27.189] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[],"uri":"file:///root/code/nccl-trace/.clangd"}}

V[15:12:27.190] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"/*************************************************************************\n * Copyright (c) 2017-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#ifndef NCCL_DEVICE_COMMON_H_\n#define NCCL_DEVICE_COMMON_H_\n\n#include \"collectives.h\"\n#include \"device.h\"\n#include \"op128.h\"\n#include \"network/unpack/unpack_defs.h\"\n\n#define COLL_UNROLL (ncclCollUnroll())\n\ntypedef void(*ncclDevFuncPtr_t)(ncclKernelRecord_t* r);\nextern __device__ ncclDevFuncPtr_t const ncclDevFuncTable[];\n\nstruct ncclShmemGroup {\n  ncclConnInfo *recvConns[NCCL_MAX_ARITY];\n  ncclConnInfo *sendConns[NCCL_MAX_ARITY];\n  void* userInput;\n  void* userOutput;\n  void* srcs[NCCL_MAX_ARITY+1];\n  void* dsts[NCCL_MAX_ARITY+1];\n  union {\n    unpackGroupShmem unpack;\n  } devicePlugin;\n  int32_t dstSizes[NCCL_MAX_ARITY+1];\n};\n\nstruct ncclShmemData {\n  struct ncclShmemGroup groups[NCCL_MAX_GROUPS];\n  uint64_t redOpArgs[NCCL_MAX_ARITY+1];\n  int channelId;\n  int aborted;\n  alignas(16) struct ncclDevComm comm;\n  alignas(16) struct ncclDevChannel channel;\n  alignas(16) struct ncclWork work;\n  alignas(16) union {\n    unpackShmem unpack;\n  } devicePlugin;\n};\nstatic_assert(offsetof(struct ncclShmemData, work)%16 == 0, \"shmem.work needs to be 16B aligned\");\n\nextern __shared__ ncclShmemData ncclShmem;\n#if __CUDA_ARCH__ >= 700\n  extern __shared__ ulong2 ncclShmemPerWarp[/*ncclShmemDynamicSize()/sizeof(ulong2)*/];\n#else\n  extern __shared__ ulong2 ncclShmemPerWarp[ncclShmemScratchWarpSize()*(NCCL_MAX_NTHREADS/WARP_SIZE)/sizeof(ulong2)];\n#endif\n\n__device__ inline void* ncclScratchForWarp(int warp) {\n  return (char*)ncclShmemPerWarp + warp*ncclShmemScratchWarpSize();\n}\n\n__device__ inline bool barrierReduceAny(int bit) {\n  uint32_t popc;\n  asm (\"{\"\n    \".reg .pred barr_pred;\"\n    \"setp.eq.u32 barr_pred, %1, 1;\"\n    \"bar.red.popc.u32 %0, 2, barr_pred;\"\n  \"}\" : \"=r\"(popc) : \"r\"(bit));\n  return popc != 0;\n}\n\n// Copy 16-byte aligned data. You must call with at least `(bytes+15)/16` threads.\ninline __device__ void copyToShmem16(int tid, void* dst, void const* src, int bytes) {\n  int offset = 16*tid;\n  if (offset < bytes) {\n    uint64_t a=0, b=0;\n    asm(\"ld.v2.u64 {%0,%1},[%2];\" : \"=l\"(a),\"=l\"(b) : \"l\"((char const*)src + offset));\n    asm volatile(\"st.v2.u64 [%0],{%1,%2};\" :: \"l\"((char*)dst + offset), \"l\"(a), \"l\"(b));\n  }\n}\n\ntemplate<ncclFunc_t Fn, typename T, typename RedOp, int Algo, int Proto>\nstruct RunWorkElement {\n  __device__ void run(ncclWorkElem*, ncclKernelRecord_t*) {\n    // Put NOT IMPLEMENTED behavior here.\n  }\n};\n\ntemplate<ncclFunc_t Fn, typename T, typename RedOp, int Algo, int Proto>\nstruct RunWork {\n  // This __forceinline__ is necessary. The compiler was inserting a function call\n  // here from the LL ncclKernel.\n  __device__ __forceinline__ void run(ncclWork *w, ncclKernelRecord_t* r) {\n    int wid = threadIdx.x / WARP_SIZE;\n    ncclWorkElem* we = w->header.type == ncclWorkTypeRegColl ? &w->regElems[0].elem : &w->elems[0];\n    int stride = w->header.type == ncclWorkTypeRegColl ? sizeof(ncclWorkElemReg) : sizeof(ncclWorkElem);\n    #pragma unroll 1\n    while ((char*)we + stride <= (char*)(w+1) && we->isUsed) {\n      if (wid < we->nWarps) {\n        RunWorkElement<Fn, T, RedOp, Algo, Proto>().run(we, r);\n      }\n      we = (ncclWorkElem*)((char*)we + stride);\n    }\n  }\n};\n\nstatic __device__ void ncclRedopPtrDeref(struct ncclWorkElem* we) {\n  if (we->isUsed && we->redOpArgIsPtr) {\n    /* redOpArg is a pointer to the scalar value, so we'll dereference it\n     * here so that redOpArg holds the bits of the scalar going forward.\n     * The tricky thing is we don't know its type T since that's encoded in\n     * the funcIndex. Because it would be difficult to get sizeof(T) from\n     * funcIndex, we'll cheat and just dereference the largest possible size\n     * given the alignment of the pointer. We might be reading in more bytes\n     * than we need but that's harmless.\n     */\n    if (we->redOpArg%2 != 0)\n      we->redOpArg = *reinterpret_cast<uint8_t*>(we->redOpArg);\n    else if (we->redOpArg%4 != 0)\n      we->redOpArg = *reinterpret_cast<uint16_t*>(we->redOpArg);\n    else if (we->redOpArg%8 != 0)\n      we->redOpArg = *reinterpret_cast<uint32_t*>(we->redOpArg);\n    else\n      we->redOpArg = *reinterpret_cast<uint64_t*>(we->redOpArg);\n  }\n}\n\ntemplate<int SpecializedFnId, typename SpecializedRunWork>\n__device__ void ncclKernelMain(struct ncclDevComm* comm, uint64_t channelMask, struct ncclWork* workHead, ncclKernelRecord_t* r) {\n  int tid = threadIdx.x;\n\n  // To map blockId to channelId, we need the n'th set bit of channelMask which\n  // is the inverse of counting the number of set bits among the the first n.\n  if (tid < WARP_SIZE) {\n    int x = tid;\n    if (channelMask & (1ull<<x)) {\n      int y = __popcll(channelMask & ((1ull<<x)-1));\n      if (blockIdx.x == y) ncclShmem.channelId = x;\n    }\n    if (32 < MAXCHANNELS) {\n      x = 32 + tid;\n      if (channelMask & (1ull<<x)) {\n        int y = __popcll(channelMask & ((1ull<<x)-1));\n        if (blockIdx.x == y) ncclShmem.channelId = x;\n      }\n    }\n  }\n  __syncthreads(); // publish ncclShmem.channelId\n  int channelId = ncclShmem.channelId;\n\n  if (threadIdx.x == 0) {\n    if(r) {\n      r->channels[channelId].startGpuCycles = clock64();\n    }\n  }\n\n  /* set abort flag to 0 */\n  if (tid == 0) ncclShmem.aborted = 0;\n\n  if (true) {\n    void *dst, *src;\n    int bytes;\n    // Use first 3 warps to load comm, channel, and work into ncclShmem\n    switch (tid/WARP_SIZE) {\n    case 0:\n      dst = &ncclShmem.comm;\n      src = comm;\n      bytes = sizeof(ncclDevComm);\n      static_assert(sizeof(ncclDevComm) <= 16*WARP_SIZE, \"ncclDevComm cannot be loaded by a single warp in one insn.\");\n      break;\n    case 1:\n      // Get address of channel without incurring indirect load from ncclDevComm::channels\n      dst = &ncclShmem.channel;\n      src = &((ncclDevCommAndChannels*)comm)->channels[channelId];\n      bytes = sizeof(ncclDevChannel);\n      static_assert(sizeof(ncclDevChannel) <= 16*WARP_SIZE, \"ncclDevChannel cannot be loaded by a single warp in one insn.\");\n      break;\n    case 2:\n      dst = &ncclShmem.work;\n      src = workHead + blockIdx.x;\n      bytes = sizeof(ncclWork);\n      static_assert(sizeof(ncclWork) <= 16*WARP_SIZE, \"ncclWork cannot be loaded by a single warp in one insn.\");\n      break;\n    default:\n      bytes = 0;\n      break;\n    }\n    if (bytes) copyToShmem16(tid%WARP_SIZE, dst, src, bytes);\n  }\n  __syncthreads(); // publish ncclShmem\n\n  while (true) {\n    // Notify host that all fifo reads are complete.\n    if (tid == 0 && ncclShmem.work.header.isLast && ncclShmem.work.header.inFifo) {\n      *ncclShmem.channel.workFifoDone = ncclShmem.work.header.doneAcks;\n    }\n\n    __syncwarp();\n    if (ncclShmem.work.header.type == ncclWorkTypeColl) {\n      if (tid < NCCL_MAX_WORK_ELEMENTS) ncclRedopPtrDeref(&ncclShmem.work.elems[tid]);\n    } else if (ncclShmem.work.header.type == ncclWorkTypeRegColl) {\n      if (tid < NCCL_MAX_WORK_ELEMENTS_REG) ncclRedopPtrDeref(&ncclShmem.work.regElems[tid].elem);\n    }\n    __syncthreads();\n\n    if (0 <= SpecializedFnId && ncclShmem.work.header.funcIndex == (unsigned)SpecializedFnId) {\n      SpecializedRunWork().run(&ncclShmem.work, r);\n    } else {\n      ncclDevFuncTable[ncclShmem.work.header.funcIndex](r);\n    }\n\n    int workIxNext = ncclShmem.work.header.workNext;\n    __syncthreads();\n    if (ncclShmem.work.header.isLast) break;\n\n    copyToShmem16(tid, &ncclShmem.work, workHead + workIxNext, sizeof(ncclWork));\n\n    { // Check whether the last operation was aborted and make sure all threads exit\n      int aborted = tid == 0 ? *comm->abortFlag : 0;\n      if (barrierReduceAny(aborted)) // publish ncclShmem.work\n        break;\n    }\n  }\n}\n\n__global__ void ncclDevKernel_Generic(struct ncclDevComm* comm, uint64_t channelMask, struct ncclWork* workHead, ncclKernelRecord_t* r);\n__device__ void ncclDevFunc_Nop(ncclKernelRecord_t* r);\n\n#define DEFINE_ncclDevKernel(suffix, coll, redop, ty, algo, proto, specializedFnId) \\\n  __global__ void ncclDevKernel_##suffix(struct ncclDevComm* comm, uint64_t channelMask, struct ncclWork* workHead, ncclKernelRecord_t* r) { \\\n  ncclKernelMain<specializedFnId, RunWork<coll, ty, redop<ty>, algo, proto>>(comm, channelMask, workHead, r); \\\n  if (threadIdx.x == 0) { \\\n    if(r) { \\\n      r->channels[ncclShmem.channelId].endGpuCycles = clock64(); \\\n    } \\\n  } \\\n}\n\n\n#define DEFINE_ncclDevFunc(suffix, coll, redop, ty, algo, proto, r) \\\n  __device__ void ncclDevFunc_##suffix(ncclKernelRecord_t* r) { \\\n    RunWork<coll, ty, redop<ty>, algo, proto>().run(&ncclShmem.work, r); \\\n  }\n\n#endif\n","uri":"file:///root/code/nccl-trace/src/device/common.h","version":1}}}

I[15:12:27.190] <-- textDocument/didOpen
I[15:12:27.190] Loaded compilation database from /root/code/nccl-trace/compile_commands.json
V[15:12:27.190] Broadcasting compilation database from /root/code/nccl-trace
I[15:12:27.190] ASTWorker building file /root/code/nccl-trace/src/profile.cc version 1 with command 
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -I. -I/root/code/nccl-trace/include -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -Iinclude -o /root/code/nccl-trace/obj/profile.o -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/profile.cc
V[15:12:27.190] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"/*************************************************************************\n * Copyright (c) 2015-2022, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#ifndef NCCL_DEVICE_H_\n#define NCCL_DEVICE_H_\n\n#include \"nccl.h\"\n#include \"nccl_common.h\"\n#include \"align.h\"\n#include <stdint.h>\n\nextern const char* ncclFuncStr[NCCL_NUM_FUNCTIONS];\n\nextern const char* ncclAlgoStr[NCCL_NUM_ALGORITHMS];\n\nextern const char* ncclProtoStr[NCCL_NUM_PROTOCOLS];\n\n#define NCCL_MAX_OPS 2048\n#define NCCL_STEPS 8\n\n#include \"net_device.h\"\n\nenum ncclDevRedOp_t {\n  ncclDevSum, ncclDevProd, ncclDevMinMax,\n  ncclDevPreMulSum, ncclDevSumPostDiv,\n  ncclNumDevRedOps\n};\nstruct ncclDevRedOpFull {\n  ncclDevRedOp_t op;\n  ncclRedOp_t proxyOp;\n  bool scalarArgIsPtr;\n  uint64_t scalarArg;\n};\n\nunion ncclLLFifoLine {\n  /* Flags have to be *after* data, because otherwise, an incomplete receive\n     from the network may receive the flag but not the data.\n     Note this is assuming that either we receive contiguous chunks of data\n     (sockets) or data is written with an atomicity of 8 bytes (IB/RDMA). */\n  struct {\n    uint32_t data1;\n    uint32_t flag1;\n    uint32_t data2;\n    uint32_t flag2;\n  };\n  uint64_t v[2];\n  int4 i4;\n};\n\n#define WARP_SIZE 32\n#define MAXCHANNELS 32\n#define NCCL_MAX_NTHREADS 640\n#define NCCL_SIMPLE_MAX_NTHREADS 512\n#define NCCL_LL_MAX_NTHREADS 512\n#define NCCL_LL_LINES_PER_THREAD 8\n#ifdef TEST_LL_CLEANUP\n#define NCCL_LL_CLEAN_MASK 0x078 // Set to 0x100 to disable cleanup\n#define NCCL_LL_FLAG_MAX   0x100\n#define NCCL_LL_FLAG(a) ((uint32_t)((a) % NCCL_LL_FLAG_MAX))\n#else\n#define NCCL_LL_CLEAN_MASK 0x7ffffff8\n#define NCCL_LL_FLAG(a) ((uint32_t)(a))\n#endif\n// Make sure the clean mask will last for at least NCCL_NSTEPS\nstatic_assert(NCCL_LL_CLEAN_MASK % NCCL_STEPS == 0, \"Invalid NCCL_LL_CLEAN_MASK value\");\n\n#define NCCL_LL128_LINESIZE 128\n#define NCCL_LL128_LINEELEMS (NCCL_LL128_LINESIZE/sizeof(uint64_t))\n#define NCCL_LL128_DATAELEMS (NCCL_LL128_LINEELEMS-1)\n\n#define NCCL_LL128_MAX_NTHREADS 640\n#define NCCL_LL128_ELEMS_PER_THREAD 120\n\n#define NCCL_LL128_SHMEM_ELEMS_PER_THREAD 8\n#define NCCL_LL128_SHMEM_SIZE (NCCL_LL128_SHMEM_ELEMS_PER_THREAD*NCCL_LL128_MAX_NTHREADS)\n\n#define NCCL_DIRECT_WRITE 0x01\n#define NCCL_DIRECT_READ  0x02\n#define NCCL_DIRECT_NIC   0x04\n#define NCCL_IPC_WRITE    0x08\n#define NCCL_IPC_READ     0x10\n#define NCCL_NVLS_MIN_POLL 0x20\n\n#define NCCL_MAX_COLLNET_SIZE (1L << 29)\n\nenum ncclRegBufferType {\n  NCCL_REGULAR_BUFFER = 0,\n  NCCL_IPC_REG_BUFFER = 1,\n  NCCL_NVLS_REG_BUFFER = 2,\n  NCCL_COLLNET_REG_BUFFER = 3\n};\n\nstruct ncclConnInfo {\n  // Regular comm mechanism\n  char *buffs[NCCL_NUM_PROTOCOLS]; // Local for recv, remote for send\n  void* mhandles[NCCL_NUM_PROTOCOLS];\n  uint64_t *tail;     // Local for recv, remote for send\n  uint64_t *head;     // Local for send, remote for recv\n\n  int flags;          // Direct communication / other flags\n  int shared;         // Buffers are shared\n  int stepSize;       // Step size for the SIMPLE buffer\n  void **ptrExchange; // Pointer exchange for direct communication\n  uint64_t* redOpArgExchange; // PreOp scaler exchange for direct pull case\n\n  struct ncclConnFifo* connFifo; // Used for GPU - Proxy communication\n\n  uint64_t step;      // Keep where we are\n  uint64_t llLastCleaning;\n  ncclNetDeviceHandle_t netDeviceHandle;\n};\n\nstruct ncclProxyConnector {\n  int tpRank;\n  int tpLocalRank;\n  int sameProcess;\n  struct ncclProxyConnection* connection;\n  ncclResult_t (*proxyProgress)(struct ncclProxyState* proxyState, struct ncclProxyArgs*); // Copied from transport if necessary\n};\n\nstruct ncclConnector {\n  int connected;\n  struct ncclProxyConnector proxyConn;\n  struct ncclTransportComm* transportComm;\n  void* transportResources;\n  struct ncclConnInfo conn;\n};\n\nstruct ncclRing {\n  // Shortcuts for userRanks[1] and userRanks[n-1]\n  int prev;\n  int next;\n\n  // Maps an internal nccl index to user-specified rank order. This is necessary\n  // since we need to know how the user expects data to be ordered across\n  // devices. Ordered from current device.\n  int* userRanks;\n\n  int index; // This rank's index in the ring\n};\n\n\n// The root of each tree only has one node down (+1 intra-node).\n#define NCCL_MAX_TREE_ARITY_TOP 2\n// Nodes inside the binary tree can have to two nodes down (+1 intra-node).\n#define NCCL_MAX_TREE_ARITY 3\nstruct ncclTree {\n  int depth;\n  int up;\n  int down[NCCL_MAX_TREE_ARITY];\n};\n\n#define NCCL_MAX_DIRECT_ARITY 7\nstruct ncclDirect {\n  int depth;\n  int out;\n  int nHeads;   // Number of parallel N<->1<->net operations we'll do in parallel; size of up/down\n  int headRank; // Index in 0..nHeads-1 I am the head rank of. -1 if I'm not a head rank (no local NIC)\n  int shift;    // Shuffling of send/recv for scatter/gather operations, basically localRank%nHeads\n  // The heads[...] are guaranteed to be in rotated order start with self:\n  //   headRank, (headRank+1)%nHeads, (headRank+2)%nHeads, ...\n  int heads[NCCL_MAX_DIRECT_ARITY+1];\n  int up[NCCL_MAX_DIRECT_ARITY];\n  int down[NCCL_MAX_DIRECT_ARITY];\n};\n\n#define NCCL_MAX_NVLS_ARITY 32\n#define NCCL_MAX_NVLS_TREE_ARITY 3\nstruct ncclNvls {\n  int out;\n  int nHeads;   // Number of parallel N<->1<->net operations we'll do in parallel; size of up/down\n  int headRank; // Index in 0..nHeads-1 I am the head rank of. -1 if I'm not a head rank (no local NIC)\n  int up[NCCL_MAX_NVLS_ARITY];\n  int down;\n  int treeUp;\n  int treeDown[NCCL_MAX_NVLS_TREE_ARITY];\n  int node;\n  int nNodes;\n};\n\n#if __CUDA_ARCH__ >= 900\n#define NCCL_MAX_ARITY NCCL_MAX_NVLS_ARITY\n#else\n#define NCCL_MAX_ARITY NCCL_MAX_DIRECT_ARITY\n#endif\n\n#define NCCL_MAX_CONNS 2\nstruct ncclChannelPeer {\n  struct ncclConnector send[NCCL_MAX_CONNS];\n  struct ncclConnector recv[NCCL_MAX_CONNS];\n  int refCount;\n};\n\nstruct ncclDevComm;\n\n/* ncclWork is to be a power of two, currently 8x64 bytes, */\n/* to make sure reads to host from the CUDA kernel are aligned. */\n/* Make sure to adjust padding at the end of ncclWorkElem. */\n#define NCCL_WORK_SIZE 512\n\nenum ncclWorkType : uint8_t {\n   ncclWorkTypeUnused=0,\n   ncclWorkTypeColl=1,\n   ncclWorkTypeP2p=2,\n   ncclWorkTypeRegColl=3\n};\nenum ncclWorkP2PType : uint8_t {\n  ncclWorkP2pTypeUnused=0,\n  ncclWorkP2pTypeSend,\n  ncclWorkP2pTypeRecv\n};\n\nstruct ncclWorkHeader {\n  union {\n    int32_t workNext;  // when isLast=0: Offset from kernel argument workHead\n    uint32_t doneAcks; // when isLast=1: Monotonic (mod 1<<32) ack value to send back.\n  };\n  uint16_t funcIndex;\n  uint8_t isLast:1; // last work for this kernel\n  uint8_t inFifo:1; // is this work in the fifo\n  enum ncclWorkType type;\n};\n\nstruct ncclWorkElem {\n  union {\n    uint8_t flagBits;\n    struct {\n      uint8_t isUsed:1, redOpArgIsPtr:1, oneNode:1;\n    };\n  };\n  uint8_t regUsed;\n  uint8_t nWarps;\n  uint8_t direct;\n  uint32_t root;\n  const void *sendbuff;\n  void *recvbuff;\n\n  size_t count;\n  uint64_t redOpArg;\n  uint64_t chunkCount:25, workCount:39;\n  union {\n    struct {\n      uint64_t lastChunkCount:25;\n      uint64_t workOffset:39;\n    };\n    struct {\n      uint64_t bid:32;\n      uint64_t nChannels:32;\n    };\n  };\n};\n\n#define NCCL_MAX_WORK_ELEMENTS ((NCCL_WORK_SIZE - alignUp(sizeof(ncclWorkHeader), alignof(ncclWorkElem)))/sizeof(ncclWorkElem))\nstatic_assert(NCCL_MAX_WORK_ELEMENTS == 9, \"Sanity check: NCCL_MAX_WORK_ELEMENTS == 9\");\n\nstruct ncclWorkElemP2p {\n  int peer : 30;\n  int proto : 2;\n\n  enum ncclWorkP2PType p2pType;\n  uint8_t reg:1;\n  uint8_t nWarps:5;\n  uint8_t warpStart;\n  uint8_t ngroups;\n  // Important not to use any fields with greater than 4-byte alignment since\n  // we need sizeof(ncclWorkElemP2p)==28, but that would be padded up to 32 if\n  // there were 8-byte fields.\n  //void* buff;\n  uint32_t buffHi32, buffLo32; // buff = buffHi32<<32 | buffLo32;\n  //size_t count;\n  uint32_t countHi32, countLo32; // count = countHi32<<32 | countLo32;\n  int chunkSize;\n};\n\nstatic_assert(((NCCL_WORK_SIZE - alignUp(sizeof(ncclWorkHeader), alignof(ncclWorkElemP2p)))/sizeof(ncclWorkElemP2p)) >= 16, \"Sanity check: NCCL_MAX_WORK_ELEMENTS_P2P == 16\");\n#define NCCL_MAX_WORK_ELEMENTS_P2P 16\n\nstruct ncclWorkElemReg {\n  struct ncclWorkElem elem;\n  void* dnInputs[NCCL_MAX_DIRECT_ARITY+1];\n  void* dnOutputs[NCCL_MAX_DIRECT_ARITY+1];\n  void* upOutputs[NCCL_MAX_DIRECT_ARITY+1];\n};\n\n#define NCCL_MAX_WORK_ELEMENTS_REG ((NCCL_WORK_SIZE - alignUp(sizeof(ncclWorkHeader), alignof(ncclWorkElemReg)))/sizeof(ncclWorkElemReg))\nstatic_assert(NCCL_MAX_WORK_ELEMENTS_REG == 2, \"Sanity check: NCCL_MAX_WORK_ELEMENTS_REG == 2\");\n\n// Number of named barriers supported by CUDA\n#define NCCL_MAX_GROUPS 16\n\nstruct ncclWork {\n  struct ncclWorkHeader header;\n  union {\n    char pad[NCCL_WORK_SIZE - sizeof(struct ncclWorkHeader)];\n    struct ncclWorkElem elems[NCCL_MAX_WORK_ELEMENTS];\n    struct ncclWorkElemP2p p2pElems[NCCL_MAX_WORK_ELEMENTS_P2P];\n    struct ncclWorkElemReg regElems[NCCL_MAX_WORK_ELEMENTS_REG];\n  };\n};\nstatic_assert(sizeof(struct ncclWork) == NCCL_WORK_SIZE, \"Sanity check: sizeof(struct ncclWork) == NCCL_WORK_SIZE\");\nstatic_assert(sizeof(struct ncclWork)%16 == 0, \"Sanity check: sizeof(struct ncclWork)%16 == 0\");\n\nstruct ncclDevChannelPeer {\n  // Stripped version of ncclChannelPeer where we only keep the ncclConnInfo\n  // instead of the full ncclConnector.\n  struct ncclConnInfo send[NCCL_MAX_CONNS];\n  struct ncclConnInfo recv[NCCL_MAX_CONNS];\n};\n\nstruct alignas(16) ncclDevChannel {\n  struct ncclDevChannelPeer** peers;\n  struct ncclRing ring;\n  struct ncclTree tree;\n  struct ncclTree collnetChain;\n  struct ncclDirect collnetDirect;\n  struct ncclNvls nvls;\n  uint32_t* workFifoDone; // Location of done counter, device writes index+1 of last work processed\n};\n\nstruct ncclDevComm {\n  int rank;\n  int nRanks;\n  int node;\n  int nNodes;\n  int buffSizes[NCCL_NUM_PROTOCOLS];\n  int p2pChunkSize;\n\n  // Operation list for aggregation\n  int workFifoDepth;\n  struct ncclWork* workFifoHeap; // may be cudaHost or GDR memory\n\n  int* collNetDenseToUserRank;\n\n  // Flag to ask NCCL kernels to abort\n  volatile uint32_t* abortFlag;\n\n  // Channels, device side\n  struct ncclDevChannel* channels/*[MAXCHANNELS]*/;\n\n  ncclKernelRecord_t *ptr;\n};\n\nstruct alignas(16) ncclDevCommAndChannels {\n  struct ncclDevComm comm;\n  struct ncclDevChannel channels[MAXCHANNELS];\n};\n\n#ifdef __CUDA_ARCH__\n  #define NCCL_CUDA_ARCH __CUDA_ARCH__\n#else\n  #define NCCL_CUDA_ARCH 0\n#endif\n\ntemplate<typename T>\n__host__ __device__ constexpr T min_constexpr(T a) { return a; }\ntemplate<typename T, typename ...Ts>\n__host__ __device__ constexpr T min_constexpr(T a, T b, Ts ...c) {\n  return min_constexpr<T>((a < b ? a : b), c...);\n}\n\ntemplate<typename T>\n__host__ __device__ constexpr T max_constexpr(T a) { return a; }\ntemplate<typename T, typename ...Ts>\n__host__ __device__ constexpr T max_constexpr(T a, T b, Ts ...c) {\n  return max_constexpr<T>((a > b ? a : b), c...);\n}\n\n// Calculate the unroll factor given:\n// * bytePerPack: number of bytes accessed per instruction\n// * insns: max permissible unroll value\n// * bytes: desired number of in-flight bytes per iteration ( = unroll*bytePerPack)\n__host__ __device__ constexpr int ncclCalcUnroll(int bytePerPack, int insns, int bytes) {\n  return min_constexpr(insns, (bytes + bytePerPack-1)/bytePerPack);\n}\n\n// Note that all unroll value logic should depend on a given cudaArch argument\n// and not __CUDA_ARCH__ since these need to be host-side executable where the\n// arch value is strictly runtime only. By defaulting to NCCL_CUDA_ARCH, device\n// side code can elide passing the arch for brevity.\n\n__host__ __device__ constexpr int ncclCollUnroll(int cudaArch = NCCL_CUDA_ARCH) {\n  // Our collective unroll should move to the same bytes&insns model as NVLS.\n  return cudaArch >= 800 ? 8 : 4;\n}\n\n__host__ __device__ constexpr int ncclNvlsUnrollBytes(int cudaArch = NCCL_CUDA_ARCH) { return 4*16; }\n__host__ __device__ constexpr int ncclNvlsUnrollInsns(int cudaArch = NCCL_CUDA_ARCH) { return 16; }\n\n__host__ __device__ constexpr int ncclNvlsUnroll(int bytePerPack, int cudaArch = NCCL_CUDA_ARCH) {\n  return ncclCalcUnroll(bytePerPack, ncclNvlsUnrollInsns(cudaArch), ncclNvlsUnrollBytes(cudaArch));\n}\n\n// The amount of dynamic shmem per warp\n__host__ __device__ constexpr int ncclShmemScratchWarpSize(int cudaArch = NCCL_CUDA_ARCH) {\n  return (max_constexpr<int>(\n      /*LL    */0,\n      /*LL128 */(NCCL_LL128_SHMEM_ELEMS_PER_THREAD*WARP_SIZE)*sizeof(uint64_t),\n      /*SIMPLE*/(ncclCollUnroll(cudaArch)*WARP_SIZE + 1)*16,\n      // NVLS needs an extra 16B to read unaligned data.\n      /*NVLS  */WARP_SIZE*(cudaArch >= 900 ? ncclNvlsUnrollBytes(cudaArch) : 0) + 16\n    ) + 15) & -16; // pad to 16 bytes\n}\n\n// The amount of dynamic shmem per block\n__host__ __device__ constexpr int ncclShmemDynamicSize(int cudaArch = NCCL_CUDA_ARCH) {\n  return cudaArch < 700 ? 0 : ncclShmemScratchWarpSize(cudaArch)*(NCCL_MAX_NTHREADS/WARP_SIZE);\n}\n\n// Host-side table of kernel function pointers.\nextern int const ncclDevKernelCount;\nextern void* const ncclDevKernelList[/*ncclDevKernelCount*/];\n\n// Table of most specialized kernel function to run given func index.\nextern int const ncclDevFuncRowToId[];\nextern void* const ncclDevKernelForFunc[/*funcIndex*/];\nextern bool const ncclDevKernelForFuncIsSpecialized[/*funcIndex*/];\n\n// Launch a one-rank reduction on stream.\nncclResult_t ncclLaunchOneRank(void* dst, void const* src, size_t nElts, struct ncclDevRedOpFull redOp, ncclDataType_t type, cudaStream_t stream);\n\n// `ncclNvlsSupported()` needs to be in sync with \"func_valid\" in \"src/device/generate.py\"\ninline bool ncclNvlsSupported(int devRedOp, int type) {\n  switch (type) {\n  case ncclInt32:\n  case ncclUint32:\n  case ncclInt64:\n  case ncclUint64:\n  case ncclFloat16:\n  #if defined(__CUDA_BF16_TYPES_EXIST__)\n  case ncclBfloat16:\n  #endif\n    return devRedOp == ncclDevSum || devRedOp == ncclDevMinMax;\n  case ncclFloat:\n  case ncclDouble:\n    return devRedOp == ncclDevSum;\n  default:\n    return false;\n  }\n}\n\n// `ncclDevFuncIndex()` needs to be in sync with \"all_functions()\" in \"src/device/generate.py\"\ninline int ncclDevFuncId(int coll, int devRedOp, int type, int algo, int proto) {\n  #if defined(__CUDA_BF16_TYPES_EXIST__)\n  constexpr int NumTypes = ncclNumTypes;\n  #else\n  constexpr int NumTypes = ncclNumTypes + 1;\n  #endif\n  int row;\n  do {\n    row = 0; // ncclDevFuncIndex_P2p\n    if (coll == ncclFuncSendRecv) break;\n    row += 1;\n\n    int nAlgos = 3;\n    if (coll == ncclFuncAllGather) {\n      int algo1 = algo == NCCL_ALGO_RING ? 0 :\n                  algo == NCCL_ALGO_COLLNET_DIRECT ? 1 :\n                /*algo == NCCL_ALGO_NVLS*/ 2;\n      row += algo1*NCCL_NUM_PROTOCOLS + proto;\n      break;\n    }\n    row += nAlgos*NCCL_NUM_PROTOCOLS;\n\n    nAlgos = 1;\n    if (coll == ncclFuncBroadcast) {\n      row += proto;\n      break;\n    }\n    row += nAlgos*NCCL_NUM_PROTOCOLS;\n\n    nAlgos = NCCL_NUM_ALGORITHMS;\n    if (coll == ncclFuncAllReduce) {\n      row += ((devRedOp*NumTypes + type)*nAlgos + algo)*NCCL_NUM_PROTOCOLS + proto;\n      break;\n    }\n    row += ncclNumDevRedOps*NumTypes*nAlgos*NCCL_NUM_PROTOCOLS;\n\n    nAlgos = 1;\n    if (coll == ncclFuncReduce) {\n      row += (devRedOp*NumTypes + type)*NCCL_NUM_PROTOCOLS + proto;\n      break;\n    }\n    row += ncclNumDevRedOps*NumTypes*nAlgos*NCCL_NUM_PROTOCOLS;\n\n    nAlgos = 3;\n    if (coll == ncclFuncReduceScatter) {\n      int algo1 = algo == NCCL_ALGO_RING ? 0 :\n                  algo == NCCL_ALGO_COLLNET_DIRECT ? 1 :\n                /*algo == NCCL_ALGO_NVLS*/ 2;\n      row += ((devRedOp*NumTypes + type)*nAlgos + algo1)*NCCL_NUM_PROTOCOLS + proto;\n      break;\n    }\n    row += ncclNumDevRedOps*NumTypes*nAlgos*NCCL_NUM_PROTOCOLS;\n  } while (false);\n\n  return ncclDevFuncRowToId[row];\n}\n\ninline int ncclDevFuncId_P2p() { return ncclDevFuncRowToId[0]; }\n\n#endif\n","uri":"file:///root/code/nccl-trace/src/include/device.h","version":1}}}

I[15:12:27.190] <-- textDocument/didOpen
I[15:12:27.190] ASTWorker building file /root/code/nccl-trace/src/graph/topo.h version 1 with command inferred from graph/topo.cc
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -I. -I/root/code/nccl-trace/include -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -Iinclude -x c++-header -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/graph/topo.h
I[15:12:27.190] --> window/workDoneProgress/create(0)
V[15:12:27.190] <<< {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"languageId":"cpp","text":"/*************************************************************************\n * Copyright (c) 2015-2021, NVIDIA CORPORATION. All rights reserved.\n *\n * See LICENSE.txt for license information\n ************************************************************************/\n\n#ifndef NCCL_H_\n#define NCCL_H_\n\n#include <stdint.h>\n\n#include <cuda_runtime.h>\n#include <cuda_fp16.h>\n#if CUDART_VERSION >= 11000\n#include <cuda_bf16.h>\n#endif\n\n#define NCCL_MAJOR 2\n#define NCCL_MINOR 21\n#define NCCL_PATCH 5\n#define NCCL_SUFFIX \"\"\n\n#define NCCL_VERSION_CODE 22105\n#define NCCL_VERSION(X,Y,Z) (((X) <= 2 && (Y) <= 8) ? (X) * 1000 + (Y) * 100 + (Z) : (X) * 10000 + (Y) * 100 + (Z))\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <pthread.h>\n#include <limits.h>\n/* Opaque handle to communicator */\ntypedef struct ncclComm* ncclComm_t;\n#define NCCL_COMM_NULL NULL\n\n#define NCCL_UNIQUE_ID_BYTES 128\ntypedef struct { char internal[NCCL_UNIQUE_ID_BYTES]; } ncclUniqueId;\n\n/* Error type */\ntypedef enum { ncclSuccess                 =  0,\n               ncclUnhandledCudaError      =  1,\n               ncclSystemError             =  2,\n               ncclInternalError           =  3,\n               ncclInvalidArgument         =  4,\n               ncclInvalidUsage            =  5,\n               ncclRemoteError             =  6,\n               ncclInProgress              =  7,\n               ncclNumResults              =  8 } ncclResult_t;\n\n#define NCCL_CONFIG_UNDEF_INT INT_MIN\n#define NCCL_CONFIG_UNDEF_PTR NULL\n#define NCCL_SPLIT_NOCOLOR -1\n\n/* Communicator configuration. Users can assign value to attributes to specify the\n * behavior of a communicator. */\ntypedef struct ncclConfig_v21700 {\n  /* attributes that users should never touch. */\n  size_t size;\n  unsigned int magic;\n  unsigned int version;\n  /* attributes that users are able to customize. */\n  int blocking;\n  int cgaClusterSize;\n  int minCTAs;\n  int maxCTAs;\n  const char *netName;\n  int splitShare;\n} ncclConfig_t;\n\n/* Config initializer must be assigned to initialize config structure when it is created.\n * Not initialized config will result in NCCL error. */\n#define NCCL_CONFIG_INITIALIZER {                                       \\\n  sizeof(ncclConfig_t), /* size */                                      \\\n  0xcafebeef,           /* magic */                                     \\\n  NCCL_VERSION(NCCL_MAJOR, NCCL_MINOR, NCCL_PATCH), /* version */       \\\n  NCCL_CONFIG_UNDEF_INT,                    /* blocking */              \\\n  NCCL_CONFIG_UNDEF_INT,                    /* cgaClusterSize */        \\\n  NCCL_CONFIG_UNDEF_INT,                    /* minCTAs */               \\\n  NCCL_CONFIG_UNDEF_INT,                    /* maxCTAs */               \\\n  NCCL_CONFIG_UNDEF_PTR,                    /* netName */               \\\n  NCCL_CONFIG_UNDEF_INT                     /* splitShare */            \\\n}\n\n#define TRACE_MAXCHANNELS 32\n#define TRACE_WARN_HANG_INTERVAL_IN_CYCLES 2.4*1e9*0.1 /*about 0.1 seconds*/\n\ntypedef enum : uint8_t {\n  unknownChannel = 0,\n  ringChannelType = 1,\n  p2pChannelType = 2,\n  treeChannelType = 3\n} channelType_t;\n\ntypedef struct alignas(64) {\n  int64_t redcopyCost[TRACE_MAXCHANNELS];\n} reduceScatterRecord_t;\n\ntypedef struct alignas(64) {\n  int receivePeers[8];\n  int sendPeers[8];\n  int receivedSlices[8];\n  int sentSlices[8];\n} p2pChannelRecord_t;\n\ntypedef struct alignas(64) {\n  int prevPeer;\n  int nextPeer;\n  int receivedSlices;\n  int sentSlices;\n  int cpuReceivedSlices;\n  int cpuSentSlices;\n} ringChannelRecord_t;\n\ntypedef struct alignas(64) {\n  int upDownPeers[3];\n  int receivedSlices[3];\n  int sentSlices[3];\n} treeChannelRecord_t;\n\ntypedef struct alignas(64) {\n  int64_t startGpuCycles;\n  int64_t endGpuCycles;\n  ringChannelRecord_t ring;\n  p2pChannelRecord_t p2p;\n  treeChannelRecord_t tree;\n  int collBytes;\n} channelRecord_t;\n\ntypedef struct alignas(64) {\n  int64_t kernelId;\n  int rank;\n  int funcIndex;\n  int channelCount;\n  int channelUbound;\n  uint64_t channelMask;\n  channelType_t channelType; // ring, p2p, tree\n  channelRecord_t channels[TRACE_MAXCHANNELS];\n  int hasRecvProxyMask;\n  int hasSendProxyMask;\n  int startedChannels; // used to save count of started channels in last scan.\n  int endedChannels;\n  int64_t lastDumpCycles;\n#ifdef ENABLE_SLOW\n  union {\n    reduceScatterRecord_t rsRecord;\n  };\n#endif\n} ncclKernelRecord_t;\n\nconst int ncclKrRingSize = 1024;\n\ntypedef struct {\n  pthread_mutex_t mutex;\n  int64_t start;\n  int64_t end;\n  ncclKernelRecord_t records[ncclKrRingSize];\n} ncclKrRing_t;\n\nncclKernelRecord_t * allocKrRingSlot(uint64_t commHash, uint64_t launchedKernels, int rank, int funcIndex, int channels, int channelUbound, uint64_t channelMask);\n\n/* NCCL malloc and free function for all types of NCCL optimizations\n * (e.g. user buffer registration). The actual allocated size might\n * be larger than requested due to granularity requirement. */\nncclResult_t  ncclMemAlloc(void** ptr, size_t size);\nncclResult_t pncclMemAlloc(void** ptr, size_t size);\n\nncclResult_t  ncclMemFree(void *ptr);\nncclResult_t pncclMemFree(void *ptr);\n\n/* Return the NCCL_VERSION_CODE of the NCCL library in the supplied integer.\n * This integer is coded with the MAJOR, MINOR and PATCH level of the\n * NCCL library\n */\nncclResult_t  ncclGetVersion(int *version);\nncclResult_t pncclGetVersion(int *version);\n\n/* Generates an Id to be used in ncclCommInitRank. ncclGetUniqueId should be\n * called once and the Id should be distributed to all ranks in the\n * communicator before calling ncclCommInitRank. */\nncclResult_t  ncclGetUniqueId(ncclUniqueId* uniqueId);\nncclResult_t pncclGetUniqueId(ncclUniqueId* uniqueId);\n\n/* Create a new communicator (multi thread/process version) with a configuration\n * set by users. */\nncclResult_t  ncclCommInitRankConfig(ncclComm_t* comm, int nranks, ncclUniqueId commId, int rank, ncclConfig_t* config);\nncclResult_t pncclCommInitRankConfig(ncclComm_t* comm, int nranks, ncclUniqueId commId, int rank, ncclConfig_t* config);\n\n/* Creates a new communicator (multi thread/process version).\n * rank must be between 0 and nranks-1 and unique within a communicator clique.\n * Each rank is associated to a CUDA device, which has to be set before calling\n * ncclCommInitRank.\n * ncclCommInitRank implicitly syncronizes with other ranks, so it must be\n * called by different threads/processes or use ncclGroupStart/ncclGroupEnd. */\nncclResult_t  ncclCommInitRank(ncclComm_t* comm, int nranks, ncclUniqueId commId, int rank);\nncclResult_t pncclCommInitRank(ncclComm_t* comm, int nranks, ncclUniqueId commId, int rank);\n\n/* Creates a clique of communicators (single process version).\n * This is a convenience function to create a single-process communicator clique.\n * Returns an array of ndev newly initialized communicators in comm.\n * comm should be pre-allocated with size at least ndev*sizeof(ncclComm_t).\n * If devlist is NULL, the first ndev CUDA devices are used.\n * Order of devlist defines user-order of processors within the communicator. */\nncclResult_t  ncclCommInitAll(ncclComm_t* comm, int ndev, const int* devlist);\nncclResult_t pncclCommInitAll(ncclComm_t* comm, int ndev, const int* devlist);\n\n/* Finalize a communicator. ncclCommFinalize flushes all issued communications,\n * and marks communicator state as ncclInProgress. The state will change to ncclSuccess\n * when the communicator is globally quiescent and related resources are freed; then,\n * calling ncclCommDestroy can locally free the rest of the resources (e.g. communicator\n * itself) without blocking. */\nncclResult_t  ncclCommFinalize(ncclComm_t comm);\nncclResult_t pncclCommFinalize(ncclComm_t comm);\n\n/* Frees local resources associated with communicator object. */\nncclResult_t  ncclCommDestroy(ncclComm_t comm);\nncclResult_t pncclCommDestroy(ncclComm_t comm);\n\n/* Frees resources associated with communicator object and aborts any operations\n * that might still be running on the device. */\nncclResult_t  ncclCommAbort(ncclComm_t comm);\nncclResult_t pncclCommAbort(ncclComm_t comm);\n\n/* Creates one or more communicators from an existing one.\n * Ranks with the same color will end up in the same communicator.\n * Within the new communicator, key will be used to order ranks.\n * NCCL_SPLIT_NOCOLOR as color will indicate the rank will not be part of any group\n * and will therefore return a NULL communicator.\n * If config is NULL, the new communicator will inherit the original communicator's\n * configuration*/\nncclResult_t  ncclCommSplit(ncclComm_t comm, int color, int key, ncclComm_t *newcomm, ncclConfig_t* config);\nncclResult_t pncclCommSplit(ncclComm_t comm, int color, int key, ncclComm_t *newcomm, ncclConfig_t* config);\n\n/* Returns a string for each error code. */\nconst char*  ncclGetErrorString(ncclResult_t result);\nconst char* pncclGetErrorString(ncclResult_t result);\n\n/* Returns a human-readable message of the last error that occurred. */\nconst char*  ncclGetLastError(ncclComm_t comm);\nconst char* pncclGetLastError(ncclComm_t comm);\n\n/* Checks whether the comm has encountered any asynchronous errors */\nncclResult_t  ncclCommGetAsyncError(ncclComm_t comm, ncclResult_t *asyncError);\nncclResult_t pncclCommGetAsyncError(ncclComm_t comm, ncclResult_t *asyncError);\n\n/* Gets the number of ranks in the communicator clique. */\nncclResult_t  ncclCommCount(const ncclComm_t comm, int* count);\nncclResult_t pncclCommCount(const ncclComm_t comm, int* count);\n\n/* Returns the cuda device number associated with the communicator. */\nncclResult_t  ncclCommCuDevice(const ncclComm_t comm, int* device);\nncclResult_t pncclCommCuDevice(const ncclComm_t comm, int* device);\n\n/* Returns the user-ordered \"rank\" associated with the communicator. */\nncclResult_t  ncclCommUserRank(const ncclComm_t comm, int* rank);\nncclResult_t pncclCommUserRank(const ncclComm_t comm, int* rank);\n\n/* Register CUDA buffer for zero-copy operation */\nncclResult_t  ncclCommRegister(const ncclComm_t comm, void* buff, size_t size, void** handle);\nncclResult_t pncclCommRegister(const ncclComm_t comm, void* buff, size_t size, void** handle);\n\n/* Deregister CUDA buffer */\nncclResult_t  ncclCommDeregister(const ncclComm_t comm, void* handle);\nncclResult_t pncclCommDeregister(const ncclComm_t comm, void* handle);\n\n/* Reduction operation selector */\ntypedef enum { ncclNumOps_dummy = 5 } ncclRedOp_dummy_t;\ntypedef enum { ncclSum        = 0,\n               ncclProd       = 1,\n               ncclMax        = 2,\n               ncclMin        = 3,\n               ncclAvg        = 4,\n               /* ncclNumOps: The number of built-in ncclRedOp_t values. Also\n                * serves as the least possible value for dynamic ncclRedOp_t's\n                * as constructed by ncclRedOpCreate*** functions. */\n               ncclNumOps     = 5,\n               /* ncclMaxRedOp: The largest valid value for ncclRedOp_t.\n                * It is defined to be the largest signed value (since compilers\n                * are permitted to use signed enums) that won't grow\n                * sizeof(ncclRedOp_t) when compared to previous NCCL versions to\n                * maintain ABI compatibility. */\n               ncclMaxRedOp   = 0x7fffffff>>(32-8*sizeof(ncclRedOp_dummy_t))\n             } ncclRedOp_t;\n\n/* Data types */\ntypedef enum { ncclInt8       = 0, ncclChar       = 0,\n               ncclUint8      = 1,\n               ncclInt32      = 2, ncclInt        = 2,\n               ncclUint32     = 3,\n               ncclInt64      = 4,\n               ncclUint64     = 5,\n               ncclFloat16    = 6, ncclHalf       = 6,\n               ncclFloat32    = 7, ncclFloat      = 7,\n               ncclFloat64    = 8, ncclDouble     = 8,\n#if defined(__CUDA_BF16_TYPES_EXIST__)\n               ncclBfloat16   = 9,\n               ncclNumTypes   = 10\n#else\n               ncclNumTypes   = 9\n#endif\n} ncclDataType_t;\n\n/* ncclScalarResidence_t: Location and dereferencing logic for scalar arguments. */\ntypedef enum {\n  /* ncclScalarDevice: The scalar is in device-visible memory and will be\n   * dereferenced while the collective is running. */\n  ncclScalarDevice = 0,\n\n  /* ncclScalarHostImmediate: The scalar is in host-visible memory and will be\n   * dereferenced before the ncclRedOpCreate***() function returns. */\n  ncclScalarHostImmediate = 1\n} ncclScalarResidence_t;\n\n/*\n * ncclRedOpCreatePreMulSum\n *\n * Creates a new reduction operator which pre-multiplies input values by a given\n * scalar locally before reducing them with peer values via summation. For use\n * only with collectives launched against *comm* and *datatype*. The\n * *residence* argument indicates how/when the memory pointed to by *scalar*\n * will be dereferenced. Upon return, the newly created operator's handle\n * is stored in *op*.\n */\nncclResult_t  ncclRedOpCreatePreMulSum(ncclRedOp_t *op, void *scalar, ncclDataType_t datatype, ncclScalarResidence_t residence, ncclComm_t comm);\nncclResult_t pncclRedOpCreatePreMulSum(ncclRedOp_t *op, void *scalar, ncclDataType_t datatype, ncclScalarResidence_t residence, ncclComm_t comm);\n\n/*\n * ncclRedOpDestroy\n *\n * Destroys the reduction operator *op*. The operator must have been created by\n * ncclRedOpCreatePreMul with the matching communicator *comm*. An operator may be\n * destroyed as soon as the last NCCL function which is given that operator returns.\n */\nncclResult_t ncclRedOpDestroy(ncclRedOp_t op, ncclComm_t comm);\nncclResult_t pncclRedOpDestroy(ncclRedOp_t op, ncclComm_t comm);\n\n/*\n * Collective communication operations\n *\n * Collective communication operations must be called separately for each\n * communicator in a communicator clique.\n *\n * They return when operations have been enqueued on the CUDA stream.\n *\n * Since they may perform inter-CPU synchronization, each call has to be done\n * from a different thread or process, or need to use Group Semantics (see\n * below).\n */\n\n/*\n * Reduce\n *\n * Reduces data arrays of length count in sendbuff into recvbuff using op\n * operation.\n * recvbuff may be NULL on all calls except for root device.\n * root is the rank (not the CUDA device) where data will reside after the\n * operation is complete.\n *\n * In-place operation will happen if sendbuff == recvbuff.\n */\nncclResult_t  ncclReduce(const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype,\n    ncclRedOp_t op, int root, ncclComm_t comm, cudaStream_t stream);\nncclResult_t pncclReduce(const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype,\n    ncclRedOp_t op, int root, ncclComm_t comm, cudaStream_t stream);\n\n/*\n * (deprecated) Broadcast (in-place)\n *\n * Copies count values from root to all other devices.\n * root is the rank (not the CUDA device) where data resides before the\n * operation is started.\n *\n * This operation is implicitely in place.\n */\nncclResult_t  ncclBcast(void* buff, size_t count, ncclDataType_t datatype, int root,\n    ncclComm_t comm, cudaStream_t stream);\nncclResult_t pncclBcast(void* buff, size_t count, ncclDataType_t datatype, int root,\n    ncclComm_t comm, cudaStream_t stream);\n\n/*\n * Broadcast\n *\n * Copies count values from root to all other devices.\n * root is the rank (not the CUDA device) where data resides before the\n * operation is started.\n *\n * In-place operation will happen if sendbuff == recvbuff.\n */\nncclResult_t  ncclBroadcast(const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype, int root,\n    ncclComm_t comm, cudaStream_t stream);\nncclResult_t pncclBroadcast(const void* sendbuff, void* recvbuff, size_t count, ncclDataType_t datatype, int root,\n    ncclComm_t comm, cudaStream_t stream);\n\n/*\n * All-Reduce\n *\n * Reduces data arrays of length count in sendbuff using op operation, and\n * leaves identical copies of result on each recvbuff.\n *\n * In-place operation will happen if sendbuff == recvbuff.\n */\nncclResult_t  ncclAllReduce(const void* sendbuff, void* recvbuff, size_t count,\n    ncclDataType_t datatype, ncclRedOp_t op, ncclComm_t comm, cudaStream_t stream);\nncclResult_t pncclAllReduce(const void* sendbuff, void* recvbuff, size_t count,\n    ncclDataType_t datatype, ncclRedOp_t op, ncclComm_t comm, cudaStream_t stream);\n\n/*\n * Reduce-Scatter\n *\n * Reduces data in sendbuff using op operation and leaves reduced result\n * scattered over the devices so that recvbuff on rank i will contain the i-th\n * block of the result.\n * Assumes sendcount is equal to nranks*recvcount, which means that sendbuff\n * should have a size of at least nranks*recvcount elements.\n *\n * In-place operations will happen if recvbuff == sendbuff + rank * recvcount.\n */\nncclResult_t  ncclReduceScatter(const void* sendbuff, void* recvbuff,\n    size_t recvcount, ncclDataType_t datatype, ncclRedOp_t op, ncclComm_t comm,\n    cudaStream_t stream);\nncclResult_t pncclReduceScatter(const void* sendbuff, void* recvbuff,\n    size_t recvcount, ncclDataType_t datatype, ncclRedOp_t op, ncclComm_t comm,\n    cudaStream_t stream);\n\n/*\n * All-Gather\n *\n * Each device gathers sendcount values from other GPUs into recvbuff,\n * receiving data from rank i at offset i*sendcount.\n * Assumes recvcount is equal to nranks*sendcount, which means that recvbuff\n * should have a size of at least nranks*sendcount elements.\n *\n * In-place operations will happen if sendbuff == recvbuff + rank * sendcount.\n */\nncclResult_t  ncclAllGather(const void* sendbuff, void* recvbuff, size_t sendcount,\n    ncclDataType_t datatype, ncclComm_t comm, cudaStream_t stream);\nncclResult_t pncclAllGather(const void* sendbuff, void* recvbuff, size_t sendcount,\n    ncclDataType_t datatype, ncclComm_t comm, cudaStream_t stream);\n\n/*\n * Send\n *\n * Send data from sendbuff to rank peer.\n *\n * Rank peer needs to call ncclRecv with the same datatype and the same count from this\n * rank.\n *\n * This operation is blocking for the GPU. If multiple ncclSend and ncclRecv operations\n * need to progress concurrently to complete, they must be fused within a ncclGroupStart/\n * ncclGroupEnd section.\n */\nncclResult_t  ncclSend(const void* sendbuff, size_t count, ncclDataType_t datatype, int peer,\n    ncclComm_t comm, cudaStream_t stream);\nncclResult_t pncclSend(const void* sendbuff, size_t count, ncclDataType_t datatype, int peer,\n    ncclComm_t comm, cudaStream_t stream);\n\n/*\n * Receive\n *\n * Receive data from rank peer into recvbuff.\n *\n * Rank peer needs to call ncclSend with the same datatype and the same count to this\n * rank.\n *\n * This operation is blocking for the GPU. If multiple ncclSend and ncclRecv operations\n * need to progress concurrently to complete, they must be fused within a ncclGroupStart/\n * ncclGroupEnd section.\n */\nncclResult_t pncclRecv(void* recvbuff, size_t count, ncclDataType_t datatype, int peer,\n    ncclComm_t comm, cudaStream_t stream);\nncclResult_t  ncclRecv(void* recvbuff, size_t count, ncclDataType_t datatype, int peer,\n    ncclComm_t comm, cudaStream_t stream);\n\n/*\n * Group semantics\n *\n * When managing multiple GPUs from a single thread, and since NCCL collective\n * calls may perform inter-CPU synchronization, we need to \"group\" calls for\n * different ranks/devices into a single call.\n *\n * Grouping NCCL calls as being part of the same collective operation is done\n * using ncclGroupStart and ncclGroupEnd. ncclGroupStart will enqueue all\n * collective calls until the ncclGroupEnd call, which will wait for all calls\n * to be complete. Note that for collective communication, ncclGroupEnd only\n * guarantees that the operations are enqueued on the streams, not that\n * the operation is effectively done.\n *\n * Both collective communication and ncclCommInitRank can be used in conjunction\n * of ncclGroupStart/ncclGroupEnd, but not together.\n *\n * Group semantics also allow to fuse multiple operations on the same device\n * to improve performance (for aggregated collective calls), or to permit\n * concurrent progress of multiple send/receive operations.\n */\n\n/*\n * Group Start\n *\n * Start a group call. All calls to NCCL until ncclGroupEnd will be fused into\n * a single NCCL operation. Nothing will be started on the CUDA stream until\n * ncclGroupEnd.\n */\nncclResult_t  ncclGroupStart();\nncclResult_t pncclGroupStart();\n\n/*\n * Group End\n *\n * End a group call. Start a fused NCCL operation consisting of all calls since\n * ncclGroupStart. Operations on the CUDA stream depending on the NCCL operations\n * need to be called after ncclGroupEnd.\n */\nncclResult_t  ncclGroupEnd();\nncclResult_t pncclGroupEnd();\n\n#ifdef __cplusplus\n} // end extern \"C\"\n#endif\n\n#endif // end include guard\n","uri":"file:///root/code/nccl-trace/include/nccl.h","version":1}}}

I[15:12:27.190] <-- textDocument/didOpen
V[15:12:27.190] >>> {"id":0,"jsonrpc":"2.0","method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"}}

I[15:12:27.191] Enqueueing 157 commands for indexing
I[15:12:27.191] ASTWorker building file /root/code/nccl-trace/src/include/device.h version 1 with command inferred from init.cc
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -I. -I/root/code/nccl-trace/include -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -Iinclude -x c++-header -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/include/device.h
I[15:12:27.191] ASTWorker building file /root/code/nccl-trace/src/init.cc version 1 with command 
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -I. -I/root/code/nccl-trace/include -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -Iinclude -o /root/code/nccl-trace/obj/init.o -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/init.cc
I[15:12:27.191] ASTWorker building file /root/code/nccl-trace/src/enqueue.cc version 1 with command 
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -I. -I/root/code/nccl-trace/include -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -Iinclude -o /root/code/nccl-trace/obj/enqueue.o -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/enqueue.cc
V[15:12:27.191] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
V[15:12:27.191] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
V[15:12:27.192] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
V[15:12:27.192] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
V[15:12:27.192] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name topo.h -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -I . -I /root/code/nccl-trace/include -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I include -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -fdeprecated-macro -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c++-header /root/code/nccl-trace/src/graph/topo.h
V[15:12:27.192] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name profile.cc -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -I . -I /root/code/nccl-trace/include -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I include -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -fdeprecated-macro -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c++ /root/code/nccl-trace/src/profile.cc
V[15:12:27.192] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
V[15:12:27.192] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name device.h -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -I . -I /root/code/nccl-trace/include -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I include -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -fdeprecated-macro -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c++-header /root/code/nccl-trace/src/include/device.h
V[15:12:27.192] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name init.cc -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -I . -I /root/code/nccl-trace/include -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I include -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -fdeprecated-macro -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c++ /root/code/nccl-trace/src/init.cc
I[15:12:27.192] ASTWorker building file /root/code/nccl-trace/include/nccl.h version 1 with command inferred from ruler/nccl_tp.c
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -x c-header -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/include/nccl.h
I[15:12:27.192] --> textDocument/clangd.fileStatus
I[15:12:27.192] --> textDocument/clangd.fileStatus
I[15:12:27.192] --> textDocument/clangd.fileStatus
V[15:12:27.193] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/profile.cc"}}

I[15:12:27.193] --> textDocument/clangd.fileStatus
V[15:12:27.193] Building first preamble for /root/code/nccl-trace/src/profile.cc version 1
V[15:12:27.193] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/graph/topo.h"}}

V[15:12:27.193] Building first preamble for /root/code/nccl-trace/src/graph/topo.h version 1
V[15:12:27.193] <<< {"id":0,"jsonrpc":"2.0","result":null}

I[15:12:27.193] <-- reply(0)
I[15:12:27.193] --> $/progress
V[15:12:27.193] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name enqueue.cc -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -I . -I /root/code/nccl-trace/include -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I include -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -fdeprecated-macro -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c++ /root/code/nccl-trace/src/enqueue.cc
V[15:12:27.193] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/include/device.h"}}

V[15:12:27.193] Building first preamble for /root/code/nccl-trace/src/include/device.h version 1
V[15:12:27.193] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/init.cc"}}

V[15:12:27.194] Building first preamble for /root/code/nccl-trace/src/init.cc version 1
I[15:12:27.193] --> textDocument/clangd.fileStatus
V[15:12:27.194] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/enqueue.cc"}}

V[15:12:27.194] Building first preamble for /root/code/nccl-trace/src/enqueue.cc version 1
V[15:12:27.195] >>> {"jsonrpc":"2.0","method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"begin","percentage":0,"title":"indexing"}}}

I[15:12:27.195] --> $/progress
V[15:12:27.195] >>> {"jsonrpc":"2.0","method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"report","message":"0/1","percentage":0}}}

V[15:12:27.194] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
I[15:12:27.194] ASTWorker building file /root/code/nccl-trace/src/device/common.h version 1 with command inferred from common.cu
[/root/code/nccl-trace/src/device]
/usr/local/cuda-12.2/bin/nvcc -c -O3 -I. -I.. -I/root/code/nccl-trace/include -I../include -dc -x cuda -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/device/common.h
I[15:12:27.196] ASTWorker building file /root/code/nccl-trace/src/include/nccl_tp.h version 1 with command inferred from ruler/nccl_tp.c
[/root/code/nccl-trace/src]
/usr/bin/g++ --driver-mode=g++ -c -DCUDA_MAJOR=12 -DCUDA_MINOR=2 -fPIC -fvisibility=hidden -Wall -Wno-unused-function -Wno-sign-compare -Wvla -I /usr/local/cuda/include -g -I/opt/x-ray/third-party/include -O3 -g -DENABLE_TRACE -DPROFAPI -x c-header -I/usr/include/c++/9 -I/opt/x-ray/third-party/include -I/opt/x-ray/third-party/rdma-core/include --no-cuda-version-check -resource-dir=/root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -- /root/code/nccl-trace/src/include/nccl_tp.h
V[15:12:27.200] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name nccl.h -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c-header /root/code/nccl-trace/include/nccl.h
V[15:12:27.203] Ignored diagnostic. argument unused during compilation: '--no-cuda-version-check'
I[15:12:27.205] --> textDocument/clangd.fileStatus
V[15:12:27.205] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/include/nccl.h"}}

V[15:12:27.205] Building first preamble for /root/code/nccl-trace/include/nccl.h version 1
V[15:12:27.208] <<< {"id":1,"jsonrpc":"2.0","method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.208] <-- textDocument/documentSymbol(1)
V[15:12:27.208] <<< {"id":2,"jsonrpc":"2.0","method":"textDocument/documentLink","params":{"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.208] <-- textDocument/documentLink(2)
V[15:12:27.208] <<< {"id":3,"jsonrpc":"2.0","method":"textDocument/inlayHint","params":{"range":{"end":{"character":0,"line":248},"start":{"character":0,"line":127}},"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.208] <-- textDocument/inlayHint(3)
V[15:12:27.208] <<< {"id":4,"jsonrpc":"2.0","method":"textDocument/codeAction","params":{"context":{"diagnostics":[],"triggerKind":2},"range":{"end":{"character":28,"line":191},"start":{"character":28,"line":191}},"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.208] <-- textDocument/codeAction(4)
V[15:12:27.209] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name nccl_tp.h -mrelocation-model pic -pic-level 2 -fhalf-no-semantic-interposition -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src -fcoverage-compilation-dir=/root/code/nccl-trace/src -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -D CUDA_MAJOR=12 -D CUDA_MINOR=2 -I /usr/local/cuda/include -I /opt/x-ray/third-party/include -D ENABLE_TRACE -D PROFAPI -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -O3 -Wall -Wno-unused-function -Wno-sign-compare -Wvla -ferror-limit 19 -fvisibility=hidden -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -vectorize-loops -vectorize-slp -no-round-trip-args -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c-header /root/code/nccl-trace/src/include/nccl_tp.h
I[15:12:27.209] --> textDocument/clangd.fileStatus
V[15:12:27.210] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/include/nccl_tp.h"}}

V[15:12:27.210] Building first preamble for /root/code/nccl-trace/src/include/nccl_tp.h version 1
V[15:12:27.231] Ignored diagnostic. argument unused during compilation: '-dc'
V[15:12:27.231] Driver produced command: cc1 -cc1 -triple x86_64-unknown-linux-gnu -target-sdk-version=12.2 -fcuda-allow-variadic-functions -aux-triple nvptx64-nvidia-cuda -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name common.h -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debugger-tuning=gdb -fdebug-compilation-dir=/root/code/nccl-trace/src/device -fcoverage-compilation-dir=/root/code/nccl-trace/src/device -resource-dir /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18 -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include/cuda_wrappers -include __clang_cuda_runtime_wrapper.h -I . -I .. -I /root/code/nccl-trace/include -I ../include -I /usr/include/c++/9 -I /opt/x-ray/third-party/include -I /opt/x-ray/third-party/rdma-core/include -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../include/c++ -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/x86_64-linux-gnu -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/backward -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -internal-isystem /root/.vscode-server/data/User/globalStorage/llvm-vs-code-extensions.vscode-clangd/install/18.1.3/clangd_18.1.3/lib/clang/18/include -internal-isystem /usr/local/include -internal-isystem /usr/lib/gcc/x86_64-linux-gnu/10/../../../../x86_64-linux-gnu/include -internal-externc-isystem /usr/include/x86_64-linux-gnu -internal-externc-isystem /include -internal-externc-isystem /usr/include -internal-isystem /usr/local/cuda-12.2/include -O3 -fdeprecated-macro -ferror-limit 19 -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -vectorize-loops -vectorize-slp -no-round-trip-args -cuid=9fe210f94a98f676 -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x cuda /root/code/nccl-trace/src/device/common.h
I[15:12:27.232] --> textDocument/clangd.fileStatus
V[15:12:27.233] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Update","uri":"file:///root/code/nccl-trace/src/device/common.h"}}

V[15:12:27.233] Building first preamble for /root/code/nccl-trace/src/device/common.h version 1
I[15:12:27.351] Built preamble of size 611440 for file /root/code/nccl-trace/include/nccl.h version 1 in 0.14 seconds
I[15:12:27.351] --> workspace/semanticTokens/refresh(1)
V[15:12:27.351] >>> {"id":1,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

I[15:12:27.351] --> textDocument/clangd.fileStatus
I[15:12:27.351] Indexing c17 standard library in the context of /root/code/nccl-trace/include/nccl.h
V[15:12:27.351] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Build AST","uri":"file:///root/code/nccl-trace/include/nccl.h"}}

V[15:12:27.352] <<< {"id":1,"jsonrpc":"2.0","result":null}

I[15:12:27.352] <-- reply(1)
V[15:12:27.376] <<< {"id":5,"jsonrpc":"2.0","method":"textDocument/semanticTokens/full","params":{"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.376] <-- textDocument/semanticTokens/full(5)
I[15:12:27.376] Built preamble of size 651152 for file /root/code/nccl-trace/src/include/nccl_tp.h version 1 in 0.17 seconds
I[15:12:27.376] --> workspace/semanticTokens/refresh(2)
I[15:12:27.376] --> textDocument/clangd.fileStatus
V[15:12:27.376] >>> {"id":2,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:27.376] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Build AST","uri":"file:///root/code/nccl-trace/src/include/nccl_tp.h"}}

V[15:12:27.377] <<< {"id":2,"jsonrpc":"2.0","result":null}

I[15:12:27.377] <-- reply(2)
V[15:12:27.393] Trying to fix unresolved name "ncclKernelRecord_t" in scopes: []
V[15:12:27.409] <<< {"id":6,"jsonrpc":"2.0","method":"textDocument/foldingRange","params":{"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.409] <-- textDocument/foldingRange(6)
V[15:12:27.442] Ignored diagnostic. /usr/include/c++/9/complex.h:29:10:'bits/c++config.h' file not found
V[15:12:27.494] indexed preamble AST for /root/code/nccl-trace/include/nccl.h version 1:
  symbol slab: 2439 symbols, 1215104 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:27.499] indexed preamble AST for /root/code/nccl-trace/src/include/nccl_tp.h version 1:
  symbol slab: 2343 symbols, 654288 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:27.502] <<< {"id":7,"jsonrpc":"2.0","method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:27.502] <-- textDocument/documentSymbol(7)
V[15:12:27.511] indexed file AST for /root/code/nccl-trace/src/include/nccl_tp.h version 1:
  symbol slab: 55 symbols, 21072 bytes
  ref slab: 71 symbols, 309 refs, 15488 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:27.511] Build dynamic index for main-file symbols with estimated memory usage of 64328 bytes
I[15:12:27.511] --> textDocument/publishDiagnostics
V[15:12:27.511] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[],"uri":"file:///root/code/nccl-trace/src/include/nccl_tp.h","version":1}}

I[15:12:27.511] --> textDocument/inactiveRegions
V[15:12:27.511] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":0,"line":129},"start":{"character":0,"line":90}}],"textDocument":{"uri":"file:///root/code/nccl-trace/src/include/nccl_tp.h"}}}

I[15:12:27.513] --> textDocument/clangd.fileStatus
V[15:12:27.513] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/include/nccl_tp.h"}}

V[15:12:27.515] indexed file AST for /root/code/nccl-trace/include/nccl.h version 1:
  symbol slab: 148 symbols, 50840 bytes
  ref slab: 158 symbols, 364 refs, 22656 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:27.515] Build dynamic index for main-file symbols with estimated memory usage of 199168 bytes
I[15:12:27.516] --> textDocument/publishDiagnostics
V[15:12:27.516] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"expected_either","message":"Expected identifier or '('","range":{"end":{"character":25,"line":93},"start":{"character":23,"line":93}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected","message":"Expected ')'","range":{"end":{"character":25,"line":93},"start":{"character":23,"line":93}},"relatedInformation":[{"location":{"range":{"end":{"character":23,"line":93},"start":{"character":22,"line":93}},"uri":"file:///root/code/nccl-trace/include/nccl.h"},"message":"To match this '('"}],"severity":1,"source":"clang"},{"code":"-Wimplicit-int","message":"Type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int (fix available)","range":{"end":{"character":23,"line":95},"start":{"character":2,"line":95}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected_either","message":"Expected identifier or '('","range":{"end":{"character":25,"line":97},"start":{"character":23,"line":97}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected","message":"Expected ')'","range":{"end":{"character":25,"line":97},"start":{"character":23,"line":97}},"relatedInformation":[{"location":{"range":{"end":{"character":23,"line":97},"start":{"character":22,"line":97}},"uri":"file:///root/code/nccl-trace/include/nccl.h"},"message":"To match this '('"}],"severity":1,"source":"clang"},{"code":"-Wimplicit-int","message":"Type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int (fix available)","range":{"end":{"character":20,"line":102},"start":{"character":2,"line":102}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected_either","message":"Expected identifier or '('","range":{"end":{"character":25,"line":104},"start":{"character":23,"line":104}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected","message":"Expected ')'","range":{"end":{"character":25,"line":104},"start":{"character":23,"line":104}},"relatedInformation":[{"location":{"range":{"end":{"character":23,"line":104},"start":{"character":22,"line":104}},"uri":"file:///root/code/nccl-trace/include/nccl.h"},"message":"To match this '('"}],"severity":1,"source":"clang"},{"code":"-Wimplicit-int","message":"Type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int (fix available)","range":{"end":{"character":21,"line":111},"start":{"character":2,"line":111}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected_either","message":"Expected identifier or '('","range":{"end":{"character":25,"line":113},"start":{"character":23,"line":113}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected","message":"Expected ')'","range":{"end":{"character":25,"line":113},"start":{"character":23,"line":113}},"relatedInformation":[{"location":{"range":{"end":{"character":23,"line":113},"start":{"character":22,"line":113}},"uri":"file:///root/code/nccl-trace/include/nccl.h"},"message":"To match this '('"}],"severity":1,"source":"clang"},{"code":"-Wimplicit-int","message":"Type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int (fix available)","range":{"end":{"character":21,"line":117},"start":{"character":2,"line":117}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected_either","message":"Expected identifier or '('","range":{"end":{"character":25,"line":119},"start":{"character":23,"line":119}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected","message":"Expected ')'","range":{"end":{"character":25,"line":119},"start":{"character":23,"line":119}},"relatedInformation":[{"location":{"range":{"end":{"character":23,"line":119},"start":{"character":22,"line":119}},"uri":"file:///root/code/nccl-trace/include/nccl.h"},"message":"To match this '('"}],"severity":1,"source":"clang"},{"code":"-Wimplicit-int","message":"Type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int (fix available)","range":{"end":{"character":17,"line":126},"start":{"character":2,"line":126}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected_either","message":"Expected identifier or '('","range":{"end":{"character":25,"line":128},"start":{"character":23,"line":128}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"expected","message":"Expected ')'","range":{"end":{"character":25,"line":128},"start":{"character":23,"line":128}},"relatedInformation":[{"location":{"range":{"end":{"character":23,"line":128},"start":{"character":22,"line":128}},"uri":"file:///root/code/nccl-trace/include/nccl.h"},"message":"To match this '('"}],"severity":1,"source":"clang"},{"code":"-Wimplicit-int","message":"Type specifier missing, defaults to 'int'; ISO C99 and later do not support implicit int (fix available)","range":{"end":{"character":20,"line":147},"start":{"character":2,"line":147}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"unknown_typename","message":"Unknown type name 'ncclKernelRecord_t'","range":{"end":{"character":20,"line":155},"start":{"character":2,"line":155}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"-Wvla","message":"Variable length array used","range":{"end":{"character":43,"line":155},"start":{"character":29,"line":155}},"relatedInformation":[],"severity":2,"source":"clang"},{"code":"fatal_too_many_errors","message":"Too many errors emitted, stopping now","range":{"end":{"character":0,"line":0},"start":{"character":0,"line":0}},"relatedInformation":[],"severity":1,"source":"clang"}],"uri":"file:///root/code/nccl-trace/include/nccl.h","version":1}}

I[15:12:27.516] --> textDocument/inactiveRegions
V[15:12:27.516] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":12,"line":26},"start":{"character":0,"line":26}},{"end":{"character":4,"line":145},"start":{"character":0,"line":143}},{"end":{"character":34,"line":295},"start":{"character":0,"line":294}},{"end":{"character":19,"line":515},"start":{"character":0,"line":515}}],"textDocument":{"uri":"file:///root/code/nccl-trace/include/nccl.h"}}}

I[15:12:27.517] --> textDocument/clangd.fileStatus
V[15:12:27.517] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/include/nccl.h"}}

V[15:12:27.626] Build dynamic index for header symbols with estimated memory usage of 2906060 bytes
V[15:12:27.656] Build dynamic index for header symbols with estimated memory usage of 4997172 bytes
V[15:12:27.668] BackgroundIndex: building version 1 after loading index from disk
I[15:12:27.688] --> reply:textDocument/foldingRange(6) 278 ms
V[15:12:27.689] >>> {"id":6,"jsonrpc":"2.0","result":[{"endLine":59,"kind":"region","startCharacter":54,"startLine":51},{"endCharacter":2,"endLine":57,"kind":"region","startCharacter":52,"startLine":54},{"endLine":72,"kind":"region","startCharacter":28,"startLine":68},{"endCharacter":2,"endLine":70,"kind":"region","startCharacter":38,"startLine":69},{"endLine":92,"kind":"region","startCharacter":32,"startLine":78},{"endCharacter":2,"endLine":89,"kind":"region","startCharacter":21,"startLine":81},{"endLine":99,"kind":"region","startCharacter":43,"startLine":96},{"endLine":108,"kind":"region","startCharacter":49,"startLine":103},{"endLine":121,"kind":"region","startCharacter":51,"startLine":118},{"endLine":129,"kind":"region","startCharacter":71,"startLine":127},{"endLine":136,"kind":"region","startCharacter":57,"startLine":131},{"endLine":141,"kind":"region","startCharacter":75,"startLine":139},{"endLine":148,"kind":"region","startCharacter":61,"startLine":143},{"endLine":153,"kind":"region","startCharacter":79,"startLine":151},{"endLine":160,"kind":"region","startCharacter":65,"startLine":155},{"endLine":165,"kind":"region","startCharacter":78,"startLine":163},{"endLine":172,"kind":"region","startCharacter":67,"startLine":167},{"endLine":252,"kind":"region","startCharacter":47,"startLine":175},{"endCharacter":2,"endLine":188,"kind":"region","startCharacter":84,"startLine":183},{"endCharacter":4,"endLine":187,"kind":"region","startCharacter":38,"startLine":185},{"endCharacter":2,"endLine":201,"kind":"region","startCharacter":24,"startLine":199},{"endCharacter":2,"endLine":224,"kind":"region","startCharacter":24,"startLine":213},{"endCharacter":4,"endLine":223,"kind":"region","startCharacter":71,"startLine":214},{"endCharacter":6,"endLine":217,"kind":"region","startCharacter":41,"startLine":215},{"endCharacter":2,"endLine":232,"kind":"region","startCharacter":27,"startLine":230},{"endCharacter":2,"endLine":240,"kind":"region","startCharacter":66,"startLine":238},{"endLine":279,"kind":"region","startCharacter":60,"startLine":264},{"endLine":303,"kind":"region","startCharacter":51,"startLine":282},{"endCharacter":2,"endLine":286,"kind":"region","startCharacter":59,"startLine":285},{"endCharacter":2,"endLine":299,"kind":"region","startCharacter":10,"startLine":287},{"endCharacter":4,"endLine":293,"kind":"region","startCharacter":29,"startLine":289},{"endCharacter":4,"endLine":298,"kind":"region","startCharacter":25,"startLine":296},{"endLine":393,"kind":"region","startCharacter":99,"startLine":306},{"endCharacter":2,"endLine":309,"kind":"region","startCharacter":17,"startLine":307},{"endCharacter":2,"endLine":313,"kind":"region","startCharacter":33,"startLine":311},{"endCharacter":2,"endLine":329,"kind":"region","startCharacter":44,"startLine":325},{"endCharacter":4,"endLine":328,"kind":"region","startCharacter":43,"startLine":326},{"endCharacter":2,"endLine":378,"kind":"region","startCharacter":53,"startLine":368},{"endCharacter":2,"endLine":381,"kind":"region","startCharacter":10,"startLine":379},{"endCharacter":2,"endLine":387,"kind":"region","startCharacter":37,"startLine":384},{"endLine":469,"kind":"region","startCharacter":51,"startLine":396},{"endCharacter":2,"endLine":412,"kind":"region","startCharacter":46,"startLine":411},{"endCharacter":2,"endLine":420,"kind":"region","startCharacter":61,"startLine":418},{"endCharacter":2,"endLine":427,"kind":"region","startCharacter":65,"startLine":424},{"endCharacter":2,"endLine":433,"kind":"region","startCharacter":10,"startLine":428},{"endCharacter":2,"endLine":445,"kind":"region","startCharacter":48,"startLine":442},{"endCharacter":2,"endLine":460,"kind":"region","startCharacter":39,"startLine":448},{"endCharacter":4,"endLine":459,"kind":"region","startCharacter":54,"startLine":458},{"endLine":482,"kind":"region","startCharacter":27,"startLine":474},{"endCharacter":2,"endLine":481,"kind":"region","startCharacter":57,"startLine":476},{"endLine":522,"kind":"region","startCharacter":99,"startLine":485},{"endCharacter":2,"endLine":519,"kind":"region","startCharacter":3,"startLine":506},{"endCharacter":4,"endLine":518,"kind":"region","startCharacter":72,"startLine":514},{"endCharacter":89,"endLine":517,"kind":"region","startCharacter":11,"startLine":515},{"endLine":540,"kind":"region","startCharacter":110,"startLine":525},{"endCharacter":2,"endLine":534,"kind":"region","startCharacter":34,"startLine":532},{"endCharacter":2,"endLine":538,"kind":"region","startCharacter":32,"startLine":537},{"endLine":580,"kind":"region","startCharacter":61,"startLine":554},{"endCharacter":2,"endLine":562,"kind":"region","startCharacter":44,"startLine":561},{"endCharacter":2,"endLine":574,"kind":"region","startCharacter":39,"startLine":572},{"endCharacter":2,"endLine":576,"kind":"region","startCharacter":10,"startLine":575},{"endLine":609,"kind":"region","startCharacter":61,"startLine":588},{"endCharacter":2,"endLine":598,"kind":"region","startCharacter":51,"startLine":596},{"endCharacter":2,"endLine":601,"kind":"region","startCharacter":49,"startLine":600},{"endCharacter":2,"endLine":607,"kind":"region","startCharacter":42,"startLine":606},{"endLine":823,"kind":"region","startCharacter":109,"startLine":612},{"endCharacter":2,"endLine":626,"kind":"region","startCharacter":27,"startLine":624},{"endCharacter":2,"endLine":639,"kind":"region","startCharacter":3,"startLine":631},{"endCharacter":4,"endLine":638,"kind":"region","startCharacter":55,"startLine":633},{"endCharacter":2,"endLine":699,"kind":"region","startCharacter":104,"startLine":644},{"endCharacter":4,"endLine":697,"kind":"region","startCharacter":44,"startLine":649},{"endCharacter":6,"endLine":664,"kind":"region","startCharacter":41,"startLine":657},{"endCharacter":10,"endLine":663,"kind":"region","startCharacter":101,"startLine":661},{"endCharacter":6,"endLine":677,"kind":"region","startCharacter":46,"startLine":668},{"endCharacter":8,"endLine":676,"kind":"region","startCharacter":32,"startLine":669},{"endCharacter":10,"endLine":675,"kind":"region","startCharacter":77,"startLine":673},{"endCharacter":6,"endLine":687,"kind":"region","startCharacter":18,"startLine":680},{"endCharacter":8,"endLine":684,"kind":"region","startCharacter":31,"startLine":681},{"endCharacter":6,"endLine":696,"kind":"region","startCharacter":14,"startLine":688},{"endCharacter":8,"endLine":694,"kind":"region","startCharacter":30,"startLine":693},{"endCharacter":2,"endLine":722,"kind":"region","startCharacter":10,"startLine":700},{"endCharacter":4,"endLine":720,"kind":"region","startCharacter":47,"startLine":708},{"endCharacter":6,"endLine":715,"kind":"region","startCharacter":46,"startLine":711},{"endCharacter":6,"endLine":719,"kind":"region","startCharacter":19,"startLine":718},{"endCharacter":2,"endLine":726,"kind":"region","startCharacter":14,"startLine":725},{"endCharacter":2,"endLine":761,"kind":"region","startCharacter":10,"startLine":727},{"endCharacter":4,"endLine":760,"kind":"region","startCharacter":8,"startLine":728},{"endCharacter":6,"endLine":746,"kind":"region","startCharacter":19,"startLine":738},{"endCharacter":8,"endLine":745,"kind":"region","startCharacter":49,"startLine":739},{"endCharacter":10,"endLine":744,"kind":"region","startCharacter":37,"startLine":740},{"endCharacter":6,"endLine":756,"kind":"region","startCharacter":47,"startLine":749},{"endCharacter":8,"endLine":755,"kind":"region","startCharacter":35,"startLine":750},{"endCharacter":2,"endLine":772,"kind":"region","startCharacter":45,"startLine":769},{"endCharacter":2,"endLine":780,"kind":"region","startCharacter":45,"startLine":778},{"endCharacter":2,"endLine":785,"kind":"region","startCharacter":45,"startLine":783},{"endCharacter":2,"endLine":793,"kind":"region","startCharacter":45,"startLine":791},{"endCharacter":2,"endLine":799,"kind":"region","startCharacter":45,"startLine":797},{"endCharacter":2,"endLine":807,"kind":"region","startCharacter":14,"startLine":806},{"endCharacter":2,"endLine":812,"kind":"region","startCharacter":46,"startLine":810},{"endLine":885,"kind":"region","startCharacter":46,"startLine":835},{"endCharacter":2,"endLine":852,"kind":"region","startCharacter":42,"startLine":851},{"endCharacter":2,"endLine":870,"kind":"region","startCharacter":42,"startLine":858},{"endCharacter":4,"endLine":869,"kind":"region","startCharacter":59,"startLine":865},{"endCharacter":6,"endLine":867,"kind":"region","startCharacter":28,"startLine":866},{"endCharacter":2,"endLine":878,"kind":"region","startCharacter":20,"startLine":876},{"endLine":1426,"kind":"region","startCharacter":95,"startLine":894},{"endCharacter":2,"endLine":917,"kind":"region","startCharacter":20,"startLine":909},{"endCharacter":2,"endLine":922,"kind":"region","startCharacter":24,"startLine":920},{"endCharacter":2,"endLine":947,"kind":"region","startCharacter":36,"startLine":941},{"endCharacter":4,"endLine":946,"kind":"region","startCharacter":146,"startLine":943},{"endCharacter":2,"endLine":956,"kind":"region","startCharacter":71,"startLine":952},{"endCharacter":2,"endLine":1009,"kind":"region","startCharacter":6,"startLine":959},{"endCharacter":4,"endLine":987,"kind":"region","startCharacter":38,"startLine":966},{"endCharacter":6,"endLine":976,"kind":"region","startCharacter":75,"startLine":968},{"endCharacter":8,"endLine":975,"kind":"region","startCharacter":50,"startLine":973},{"endCharacter":6,"endLine":986,"kind":"region","startCharacter":33,"startLine":979},{"endCharacter":8,"endLine":985,"kind":"region","startCharacter":46,"startLine":980},{"endCharacter":10,"endLine":984,"kind":"region","startCharacter":69,"startLine":982},{"endCharacter":4,"endLine":1000,"kind":"region","startCharacter":101,"startLine":995},{"endCharacter":55,"endLine":997,"kind":"region","startCharacter":11,"startLine":996},{"endCharacter":2,"endLine":1030,"kind":"region","startCharacter":38,"startLine":1028},{"endCharacter":2,"endLine":1041,"kind":"region","startCharacter":29,"startLine":1034},{"endCharacter":4,"endLine":1040,"kind":"region","startCharacter":32,"startLine":1036},{"endCharacter":6,"endLine":1039,"kind":"region","startCharacter":44,"startLine":1038},{"endCharacter":2,"endLine":1071,"kind":"region","startCharacter":29,"startLine":1069},{"endCharacter":2,"endLine":1081,"kind":"region","startCharacter":26,"startLine":1079},{"endCharacter":2,"endLine":1089,"kind":"region","startCharacter":51,"startLine":1087},{"endCharacter":2,"endLine":1103,"kind":"region","startCharacter":45,"startLine":1095},{"endCharacter":2,"endLine":1125,"kind":"region","startCharacter":32,"startLine":1115},{"endCharacter":4,"endLine":1123,"kind":"region","startCharacter":31,"startLine":1119},{"endCharacter":2,"endLine":1133,"kind":"region","startCharacter":38,"startLine":1130},{"endCharacter":2,"endLine":1139,"kind":"region","startCharacter":38,"startLine":1136},{"endCharacter":2,"endLine":1144,"kind":"region","startCharacter":38,"startLine":1142},{"endCharacter":2,"endLine":1158,"kind":"region","startCharacter":89,"startLine":1153},{"endCharacter":68,"endLine":1155,"kind":"region","startCharacter":9,"startLine":1154},{"endCharacter":2,"endLine":1177,"kind":"region","startCharacter":32,"startLine":1166},{"endCharacter":4,"endLine":1176,"kind":"region","startCharacter":47,"startLine":1169},{"endCharacter":2,"endLine":1186,"kind":"region","startCharacter":40,"startLine":1183},{"endCharacter":2,"endLine":1207,"kind":"region","startCharacter":34,"startLine":1190},{"endCharacter":4,"endLine":1194,"kind":"region","startCharacter":46,"startLine":1192},{"endCharacter":4,"endLine":1206,"kind":"region","startCharacter":40,"startLine":1197},{"endCharacter":6,"endLine":1201,"kind":"region","startCharacter":68,"startLine":1198},{"endCharacter":6,"endLine":1205,"kind":"region","startCharacter":46,"startLine":1203},{"endCharacter":2,"endLine":1222,"kind":"region","startCharacter":41,"startLine":1218},{"endCharacter":2,"endLine":1240,"kind":"region","startCharacter":39,"startLine":1235},{"endCharacter":2,"endLine":1245,"kind":"region","startCharacter":46,"startLine":1243},{"endCharacter":2,"endLine":1252,"kind":"region","startCharacter":44,"startLine":1250},{"endCharacter":2,"endLine":1254,"kind":"region","startCharacter":10,"startLine":1253},{"endCharacter":2,"endLine":1262,"kind":"region","startCharacter":41,"startLine":1258},{"endCharacter":2,"endLine":1272,"kind":"region","startCharacter":41,"startLine":1268},{"endCharacter":2,"endLine":1287,"kind":"region","startCharacter":46,"startLine":1280},{"endCharacter":4,"endLine":1284,"kind":"region","startCharacter":43,"startLine":1281},{"endCharacter":2,"endLine":1341,"kind":"region","startCharacter":6,"startLine":1300},{"endCharacter":4,"endLine":1339,"kind":"region","startCharacter":39,"startLine":1315},{"endCharacter":6,"endLine":1329,"kind":"region","startCharacter":46,"startLine":1322},{"endCharacter":6,"endLine":1338,"kind":"region","startCharacter":22,"startLine":1336},{"endCharacter":2,"endLine":1365,"kind":"region","startCharacter":33,"startLine":1344},{"endCharacter":4,"endLine":1362,"kind":"region","startCharacter":37,"startLine":1348},{"endCharacter":6,"endLine":1355,"kind":"region","startCharacter":55,"startLine":1351},{"endCharacter":8,"endLine":1354,"kind":"region","startCharacter":76,"startLine":1353},{"endCharacter":6,"endLine":1361,"kind":"region","startCharacter":55,"startLine":1357},{"endCharacter":8,"endLine":1360,"kind":"region","startCharacter":76,"startLine":1359},{"endCharacter":2,"endLine":1381,"kind":"region","startCharacter":34,"startLine":1374},{"endCharacter":4,"endLine":1380,"kind":"region","startCharacter":34,"startLine":1377},{"endCharacter":2,"endLine":1397,"kind":"region","startCharacter":29,"startLine":1384},{"endCharacter":4,"endLine":1388,"kind":"region","startCharacter":47,"startLine":1387},{"endCharacter":4,"endLine":1390,"kind":"region","startCharacter":12,"startLine":1389},{"endCharacter":4,"endLine":1396,"kind":"region","startCharacter":66,"startLine":1395},{"endLine":1446,"kind":"region","startCharacter":33,"startLine":1436},{"endLine":1451,"kind":"region","startCharacter":33,"startLine":1449},{"endLine":1499,"kind":"region","startCharacter":159,"startLine":1456},{"endCharacter":2,"endLine":1484,"kind":"region","startCharacter":44,"startLine":1475},{"endCharacter":2,"endLine":1488,"kind":"region","startCharacter":36,"startLine":1487},{"endLine":1599,"kind":"region","startCharacter":69,"startLine":1502},{"endCharacter":2,"endLine":1522,"kind":"region","startCharacter":62,"startLine":1520},{"endCharacter":2,"endLine":1532,"kind":"region","startCharacter":20,"startLine":1525},{"endCharacter":2,"endLine":1535,"kind":"region","startCharacter":10,"startLine":1533},{"endCharacter":2,"endLine":1543,"kind":"region","startCharacter":20,"startLine":1541},{"endCharacter":2,"endLine":1546,"kind":"region","startCharacter":10,"startLine":1544},{"endCharacter":2,"endLine":1553,"kind":"region","startCharacter":20,"startLine":1552},{"endCharacter":2,"endLine":1564,"kind":"region","startCharacter":20,"startLine":1560},{"endCharacter":2,"endLine":1567,"kind":"region","startCharacter":10,"startLine":1565},{"endCharacter":2,"endLine":1572,"kind":"region","startCharacter":20,"startLine":1570},{"endCharacter":2,"endLine":1575,"kind":"region","startCharacter":10,"startLine":1573},{"endCharacter":2,"endLine":1586,"kind":"region","startCharacter":41,"startLine":1581},{"endCharacter":2,"endLine":1593,"kind":"region","startCharacter":21,"startLine":1591},{"endLine":1679,"kind":"region","startCharacter":56,"startLine":1609},{"endCharacter":2,"endLine":1626,"kind":"region","startCharacter":81,"startLine":1625},{"endCharacter":2,"endLine":1629,"kind":"region","startCharacter":61,"startLine":1627},{"endCharacter":2,"endLine":1634,"kind":"region","startCharacter":44,"startLine":1633},{"endCharacter":2,"endLine":1639,"kind":"region","startCharacter":44,"startLine":1638},{"endCharacter":2,"endLine":1648,"kind":"region","startCharacter":27,"startLine":1645},{"endCharacter":2,"endLine":1650,"kind":"region","startCharacter":10,"startLine":1649},{"endCharacter":2,"endLine":1655,"kind":"region","startCharacter":47,"startLine":1654},{"endCharacter":2,"endLine":1661,"kind":"region","startCharacter":43,"startLine":1659},{"endCharacter":2,"endLine":1666,"kind":"region","startCharacter":43,"startLine":1664},{"endCharacter":2,"endLine":1671,"kind":"region","startCharacter":52,"startLine":1669},{"endCharacter":2,"endLine":1676,"kind":"region","startCharacter":69,"startLine":1674},{"endLine":1685,"kind":"region","startCharacter":77,"startLine":1682},{"endLine":1770,"kind":"region","startCharacter":76,"startLine":1688},{"endCharacter":2,"endLine":1717,"kind":"region","startCharacter":15,"startLine":1697},{"endCharacter":4,"endLine":1704,"kind":"region","startCharacter":49,"startLine":1701},{"endCharacter":4,"endLine":1709,"kind":"region","startCharacter":62,"startLine":1708},{"endCharacter":4,"endLine":1716,"kind":"region","startCharacter":62,"startLine":1712},{"endCharacter":2,"endLine":1724,"kind":"region","startCharacter":133,"startLine":1721},{"endCharacter":2,"endLine":1730,"kind":"region","startCharacter":108,"startLine":1727},{"endCharacter":61,"endLine":1736,"kind":"region","startCharacter":6,"startLine":1733},{"endCharacter":2,"endLine":1740,"kind":"region","startCharacter":64,"startLine":1737},{"endCharacter":2,"endLine":1746,"kind":"region","startCharacter":139,"startLine":1743},{"endLine":1824,"kind":"region","startCharacter":142,"startLine":1773},{"endCharacter":2,"endLine":1780,"kind":"region","startCharacter":27,"startLine":1778},{"endCharacter":2,"endLine":1794,"kind":"region","startCharacter":53,"startLine":1791},{"endCharacter":2,"endLine":1821,"kind":"region","startCharacter":13,"startLine":1818},{"endLine":1831,"kind":"region","startCharacter":1,"startLine":1828},{"endLine":1836,"kind":"region","startCharacter":59,"startLine":1833},{"endLine":1852,"kind":"region","startCharacter":97,"startLine":1840},{"endLine":1910,"kind":"region","startCharacter":79,"startLine":1856},{"endCharacter":2,"endLine":1863,"kind":"region","startCharacter":60,"startLine":1862},{"endCharacter":2,"endLine":1874,"kind":"region","startCharacter":17,"startLine":1871},{"endCharacter":2,"endLine":1896,"kind":"region","startCharacter":16,"startLine":1878},{"endCharacter":4,"endLine":1893,"kind":"region","startCharacter":36,"startLine":1880},{"endCharacter":6,"endLine":1884,"kind":"region","startCharacter":54,"startLine":1882},{"endCharacter":6,"endLine":1890,"kind":"region","startCharacter":38,"startLine":1888},{"endCharacter":2,"endLine":1904,"kind":"region","startCharacter":30,"startLine":1902},{"endLine":1920,"kind":"region","startCharacter":77,"startLine":1913},{"endCharacter":2,"endLine":1916,"kind":"region","startCharacter":69,"startLine":1914},{"endLine":1948,"kind":"region","startCharacter":125,"startLine":1924},{"endLine":1983,"kind":"region","startCharacter":64,"startLine":1951},{"endCharacter":2,"endLine":1960,"kind":"region","startCharacter":34,"startLine":1959},{"endCharacter":2,"endLine":1967,"kind":"region","startCharacter":39,"startLine":1965},{"endCharacter":2,"endLine":1972,"kind":"region","startCharacter":37,"startLine":1971},{"endCharacter":2,"endLine":1976,"kind":"region","startCharacter":34,"startLine":1975},{"endLine":2006,"kind":"region","startCharacter":50,"startLine":1986},{"endCharacter":2,"endLine":1992,"kind":"region","startCharacter":34,"startLine":1991},{"endCharacter":2,"endLine":1997,"kind":"region","startCharacter":28,"startLine":1995},{"endCharacter":2,"endLine":2003,"kind":"region","startCharacter":34,"startLine":2002},{"endLine":2027,"kind":"region","startCharacter":68,"startLine":2009},{"endCharacter":2,"endLine":2018,"kind":"region","startCharacter":19,"startLine":2017},{"endCharacter":2,"endLine":2021,"kind":"region","startCharacter":10,"startLine":2019},{"endLine":2057,"kind":"region","startCharacter":48,"startLine":2031},{"endCharacter":2,"endLine":2044,"kind":"region","startCharacter":29,"startLine":2042},{"endLine":2141,"kind":"region","startCharacter":50,"startLine":2060},{"endCharacter":2,"endLine":2070,"kind":"region","startCharacter":121,"startLine":2067},{"endCharacter":2,"endLine":2135,"kind":"region","startCharacter":33,"startLine":2073},{"endCharacter":4,"endLine":2134,"kind":"region","startCharacter":35,"startLine":2081},{"endCharacter":6,"endLine":2098,"kind":"region","startCharacter":29,"startLine":2087},{"endCharacter":8,"endLine":2097,"kind":"region","startCharacter":52,"startLine":2092},{"endCharacter":6,"endLine":2121,"kind":"region","startCharacter":29,"startLine":2113},{"endCharacter":8,"endLine":2120,"kind":"region","startCharacter":65,"startLine":2119},{"endCharacter":6,"endLine":2133,"kind":"region","startCharacter":29,"startLine":2126},{"endCharacter":8,"endLine":2132,"kind":"region","startCharacter":63,"startLine":2131},{"endLine":2170,"kind":"region","startCharacter":47,"startLine":2145},{"endCharacter":2,"endLine":2148,"kind":"region","startCharacter":21,"startLine":2146},{"endCharacter":2,"endLine":2161,"kind":"region","startCharacter":91,"startLine":2159},{"endLine":2202,"kind":"region","startCharacter":45,"startLine":2174},{"endCharacter":2,"endLine":2177,"kind":"region","startCharacter":21,"startLine":2175},{"endCharacter":2,"endLine":2192,"kind":"region","startCharacter":31,"startLine":2191},{"endLine":2267,"kind":"region","startCharacter":108,"startLine":2206},{"endCharacter":2,"endLine":2219,"kind":"region","startCharacter":36,"startLine":2218},{"endCharacter":2,"endLine":2242,"kind":"region","startCharacter":10,"startLine":2220},{"endCharacter":4,"endLine":2227,"kind":"region","startCharacter":34,"startLine":2223},{"endCharacter":4,"endLine":2233,"kind":"region","startCharacter":12,"startLine":2228},{"endCharacter":4,"endLine":2236,"kind":"region","startCharacter":25,"startLine":2235},{"endCharacter":4,"endLine":2238,"kind":"region","startCharacter":12,"startLine":2237},{"endCharacter":2,"endLine":2264,"kind":"region","startCharacter":18,"startLine":2259},{"endCharacter":4,"endLine":2262,"kind":"region","startCharacter":43,"startLine":2260},{"endLine":2282,"kind":"region","startCharacter":51,"startLine":2271},{"endCharacter":2,"endLine":2281,"kind":"region","startCharacter":17,"startLine":2272},{"endLine":2290,"kind":"region","startCharacter":47,"startLine":2289},{"endLine":2300,"kind":"region","startCharacter":79,"startLine":2294},{"endLine":2314,"kind":"region","startCharacter":63,"startLine":2304},{"endLine":2327,"kind":"region","startCharacter":66,"startLine":2318},{"endLine":2340,"kind":"region","startCharacter":65,"startLine":2331},{"endLine":2417,"kind":"region","startCharacter":53,"startLine":2344},{"endCharacter":2,"endLine":2407,"kind":"region","startCharacter":18,"startLine":2370},{"endCharacter":4,"endLine":2405,"kind":"region","startCharacter":36,"startLine":2398},{"endCharacter":6,"endLine":2404,"kind":"region","startCharacter":96,"startLine":2400},{"endLine":2453,"kind":"region","startCharacter":38,"startLine":2421},{"endCharacter":2,"endLine":2442,"kind":"region","startCharacter":18,"startLine":2440},{"endCharacter":72,"endLine":3,"kind":"comment","startCharacter":2,"startLine":0},{"endCharacter":37,"endLine":181,"kind":"comment","startCharacter":4,"startLine":180},{"endCharacter":67,"endLine":332,"kind":"comment","startCharacter":4,"startLine":331},{"endCharacter":45,"endLine":494,"kind":"comment","startCharacter":4,"startLine":492},{"endCharacter":97,"endLine":647,"kind":"comment","startCharacter":6,"startLine":646},{"endCharacter":61,"endLine":690,"kind":"comment","startCharacter":10,"startLine":689},{"endCharacter":15,"endLine":730,"kind":"comment","startCharacter":8,"startLine":729},{"endCharacter":136,"endLine":804,"kind":"comment","startCharacter":4,"startLine":803},{"endCharacter":72,"endLine":862,"kind":"comment","startCharacter":6,"startLine":861},{"endCharacter":43,"endLine":897,"kind":"comment","startCharacter":4,"startLine":895},{"endCharacter":26,"endLine":1026,"kind":"comment","startCharacter":4,"startLine":1025},{"endCharacter":54,"endLine":1185,"kind":"comment","startCharacter":6,"startLine":1184},{"endCharacter":27,"endLine":1233,"kind":"comment","startCharacter":4,"startLine":1232},{"endCharacter":74,"endLine":1314,"kind":"comment","startCharacter":6,"startLine":1313},{"endCharacter":82,"endLine":1393,"kind":"comment","startCharacter":6,"startLine":1392},{"endCharacter":97,"endLine":1401,"kind":"comment","startCharacter":4,"startLine":1400},{"endCharacter":26,"endLine":1408,"kind":"comment","startCharacter":4,"startLine":1407},{"endCharacter":26,"endLine":1414,"kind":"comment","startCharacter":4,"startLine":1413},{"endCharacter":56,"endLine":1519,"kind":"comment","startCharacter":4,"startLine":1518},{"endCharacter":38,"endLine":2110,"kind":"comment","startCharacter":8,"startLine":2101},{"endCharacter":1,"endLine":2286,"kind":"comment","startCharacter":2,"startLine":2285}]}

I[15:12:27.714] Indexed c17 standard library (incomplete due to errors): 2470 symbols, 31 filtered
V[15:12:27.749] Build dynamic index for header symbols with estimated memory usage of 5670684 bytes
I[15:12:27.757] Built preamble of size 2454596 for file /root/code/nccl-trace/src/include/device.h version 1 in 0.56 seconds
I[15:12:27.758] --> workspace/semanticTokens/refresh(3)
V[15:12:27.758] >>> {"id":3,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:27.758] <<< {"id":3,"jsonrpc":"2.0","result":null}

I[15:12:27.758] <-- reply(3)
I[15:12:27.758] Indexing c++17 standard library in the context of /root/code/nccl-trace/src/include/device.h
V[15:12:27.765] Ignored diagnostic. /usr/include/c++/9/bits/localefwd.h:39:10:'bits/c++config.h' file not found
V[15:12:27.800] indexed file AST for /root/code/nccl-trace/src/include/device.h version 1:
  symbol slab: 229 symbols, 61440 bytes
  ref slab: 279 symbols, 458 refs, 28800 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:27.800] Build dynamic index for main-file symbols with estimated memory usage of 377672 bytes
I[15:12:27.800] --> textDocument/publishDiagnostics
V[15:12:27.800] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"pp_file_not_found","message":"In included file: 'bits/c++config.h' file not found","range":{"end":{"character":17,"line":9},"start":{"character":9,"line":9}},"relatedInformation":[{"location":{"range":{"end":{"character":27,"line":67},"start":{"character":9,"line":67}},"uri":"file:///usr/include/c%2B%2B/9/utility"},"message":"Error occurred here"}],"severity":1,"source":"clang"}],"uri":"file:///root/code/nccl-trace/src/include/device.h","version":1}}

I[15:12:27.800] --> textDocument/inactiveRegions
V[15:12:27.800] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":60,"line":61},"start":{"character":0,"line":59}},{"end":{"character":42,"line":184},"start":{"character":0,"line":184}},{"end":{"character":38,"line":351},"start":{"character":0,"line":351}},{"end":{"character":44,"line":448},"start":{"character":2,"line":448}}],"textDocument":{"uri":"file:///root/code/nccl-trace/src/include/device.h"}}}

I[15:12:27.801] --> textDocument/clangd.fileStatus
V[15:12:27.801] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/include/device.h"}}

V[15:12:27.853] indexed preamble AST for /root/code/nccl-trace/src/include/device.h version 1:
  symbol slab: 4040 symbols, 1875625 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:27.906] Build dynamic index for header symbols with estimated memory usage of 6809901 bytes
V[15:12:27.971] BackgroundIndex: serving version 1 (34666713 bytes)
I[15:12:27.992] --> $/progress
V[15:12:27.992] >>> {"jsonrpc":"2.0","method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"report","message":"0/1","percentage":0}}}

I[15:12:27.992] --> $/progress
V[15:12:27.992] >>> {"jsonrpc":"2.0","method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}}}

I[15:12:28.005] Built preamble of size 4105216 for file /root/code/nccl-trace/src/graph/topo.h version 1 in 0.81 seconds
I[15:12:28.006] --> workspace/semanticTokens/refresh(4)
V[15:12:28.006] >>> {"id":4,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:28.007] <<< {"id":4,"jsonrpc":"2.0","result":null}

I[15:12:28.007] <-- reply(4)
V[15:12:28.060] indexed file AST for /root/code/nccl-trace/src/graph/topo.h version 1:
  symbol slab: 117 symbols, 31360 bytes
  ref slab: 131 symbols, 244 refs, 14464 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:28.060] Build dynamic index for main-file symbols with estimated memory usage of 458448 bytes
I[15:12:28.060] --> textDocument/publishDiagnostics
V[15:12:28.060] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"pp_file_not_found","message":"In included file: 'bits/c++config.h' file not found","range":{"end":{"character":18,"line":9},"start":{"character":9,"line":9}},"relatedInformation":[{"location":{"range":{"end":{"character":27,"line":67},"start":{"character":9,"line":67}},"uri":"file:///usr/include/c%2B%2B/9/utility"},"message":"Error occurred here"}],"severity":1,"source":"clang"},{"code":"unused-includes","codeDescription":{"href":"https://clangd.llvm.org/guides/include-cleaner"},"message":"Included header core.h is not used directly (fix available)","range":{"end":{"character":17,"line":10},"start":{"character":0,"line":10}},"relatedInformation":[],"severity":2,"source":"clangd","tags":[1]}],"uri":"file:///root/code/nccl-trace/src/graph/topo.h","version":1}}

I[15:12:28.060] --> textDocument/inactiveRegions
V[15:12:28.060] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[],"textDocument":{"uri":"file:///root/code/nccl-trace/src/graph/topo.h"}}}

I[15:12:28.061] --> textDocument/clangd.fileStatus
V[15:12:28.061] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/graph/topo.h"}}

I[15:12:28.121] Indexed c++17 standard library (incomplete due to errors): 3121 symbols, 705 filtered
V[15:12:28.153] Dropped diagnostic: /usr/include/c++/9/cmath: 'bits/c++config.h' file not found
I[15:12:28.155] Built preamble of size 6416312 for file /root/code/nccl-trace/src/device/common.h version 1 in 0.92 seconds
I[15:12:28.155] --> workspace/semanticTokens/refresh(5)
I[15:12:28.155] --> textDocument/clangd.fileStatus
V[15:12:28.155] >>> {"id":5,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:28.155] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Build AST","uri":"file:///root/code/nccl-trace/src/device/common.h"}}

V[15:12:28.163] <<< {"id":5,"jsonrpc":"2.0","result":null}

I[15:12:28.164] <-- reply(5)
V[15:12:28.165] Build dynamic index for header symbols with estimated memory usage of 7636561 bytes
V[15:12:28.212] indexed file AST for /root/code/nccl-trace/src/device/common.h version 1:
  symbol slab: 39 symbols, 13264 bytes
  ref slab: 98 symbols, 251 refs, 11392 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:28.213] Build dynamic index for main-file symbols with estimated memory usage of 500184 bytes
I[15:12:28.213] --> textDocument/publishDiagnostics
V[15:12:28.213] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"cuda_extern_shared","message":"__shared__ variable 'ncclShmem' cannot be 'extern'","range":{"end":{"character":17,"line":46},"start":{"character":7,"line":46}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"cuda_extern_shared","message":"__shared__ variable 'ncclShmemPerWarp' cannot be 'extern'","range":{"end":{"character":19,"line":50},"start":{"character":9,"line":50}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"vla_decl_in_file_scope","message":"Variable length array declaration not allowed at file scope","range":{"end":{"character":43,"line":50},"start":{"character":27,"line":50}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":75,"line":90},"start":{"character":67,"line":90}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'elems' in 'ncclWork'","range":{"end":{"character":95,"line":90},"start":{"character":90,"line":90}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'elems' in 'ncclWork'","range":{"end":{"character":79,"line":195},"start":{"character":74,"line":195}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":86,"line":197},"start":{"character":78,"line":197}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"unused-includes","codeDescription":{"href":"https://clangd.llvm.org/guides/include-cleaner"},"message":"Included header collectives.h is not used directly (fixes available)","range":{"end":{"character":24,"line":9},"start":{"character":0,"line":9}},"relatedInformation":[],"severity":2,"source":"clangd","tags":[1]},{"code":"unused-includes","codeDescription":{"href":"https://clangd.llvm.org/guides/include-cleaner"},"message":"Included header op128.h is not used directly (fixes available)","range":{"end":{"character":18,"line":11},"start":{"character":0,"line":11}},"relatedInformation":[],"severity":2,"source":"clangd","tags":[1]}],"uri":"file:///root/code/nccl-trace/src/device/common.h","version":1}}

I[15:12:28.213] --> textDocument/inactiveRegions
V[15:12:28.213] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":87,"line":48},"start":{"character":0,"line":48}}],"textDocument":{"uri":"file:///root/code/nccl-trace/src/device/common.h"}}}

I[15:12:28.214] --> textDocument/clangd.fileStatus
V[15:12:28.214] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/device/common.h"}}

V[15:12:28.266] indexed preamble AST for /root/code/nccl-trace/src/graph/topo.h version 1:
  symbol slab: 10601 symbols, 4539013 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 14 relations, 296 bytes
I[15:12:28.275] Built preamble of size 6877284 for file /root/code/nccl-trace/src/profile.cc version 1 in 1.08 seconds
I[15:12:28.276] --> workspace/semanticTokens/refresh(6)
V[15:12:28.276] >>> {"id":6,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:28.289] <<< {"id":6,"jsonrpc":"2.0","result":null}

I[15:12:28.289] <-- reply(6)
V[15:12:28.314] indexed preamble AST for /root/code/nccl-trace/src/device/common.h version 1:
  symbol slab: 8591 symbols, 3803307 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:28.346] indexed file AST for /root/code/nccl-trace/src/profile.cc version 1:
  symbol slab: 46 symbols, 18984 bytes
  ref slab: 173 symbols, 704 refs, 30848 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:28.353] Build dynamic index for header symbols with estimated memory usage of 12957552 bytes
V[15:12:28.353] Build dynamic index for main-file symbols with estimated memory usage of 602224 bytes
I[15:12:28.354] --> textDocument/publishDiagnostics
V[15:12:28.355] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"pp_file_not_found","message":"In included file: 'bits/c++config.h' file not found","range":{"end":{"character":10,"line":0},"start":{"character":9,"line":0}},"relatedInformation":[{"location":{"range":{"end":{"character":27,"line":40},"start":{"character":9,"line":40}},"uri":"file:///usr/include/c%2B%2B/9/cstdlib"},"message":"Error occurred here"}],"severity":1,"source":"clang"},{"code":"-Wunused-but-set-variable","message":"Variable 'total' set but not used","range":{"end":{"character":18,"line":38},"start":{"character":13,"line":38}},"relatedInformation":[],"severity":2,"source":"clang","tags":[1]},{"code":"unused-includes","codeDescription":{"href":"https://clangd.llvm.org/guides/include-cleaner"},"message":"Included header checks.h is not used directly (fix available)","range":{"end":{"character":19,"line":6},"start":{"character":0,"line":6}},"relatedInformation":[],"severity":2,"source":"clangd","tags":[1]}],"uri":"file:///root/code/nccl-trace/src/profile.cc","version":1}}

I[15:12:28.355] --> textDocument/inactiveRegions
V[15:12:28.356] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":102,"line":201},"start":{"character":0,"line":201}}],"textDocument":{"uri":"file:///root/code/nccl-trace/src/profile.cc"}}}

I[15:12:28.360] --> textDocument/clangd.fileStatus
V[15:12:28.361] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/profile.cc"}}

I[15:12:28.381] Built preamble of size 7799808 for file /root/code/nccl-trace/src/init.cc version 1 in 1.19 seconds
I[15:12:28.381] --> workspace/semanticTokens/refresh(7)
V[15:12:28.381] >>> {"id":7,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:28.382] <<< {"id":7,"jsonrpc":"2.0","result":null}

I[15:12:28.382] <-- reply(7)
V[15:12:28.404] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.404] Dex query tree: (LIMIT 10000 (& T=fre T=ree S= ?=Restricted For Code Completion))
V[15:12:28.404] Dex query tree: (LIMIT 10000 (& T=fre T=ree ?=Restricted For Code Completion S=))
I[15:12:28.410] Built preamble of size 7816328 for file /root/code/nccl-trace/src/enqueue.cc version 1 in 1.22 seconds
I[15:12:28.410] --> workspace/semanticTokens/refresh(8)
I[15:12:28.411] --> textDocument/clangd.fileStatus
V[15:12:28.411] >>> {"id":8,"jsonrpc":"2.0","method":"workspace/semanticTokens/refresh","params":null}

V[15:12:28.411] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"parsing includes, running Build AST","uri":"file:///root/code/nccl-trace/src/enqueue.cc"}}

V[15:12:28.411] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.412] <<< {"id":8,"jsonrpc":"2.0","result":null}

I[15:12:28.412] <-- reply(8)
V[15:12:28.412] Build dynamic index for header symbols with estimated memory usage of 13210738 bytes
V[15:12:28.413] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.415] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.416] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.418] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.420] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.421] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.423] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.426] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.428] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.432] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.435] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.437] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.438] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.439] Trying to fix unresolved name "min" in scopes: [std::]
V[15:12:28.439] Dex query tree: (LIMIT 10000 (& T=min S=std:: ?=Restricted For Code Completion))
V[15:12:28.439] Dex query tree: (LIMIT 10000 (& S=std:: T=min ?=Restricted For Code Completion))
V[15:12:28.440] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.444] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.445] Trying to fix unresolved name "max" in scopes: [std::]
V[15:12:28.445] Dex query tree: (LIMIT 10000 (& S=std:: T=max ?=Restricted For Code Completion))
V[15:12:28.445] Dex query tree: (LIMIT 10000 (& S=std:: T=max ?=Restricted For Code Completion))
V[15:12:28.447] Trying to fix unresolved name "min" in scopes: [std::]
V[15:12:28.452] Trying to fix unresolved name "min" in scopes: [std::]
V[15:12:28.491] Trying to fix unresolved name "min" in scopes: [std::]
V[15:12:28.491] Dex query tree: (LIMIT 10000 (& T=min S=std:: ?=Restricted For Code Completion))
V[15:12:28.491] Dex query tree: (LIMIT 10000 (& S=std:: T=min ?=Restricted For Code Completion))
V[15:12:28.510] Trying to fix unresolved name "free" in scopes: []
V[15:12:28.594] indexed preamble AST for /root/code/nccl-trace/src/profile.cc version 1:
  symbol slab: 16905 symbols, 6751457 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 12 relations, 296 bytes
V[15:12:28.638] indexed file AST for /root/code/nccl-trace/src/enqueue.cc version 1:
  symbol slab: 62 symbols, 18600 bytes
  ref slab: 620 symbols, 3297 refs, 143790 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:28.640] Build dynamic index for main-file symbols with estimated memory usage of 883574 bytes
I[15:12:28.640] --> textDocument/publishDiagnostics
V[15:12:28.640] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"pp_file_not_found","message":"In included file: 'bits/c++config.h' file not found","range":{"end":{"character":20,"line":6},"start":{"character":9,"line":6}},"relatedInformation":[{"location":{"range":{"end":{"character":27,"line":67},"start":{"character":9,"line":67}},"uri":"file:///usr/include/c%2B%2B/9/utility"},"message":"Error occurred here"}],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'elems' in 'ncclWork'","range":{"end":{"character":40,"line":77},"start":{"character":35,"line":77}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'elems' in 'ncclWork'","range":{"end":{"character":17,"line":81},"start":{"character":12,"line":81}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'elems' in 'ncclWork'","range":{"end":{"character":15,"line":87},"start":{"character":10,"line":87}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":48,"line":99},"start":{"character":40,"line":99}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":20,"line":103},"start":{"character":12,"line":103}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":20,"line":104},"start":{"character":12,"line":104}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":18,"line":110},"start":{"character":10,"line":110}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'regElems' in 'ncclWork'","range":{"end":{"character":18,"line":111},"start":{"character":10,"line":111}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":22,"line":120},"start":{"character":14,"line":120}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":18,"line":128},"start":{"character":10,"line":128}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":18,"line":129},"start":{"character":10,"line":129}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":18,"line":131},"start":{"character":10,"line":131}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":28,"line":154},"start":{"character":20,"line":154}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":22,"line":158},"start":{"character":14,"line":158}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'p2pElems' in 'ncclWork'","range":{"end":{"character":18,"line":170},"start":{"character":10,"line":170}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'min' in namespace 'std'","range":{"end":{"character":26,"line":271},"start":{"character":23,"line":271}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'max' in namespace 'std'","range":{"end":{"character":33,"line":308},"start":{"character":30,"line":308}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'min' in namespace 'std'","range":{"end":{"character":26,"line":340},"start":{"character":23,"line":340}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'min' in namespace 'std'","range":{"end":{"character":24,"line":384},"start":{"character":21,"line":384}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"fatal_too_many_errors","message":"Too many errors emitted, stopping now","range":{"end":{"character":0,"line":0},"start":{"character":0,"line":0}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"unused-includes","codeDescription":{"href":"https://clangd.llvm.org/guides/include-cleaner"},"message":"Included header coll_net.h is not used directly (fix available)","range":{"end":{"character":21,"line":8},"start":{"character":0,"line":8}},"relatedInformation":[],"severity":2,"source":"clangd","tags":[1]}],"uri":"file:///root/code/nccl-trace/src/enqueue.cc","version":1}}

I[15:12:28.640] --> textDocument/inactiveRegions
V[15:12:28.641] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":3,"line":1399},"start":{"character":0,"line":1363}}],"textDocument":{"uri":"file:///root/code/nccl-trace/src/enqueue.cc"}}}

I[15:12:28.651] --> textDocument/clangd.fileStatus
V[15:12:28.651] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/enqueue.cc"}}

V[15:12:28.738] Build dynamic index for header symbols with estimated memory usage of 17069444 bytes
V[15:12:28.770] indexed file AST for /root/code/nccl-trace/src/init.cc version 1:
  symbol slab: 133 symbols, 39168 bytes
  ref slab: 703 symbols, 4799 refs, 184632 bytes
  relations slab: 0 relations, 24 bytes
V[15:12:28.773] Build dynamic index for main-file symbols with estimated memory usage of 1332366 bytes
I[15:12:28.773] --> textDocument/publishDiagnostics
V[15:12:28.773] >>> {"jsonrpc":"2.0","method":"textDocument/publishDiagnostics","params":{"diagnostics":[{"code":"pp_file_not_found","message":"In included file: 'bits/c++config.h' file not found","range":{"end":{"character":17,"line":6},"start":{"character":9,"line":6}},"relatedInformation":[{"location":{"range":{"end":{"character":27,"line":67},"start":{"character":9,"line":67}},"uri":"file:///usr/include/c%2B%2B/9/utility"},"message":"Error occurred here"}],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":128},"start":{"character":2,"line":128}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":193},"start":{"character":2,"line":193}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":194},"start":{"character":2,"line":194}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":196},"start":{"character":2,"line":196}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":43,"line":200},"start":{"character":39,"line":200}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":8,"line":201},"start":{"character":4,"line":201}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":203},"start":{"character":2,"line":203}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":204},"start":{"character":2,"line":204}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":205},"start":{"character":2,"line":205}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":43,"line":216},"start":{"character":39,"line":216}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":10,"line":219},"start":{"character":6,"line":219}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":10,"line":223},"start":{"character":6,"line":223}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":8,"line":240},"start":{"character":4,"line":240}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":242},"start":{"character":2,"line":242}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":244},"start":{"character":2,"line":244}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":245},"start":{"character":2,"line":245}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":6,"line":250},"start":{"character":2,"line":250}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"no_member","message":"No member named 'min' in namespace 'std'","range":{"end":{"character":33,"line":574},"start":{"character":30,"line":574}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"undeclared_var_use","message":"Use of undeclared identifier 'free' (fix available)","range":{"end":{"character":10,"line":759},"start":{"character":6,"line":759}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"fatal_too_many_errors","message":"Too many errors emitted, stopping now","range":{"end":{"character":0,"line":0},"start":{"character":0,"line":0}},"relatedInformation":[],"severity":1,"source":"clang"},{"code":"unused-includes","codeDescription":{"href":"https://clangd.llvm.org/guides/include-cleaner"},"message":"Included header errno.h is not used directly (fix available)","range":{"end":{"character":18,"line":21},"start":{"character":0,"line":21}},"relatedInformation":[],"severity":2,"source":"clangd","tags":[1]}],"uri":"file:///root/code/nccl-trace/src/init.cc","version":1}}

I[15:12:28.773] --> textDocument/inactiveRegions
V[15:12:28.773] >>> {"jsonrpc":"2.0","method":"textDocument/inactiveRegions","params":{"regions":[{"end":{"character":90,"line":37},"start":{"character":0,"line":37}},{"end":{"character":56,"line":115},"start":{"character":0,"line":115}},{"end":{"character":1,"line":891},"start":{"character":0,"line":889}}],"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

V[15:12:28.786] ASTWorker running DocumentSymbols on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:28.798] --> reply:textDocument/documentSymbol(1) 1589 ms
V[15:12:28.800] >>> {"id":1,"jsonrpc":"2.0","result":[{"detail":"const char *[5]","kind":13,"name":"ncclFuncStr","range":{"end":{"character":114,"line":40},"start":{"character":0,"line":40}},"selectionRange":{"end":{"character":23,"line":40},"start":{"character":12,"line":40}}},{"detail":"const char *[6]","kind":13,"name":"ncclAlgoStr","range":{"end":{"character":118,"line":41},"start":{"character":0,"line":41}},"selectionRange":{"end":{"character":23,"line":41},"start":{"character":12,"line":41}}},{"detail":"const char *[3]","kind":13,"name":"ncclProtoStr","range":{"end":{"character":74,"line":42},"start":{"character":0,"line":42}},"selectionRange":{"end":{"character":24,"line":42},"start":{"character":12,"line":42}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGroupCudaStream","range":{"end":{"character":10,"line":44},"start":{"character":0,"line":44}},"selectionRange":{"end":{"character":10,"line":44},"start":{"character":0,"line":44}}}],"detail":"(GroupCudaStream, \"GROUP_CUDA_STREAM\", NCCL_GROUP_CUDA_STREAM)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":72,"line":44},"start":{"character":0,"line":44}},"selectionRange":{"end":{"character":10,"line":44},"start":{"character":0,"line":44}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCheckPointers","range":{"end":{"character":10,"line":46},"start":{"character":0,"line":46}},"selectionRange":{"end":{"character":10,"line":46},"start":{"character":0,"line":46}}}],"detail":"(CheckPointers, \"CHECK_POINTERS\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":46,"line":46},"start":{"character":0,"line":46}},"selectionRange":{"end":{"character":10,"line":46},"start":{"character":0,"line":46}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCommBlocking","range":{"end":{"character":10,"line":47},"start":{"character":0,"line":47}},"selectionRange":{"end":{"character":10,"line":47},"start":{"character":0,"line":47}}}],"detail":"(CommBlocking, \"COMM_BLOCKING\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":64,"line":47},"start":{"character":0,"line":47}},"selectionRange":{"end":{"character":10,"line":47},"start":{"character":0,"line":47}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commReclaim","range":{"end":{"character":48,"line":49},"start":{"character":0,"line":49}},"selectionRange":{"end":{"character":31,"line":49},"start":{"character":20,"line":49}}},{"detail":"uint64_t (const ncclUniqueId &)","kind":12,"name":"hashUniqueId","range":{"end":{"character":1,"line":60},"start":{"character":0,"line":51}},"selectionRange":{"end":{"character":28,"line":51},"start":{"character":16,"line":51}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGdrCopyEnable","range":{"end":{"character":10,"line":63},"start":{"character":0,"line":63}},"selectionRange":{"end":{"character":10,"line":63},"start":{"character":0,"line":63}}}],"detail":"(GdrCopyEnable, \"GDRCOPY_ENABLE\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":46,"line":63},"start":{"character":0,"line":63}},"selectionRange":{"end":{"character":10,"line":63},"start":{"character":0,"line":63}}},{"detail":"gdr_t","kind":13,"name":"ncclGdrCopy","range":{"end":{"character":24,"line":66},"start":{"character":0,"line":66}},"selectionRange":{"end":{"character":17,"line":66},"start":{"character":6,"line":66}}},{"detail":"ncclResult_t ()","kind":12,"name":"initGdrCopy","range":{"end":{"character":1,"line":73},"start":{"character":0,"line":68}},"selectionRange":{"end":{"character":24,"line":68},"start":{"character":13,"line":68}}},{"detail":"pthread_mutex_t","kind":13,"name":"initLock","range":{"end":{"character":52,"line":75},"start":{"character":0,"line":75}},"selectionRange":{"end":{"character":24,"line":75},"start":{"character":16,"line":75}}},{"detail":"bool","kind":13,"name":"initialized","range":{"end":{"character":31,"line":76},"start":{"character":0,"line":76}},"selectionRange":{"end":{"character":23,"line":76},"start":{"character":12,"line":76}}},{"detail":"ncclResult_t ()","kind":12,"name":"ncclInit","range":{"end":{"character":1,"line":93},"start":{"character":0,"line":78}},"selectionRange":{"end":{"character":28,"line":78},"start":{"character":20,"line":78}}},{"children":[{"detail":"ncclResult_t (int *)","kind":12,"name":"pncclGetVersion","range":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}},"selectionRange":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}}},{"detail":"ncclResult_t (int *)","kind":12,"name":"ncclGetVersion","range":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}},"selectionRange":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}}}],"detail":"(ncclResult_t, ncclGetVersion, int* version)","kind":21,"name":"NCCL_API","range":{"end":{"character":52,"line":95},"start":{"character":0,"line":95}},"selectionRange":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}}},{"detail":"ncclResult_t (int *)","kind":12,"name":"ncclGetVersion","range":{"end":{"character":1,"line":100},"start":{"character":0,"line":96}},"selectionRange":{"end":{"character":27,"line":96},"start":{"character":13,"line":96}}},{"children":[{"detail":"ncclResult_t (ncclUniqueId *)","kind":12,"name":"pncclGetUniqueId","range":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}},"selectionRange":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}}},{"detail":"ncclResult_t (ncclUniqueId *)","kind":12,"name":"ncclGetUniqueId","range":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}},"selectionRange":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}}}],"detail":"(ncclResult_t, ncclGetUniqueId, ncclUniqueId* out)","kind":21,"name":"NCCL_API","range":{"end":{"character":58,"line":102},"start":{"character":0,"line":102}},"selectionRange":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}}},{"detail":"ncclResult_t (ncclUniqueId *)","kind":12,"name":"ncclGetUniqueId","range":{"end":{"character":1,"line":109},"start":{"character":0,"line":103}},"selectionRange":{"end":{"character":28,"line":103},"start":{"character":13,"line":103}}},{"detail":"void (ncclComm_t)","kind":12,"name":"commPoison","range":{"end":{"character":1,"line":122},"start":{"character":0,"line":118}},"selectionRange":{"end":{"character":32,"line":118},"start":{"character":22,"line":118}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnFree","range":{"end":{"character":1,"line":130},"start":{"character":0,"line":127}},"selectionRange":{"end":{"character":40,"line":127},"start":{"character":20,"line":127}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushFree","range":{"end":{"character":1,"line":137},"start":{"character":0,"line":131}},"selectionRange":{"end":{"character":21,"line":131},"start":{"character":5,"line":131}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnCudaFree","range":{"end":{"character":1,"line":142},"start":{"character":0,"line":139}},"selectionRange":{"end":{"character":44,"line":139},"start":{"character":20,"line":139}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushCudaFree","range":{"end":{"character":1,"line":149},"start":{"character":0,"line":143}},"selectionRange":{"end":{"character":25,"line":143},"start":{"character":5,"line":143}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnCudaHostFree","range":{"end":{"character":1,"line":154},"start":{"character":0,"line":151}},"selectionRange":{"end":{"character":48,"line":151},"start":{"character":20,"line":151}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushCudaHostFree","range":{"end":{"character":1,"line":161},"start":{"character":0,"line":155}},"selectionRange":{"end":{"character":29,"line":155},"start":{"character":5,"line":155}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnCudaGdrFree","range":{"end":{"character":1,"line":166},"start":{"character":0,"line":163}},"selectionRange":{"end":{"character":47,"line":163},"start":{"character":20,"line":163}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushCudaGdrFree","range":{"end":{"character":1,"line":173},"start":{"character":0,"line":167}},"selectionRange":{"end":{"character":28,"line":167},"start":{"character":5,"line":167}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commFree","range":{"end":{"character":1,"line":253},"start":{"character":0,"line":175}},"selectionRange":{"end":{"character":28,"line":175},"start":{"character":20,"line":175}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamDisableGraphHelper","range":{"end":{"character":10,"line":255},"start":{"character":0,"line":255}},"selectionRange":{"end":{"character":10,"line":255},"start":{"character":0,"line":255}}}],"detail":"(DisableGraphHelper, \"GRAPH_HELPER_DISABLE\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":57,"line":255},"start":{"character":0,"line":255}},"selectionRange":{"end":{"character":10,"line":255},"start":{"character":0,"line":255}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGdrCopyFifoEnable","range":{"end":{"character":10,"line":257},"start":{"character":0,"line":257}},"selectionRange":{"end":{"character":10,"line":257},"start":{"character":0,"line":257}}}],"detail":"(GdrCopyFifoEnable, \"GDRCOPY_FIFO_ENABLE\", 1)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":55,"line":257},"start":{"character":0,"line":257}},"selectionRange":{"end":{"character":10,"line":257},"start":{"character":0,"line":257}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamWorkFifoDepth","range":{"end":{"character":10,"line":258},"start":{"character":0,"line":258}},"selectionRange":{"end":{"character":10,"line":258},"start":{"character":0,"line":258}}}],"detail":"(WorkFifoDepth, \"WORK_FIFO_DEPTH\", 64<<10)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":52,"line":258},"start":{"character":0,"line":258}},"selectionRange":{"end":{"character":10,"line":258},"start":{"character":0,"line":258}}},{"detail":"enum ncclLaunchMode","kind":13,"name":"ncclParamLaunchMode","range":{"end":{"character":39,"line":259},"start":{"character":0,"line":259}},"selectionRange":{"end":{"character":39,"line":259},"start":{"character":20,"line":259}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamDmaBufEnable","range":{"end":{"character":10,"line":261},"start":{"character":0,"line":261}},"selectionRange":{"end":{"character":10,"line":261},"start":{"character":0,"line":261}}}],"detail":"(DmaBufEnable, \"DMABUF_ENABLE\", 1)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":44,"line":261},"start":{"character":0,"line":261}},"selectionRange":{"end":{"character":10,"line":261},"start":{"character":0,"line":261}}},{"detail":"ncclResult_t (struct ncclComm *)","kind":12,"name":"dmaBufSupported","range":{"end":{"character":1,"line":280},"start":{"character":0,"line":264}},"selectionRange":{"end":{"character":35,"line":264},"start":{"character":20,"line":264}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommEnsureReady","range":{"end":{"character":1,"line":304},"start":{"character":0,"line":282}},"selectionRange":{"end":{"character":32,"line":282},"start":{"character":13,"line":282}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclComm *, int, int)","kind":12,"name":"commAlloc","range":{"end":{"character":1,"line":394},"start":{"character":0,"line":306}},"selectionRange":{"end":{"character":29,"line":306},"start":{"character":20,"line":306}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"devCommSetup","range":{"end":{"character":1,"line":470},"start":{"character":0,"line":396}},"selectionRange":{"end":{"character":32,"line":396},"start":{"character":20,"line":396}}},{"detail":"void ()","kind":12,"name":"showVersion","range":{"end":{"character":1,"line":483},"start":{"character":0,"line":474}},"selectionRange":{"end":{"character":23,"line":474},"start":{"character":12,"line":474}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclPeerInfo *, uint64_t)","kind":12,"name":"fillInfo","range":{"end":{"character":1,"line":523},"start":{"character":0,"line":485}},"selectionRange":{"end":{"character":28,"line":485},"start":{"character":20,"line":485}}},{"detail":"ncclResult_t (struct ncclComm *, int, int, int, int *)","kind":12,"name":"setupChannel","range":{"end":{"character":1,"line":541},"start":{"character":0,"line":525}},"selectionRange":{"end":{"character":32,"line":525},"start":{"character":20,"line":525}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamBuffSize","range":{"end":{"character":10,"line":546},"start":{"character":0,"line":546}},"selectionRange":{"end":{"character":10,"line":546},"start":{"character":0,"line":546}}}],"detail":"(BuffSize, \"BUFFSIZE\", -2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":36,"line":546},"start":{"character":0,"line":546}},"selectionRange":{"end":{"character":10,"line":546},"start":{"character":0,"line":546}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamLlBuffSize","range":{"end":{"character":10,"line":547},"start":{"character":0,"line":547}},"selectionRange":{"end":{"character":10,"line":547},"start":{"character":0,"line":547}}}],"detail":"(LlBuffSize, \"LL_BUFFSIZE\", -2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":41,"line":547},"start":{"character":0,"line":547}},"selectionRange":{"end":{"character":10,"line":547},"start":{"character":0,"line":547}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamLl128BuffSize","range":{"end":{"character":10,"line":548},"start":{"character":0,"line":548}},"selectionRange":{"end":{"character":10,"line":548},"start":{"character":0,"line":548}}}],"detail":"(Ll128BuffSize, \"LL128_BUFFSIZE\", -2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":47,"line":548},"start":{"character":0,"line":548}},"selectionRange":{"end":{"character":10,"line":548},"start":{"character":0,"line":548}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamP2pNetChunkSize","range":{"end":{"character":10,"line":550},"start":{"character":0,"line":550}},"selectionRange":{"end":{"character":10,"line":550},"start":{"character":0,"line":550}}}],"detail":"(P2pNetChunkSize, \"P2P_NET_CHUNKSIZE\", (1 << 17))","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":59,"line":550},"start":{"character":0,"line":550}},"selectionRange":{"end":{"character":10,"line":550},"start":{"character":0,"line":550}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamP2pPciChunkSize","range":{"end":{"character":10,"line":551},"start":{"character":0,"line":551}},"selectionRange":{"end":{"character":10,"line":551},"start":{"character":0,"line":551}}}],"detail":"(P2pPciChunkSize, \"P2P_PCI_CHUNKSIZE\", (1 << 17))","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":59,"line":551},"start":{"character":0,"line":551}},"selectionRange":{"end":{"character":10,"line":551},"start":{"character":0,"line":551}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamP2pNvlChunkSize","range":{"end":{"character":10,"line":552},"start":{"character":0,"line":552}},"selectionRange":{"end":{"character":10,"line":552},"start":{"character":0,"line":552}}}],"detail":"(P2pNvlChunkSize, \"P2P_NVL_CHUNKSIZE\", (1 << 19))","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":59,"line":552},"start":{"character":0,"line":552}},"selectionRange":{"end":{"character":10,"line":552},"start":{"character":0,"line":552}}},{"detail":"ncclResult_t (struct ncclComm *)","kind":12,"name":"computeBuffSizes","range":{"end":{"character":1,"line":581},"start":{"character":0,"line":554}},"selectionRange":{"end":{"character":36,"line":554},"start":{"character":20,"line":554}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGraphDumpFileRank","range":{"end":{"character":10,"line":583},"start":{"character":0,"line":583}},"selectionRange":{"end":{"character":10,"line":583},"start":{"character":0,"line":583}}}],"detail":"(GraphDumpFileRank, \"GRAPH_DUMP_FILE_RANK\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":56,"line":583},"start":{"character":0,"line":583}},"selectionRange":{"end":{"character":10,"line":583},"start":{"character":0,"line":583}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCollNetNodeThreshold","range":{"end":{"character":10,"line":584},"start":{"character":0,"line":584}},"selectionRange":{"end":{"character":10,"line":584},"start":{"character":0,"line":584}}}],"detail":"(CollNetNodeThreshold, \"COLLNET_NODE_THRESHOLD\", 2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":61,"line":584},"start":{"character":0,"line":584}},"selectionRange":{"end":{"character":10,"line":584},"start":{"character":0,"line":584}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamNvbPreconnect","range":{"end":{"character":10,"line":585},"start":{"character":0,"line":585}},"selectionRange":{"end":{"character":10,"line":585},"start":{"character":0,"line":585}}}],"detail":"(NvbPreconnect, \"NVB_PRECONNECT\", 1)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":46,"line":585},"start":{"character":0,"line":585}},"selectionRange":{"end":{"character":10,"line":585},"start":{"character":0,"line":585}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamAllocP2pNetLLBuffers","range":{"end":{"character":10,"line":586},"start":{"character":0,"line":586}},"selectionRange":{"end":{"character":10,"line":586},"start":{"character":0,"line":586}}}],"detail":"(AllocP2pNetLLBuffers, \"ALLOC_P2P_NET_LL_BUFFERS\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":63,"line":586},"start":{"character":0,"line":586}},"selectionRange":{"end":{"character":10,"line":586},"start":{"character":0,"line":586}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"collNetInitRailRankMap","range":{"end":{"character":1,"line":610},"start":{"character":0,"line":588}},"selectionRange":{"end":{"character":42,"line":588},"start":{"character":20,"line":588}}},{"detail":"ncclResult_t (ncclComm_t, ncclComm_t, struct ncclTopoGraph *)","kind":12,"name":"collNetTrySetup","range":{"end":{"character":1,"line":824},"start":{"character":0,"line":612}},"selectionRange":{"end":{"character":35,"line":612},"start":{"character":20,"line":612}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamMNNVLEnable","range":{"end":{"character":10,"line":827},"start":{"character":0,"line":827}},"selectionRange":{"end":{"character":10,"line":827},"start":{"character":0,"line":827}}}],"detail":"(MNNVLEnable, \"MNNVL_ENABLE\", 2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":42,"line":827},"start":{"character":0,"line":827}},"selectionRange":{"end":{"character":10,"line":827},"start":{"character":0,"line":827}}},{"detail":"int (struct ncclComm *)","kind":12,"name":"checkMNNVL","range":{"end":{"character":1,"line":886},"start":{"character":0,"line":835}},"selectionRange":{"end":{"character":21,"line":835},"start":{"character":11,"line":835}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclComm *)","kind":12,"name":"initTransportsRank","range":{"end":{"character":1,"line":1427},"start":{"character":0,"line":894}},"selectionRange":{"end":{"character":38,"line":894},"start":{"character":20,"line":894}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamSetStackSize","range":{"end":{"character":10,"line":1429},"start":{"character":0,"line":1429}},"selectionRange":{"end":{"character":10,"line":1429},"start":{"character":0,"line":1429}}}],"detail":"(SetStackSize, \"SET_STACK_SIZE\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":45,"line":1429},"start":{"character":0,"line":1429}},"selectionRange":{"end":{"character":10,"line":1429},"start":{"character":0,"line":1429}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCGAClusterSize","range":{"end":{"character":10,"line":1430},"start":{"character":0,"line":1430}},"selectionRange":{"end":{"character":10,"line":1430},"start":{"character":0,"line":1430}}}],"detail":"(CGAClusterSize, \"CGA_CLUSTER_SIZE\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":69,"line":1430},"start":{"character":0,"line":1430}},"selectionRange":{"end":{"character":10,"line":1430},"start":{"character":0,"line":1430}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamMaxCTAs","range":{"end":{"character":10,"line":1432},"start":{"character":0,"line":1432}},"selectionRange":{"end":{"character":10,"line":1432},"start":{"character":0,"line":1432}}}],"detail":"(MaxCTAs, \"MAX_CTAS\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":54,"line":1432},"start":{"character":0,"line":1432}},"selectionRange":{"end":{"character":10,"line":1432},"start":{"character":0,"line":1432}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamMinCTAs","range":{"end":{"character":10,"line":1433},"start":{"character":0,"line":1433}},"selectionRange":{"end":{"character":10,"line":1433},"start":{"character":0,"line":1433}}}],"detail":"(MinCTAs, \"MIN_CTAS\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":54,"line":1433},"start":{"character":0,"line":1433}},"selectionRange":{"end":{"character":10,"line":1433},"start":{"character":0,"line":1433}}},{"children":[{"detail":"struct ncclAsyncJob","kind":8,"name":"base","range":{"end":{"character":26,"line":1437},"start":{"character":2,"line":1437}},"selectionRange":{"end":{"character":26,"line":1437},"start":{"character":22,"line":1437}}},{"detail":"struct ncclComm *","kind":8,"name":"comm","range":{"end":{"character":23,"line":1438},"start":{"character":2,"line":1438}},"selectionRange":{"end":{"character":23,"line":1438},"start":{"character":19,"line":1438}}},{"detail":"struct ncclComm **","kind":8,"name":"newcomm","range":{"end":{"character":27,"line":1439},"start":{"character":2,"line":1439}},"selectionRange":{"end":{"character":27,"line":1439},"start":{"character":20,"line":1439}}},{"detail":"int","kind":8,"name":"cudaDev","range":{"end":{"character":13,"line":1440},"start":{"character":2,"line":1440}},"selectionRange":{"end":{"character":13,"line":1440},"start":{"character":6,"line":1440}}},{"detail":"int","kind":8,"name":"nranks","range":{"end":{"character":12,"line":1442},"start":{"character":2,"line":1442}},"selectionRange":{"end":{"character":12,"line":1442},"start":{"character":6,"line":1442}}},{"detail":"int","kind":8,"name":"myrank","range":{"end":{"character":20,"line":1442},"start":{"character":2,"line":1442}},"selectionRange":{"end":{"character":20,"line":1442},"start":{"character":14,"line":1442}}},{"detail":"ncclUniqueId","kind":8,"name":"commId","range":{"end":{"character":21,"line":1443},"start":{"character":2,"line":1443}},"selectionRange":{"end":{"character":21,"line":1443},"start":{"character":15,"line":1443}}},{"detail":"struct ncclComm *","kind":8,"name":"parent","range":{"end":{"character":25,"line":1445},"start":{"character":2,"line":1445}},"selectionRange":{"end":{"character":25,"line":1445},"start":{"character":19,"line":1445}}},{"detail":"int","kind":8,"name":"color","range":{"end":{"character":11,"line":1446},"start":{"character":2,"line":1446}},"selectionRange":{"end":{"character":11,"line":1446},"start":{"character":6,"line":1446}}},{"detail":"int","kind":8,"name":"key","range":{"end":{"character":16,"line":1446},"start":{"character":2,"line":1446}},"selectionRange":{"end":{"character":16,"line":1446},"start":{"character":13,"line":1446}}}],"detail":"struct","kind":23,"name":"ncclCommInitRankAsyncJob","range":{"end":{"character":1,"line":1447},"start":{"character":0,"line":1436}},"selectionRange":{"end":{"character":31,"line":1436},"start":{"character":7,"line":1436}}},{"children":[{"detail":"struct ncclAsyncJob","kind":8,"name":"base","range":{"end":{"character":26,"line":1450},"start":{"character":2,"line":1450}},"selectionRange":{"end":{"character":26,"line":1450},"start":{"character":22,"line":1450}}},{"detail":"ncclComm_t","kind":8,"name":"comm","range":{"end":{"character":17,"line":1451},"start":{"character":2,"line":1451}},"selectionRange":{"end":{"character":17,"line":1451},"start":{"character":13,"line":1451}}}],"detail":"struct","kind":23,"name":"ncclCommFinalizeAsyncJob","range":{"end":{"character":1,"line":1452},"start":{"character":0,"line":1449}},"selectionRange":{"end":{"character":31,"line":1449},"start":{"character":7,"line":1449}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCommSplitShareResources","range":{"end":{"character":10,"line":1454},"start":{"character":0,"line":1454}},"selectionRange":{"end":{"character":10,"line":1454},"start":{"character":0,"line":1454}}}],"detail":"(CommSplitShareResources, \"COMM_SPLIT_SHARE_RESOURCES\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":88,"line":1454},"start":{"character":0,"line":1454}},"selectionRange":{"end":{"character":10,"line":1454},"start":{"character":0,"line":1454}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclComm *, int, int, int *, int *, int *)","kind":12,"name":"commGetSplitInfo","range":{"end":{"character":1,"line":1500},"start":{"character":0,"line":1456}},"selectionRange":{"end":{"character":36,"line":1456},"start":{"character":20,"line":1456}}},{"detail":"ncclResult_t (struct ncclAsyncJob *)","kind":12,"name":"ncclCommInitRankFunc","range":{"end":{"character":1,"line":1600},"start":{"character":0,"line":1502}},"selectionRange":{"end":{"character":40,"line":1502},"start":{"character":20,"line":1502}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"envConfigOverride","range":{"end":{"character":1,"line":1680},"start":{"character":0,"line":1609}},"selectionRange":{"end":{"character":37,"line":1609},"start":{"character":20,"line":1609}}},{"detail":"ncclResult_t (ncclComm_t, ncclComm_t)","kind":12,"name":"copyCommConfig","range":{"end":{"character":1,"line":1686},"start":{"character":0,"line":1682}},"selectionRange":{"end":{"character":34,"line":1682},"start":{"character":20,"line":1682}}},{"detail":"ncclResult_t (ncclComm_t, ncclConfig_t *)","kind":12,"name":"parseCommConfig","range":{"end":{"character":1,"line":1771},"start":{"character":0,"line":1688}},"selectionRange":{"end":{"character":35,"line":1688},"start":{"character":20,"line":1688}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, int, ncclConfig_t *)","kind":12,"name":"ncclCommInitRankDev","range":{"end":{"character":1,"line":1825},"start":{"character":0,"line":1773}},"selectionRange":{"end":{"character":39,"line":1773},"start":{"character":20,"line":1773}}},{"children":[{"detail":"int","kind":8,"name":"rank","range":{"end":{"character":10,"line":1829},"start":{"character":2,"line":1829}},"selectionRange":{"end":{"character":10,"line":1829},"start":{"character":6,"line":1829}}},{"detail":"int","kind":8,"name":"nranks","range":{"end":{"character":12,"line":1830},"start":{"character":2,"line":1830}},"selectionRange":{"end":{"character":12,"line":1830},"start":{"character":6,"line":1830}}},{"detail":"int","kind":8,"name":"cudaDev","range":{"end":{"character":13,"line":1831},"start":{"character":2,"line":1831}},"selectionRange":{"end":{"character":13,"line":1831},"start":{"character":6,"line":1831}}}],"detail":"struct","kind":23,"name":"NvtxParamsCommInitRank","range":{"end":{"character":1,"line":1832},"start":{"character":0,"line":1827}},"selectionRange":{"end":{"character":29,"line":1827},"start":{"character":7,"line":1827}}},{"detail":"const nvtxPayloadSchemaEntry_t[3]","kind":13,"name":"CommInitRankSchema","range":{"end":{"character":1,"line":1837},"start":{"character":0,"line":1833}},"selectionRange":{"end":{"character":53,"line":1833},"start":{"character":35,"line":1833}}},{"children":[{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int)","kind":12,"name":"pncclCommInitRank","range":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}},"selectionRange":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int)","kind":12,"name":"ncclCommInitRank","range":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}},"selectionRange":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}}}],"detail":"(ncclResult_t, ncclCommInitRank, ncclComm_t* newcomm, int nranks, ncclUniqueId commId ...)","kind":21,"name":"NCCL_API","range":{"end":{"character":106,"line":1839},"start":{"character":0,"line":1839}},"selectionRange":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int)","kind":12,"name":"ncclCommInitRank","range":{"end":{"character":1,"line":1853},"start":{"character":0,"line":1840}},"selectionRange":{"end":{"character":29,"line":1840},"start":{"character":13,"line":1840}}},{"children":[{"detail":"ncclResult_t (ncclComm_t *, int, const int *)","kind":12,"name":"pncclCommInitAll","range":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}},"selectionRange":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}}},{"detail":"ncclResult_t (ncclComm_t *, int, const int *)","kind":12,"name":"ncclCommInitAll","range":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}},"selectionRange":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}}}],"detail":"(ncclResult_t, ncclCommInitAll, ncclComm_t* comms, int ndev, const int* devlist)","kind":21,"name":"NCCL_API","range":{"end":{"character":88,"line":1855},"start":{"character":0,"line":1855}},"selectionRange":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}}},{"detail":"ncclResult_t (ncclComm_t *, int, const int *)","kind":12,"name":"ncclCommInitAll","range":{"end":{"character":1,"line":1911},"start":{"character":0,"line":1856}},"selectionRange":{"end":{"character":28,"line":1856},"start":{"character":13,"line":1856}}},{"detail":"ncclResult_t (ncclComm_t, ncclResult_t)","kind":12,"name":"ncclCommSetAsyncError","range":{"end":{"character":1,"line":1921},"start":{"character":0,"line":1913}},"selectionRange":{"end":{"character":34,"line":1913},"start":{"character":13,"line":1913}}},{"children":[{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, ncclConfig_t *)","kind":12,"name":"pncclCommInitRankConfig","range":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}},"selectionRange":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, ncclConfig_t *)","kind":12,"name":"ncclCommInitRankConfig","range":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}},"selectionRange":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}}}],"detail":"(ncclResult_t, ncclCommInitRankConfig, ncclComm_t* comm, int nranks, ncclUniqueId ...)","kind":21,"name":"NCCL_API","range":{"end":{"character":131,"line":1923},"start":{"character":0,"line":1923}},"selectionRange":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, ncclConfig_t *)","kind":12,"name":"ncclCommInitRankConfig","range":{"end":{"character":1,"line":1949},"start":{"character":0,"line":1924}},"selectionRange":{"end":{"character":35,"line":1924},"start":{"character":13,"line":1924}}},{"detail":"ncclResult_t (struct ncclAsyncJob *)","kind":12,"name":"commDestroySync","range":{"end":{"character":1,"line":1984},"start":{"character":0,"line":1951}},"selectionRange":{"end":{"character":35,"line":1951},"start":{"character":20,"line":1951}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commCleanup","range":{"end":{"character":1,"line":2007},"start":{"character":0,"line":1986}},"selectionRange":{"end":{"character":31,"line":1986},"start":{"character":20,"line":1986}}},{"detail":"ncclResult_t (ncclComm_t, bool)","kind":12,"name":"commFinalize","range":{"end":{"character":1,"line":2028},"start":{"character":0,"line":2009}},"selectionRange":{"end":{"character":32,"line":2009},"start":{"character":20,"line":2009}}},{"children":[{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"pncclCommFinalize","range":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}},"selectionRange":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommFinalize","range":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}},"selectionRange":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}}}],"detail":"(ncclResult_t, ncclCommFinalize, ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":57,"line":2030},"start":{"character":0,"line":2030}},"selectionRange":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommFinalize","range":{"end":{"character":1,"line":2058},"start":{"character":0,"line":2031}},"selectionRange":{"end":{"character":29,"line":2031},"start":{"character":13,"line":2031}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commReclaim","range":{"end":{"character":1,"line":2142},"start":{"character":0,"line":2060}},"selectionRange":{"end":{"character":31,"line":2060},"start":{"character":20,"line":2060}}},{"children":[{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"pncclCommDestroy","range":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}},"selectionRange":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommDestroy","range":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}},"selectionRange":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}}}],"detail":"(ncclResult_t, ncclCommDestroy, ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":56,"line":2144},"start":{"character":0,"line":2144}},"selectionRange":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommDestroy","range":{"end":{"character":1,"line":2171},"start":{"character":0,"line":2145}},"selectionRange":{"end":{"character":28,"line":2145},"start":{"character":13,"line":2145}}},{"children":[{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"pncclCommAbort","range":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}},"selectionRange":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommAbort","range":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}},"selectionRange":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}}}],"detail":"(ncclResult_t, ncclCommAbort, ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":54,"line":2173},"start":{"character":0,"line":2173}},"selectionRange":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommAbort","range":{"end":{"character":1,"line":2203},"start":{"character":0,"line":2174}},"selectionRange":{"end":{"character":26,"line":2174},"start":{"character":13,"line":2174}}},{"children":[{"detail":"ncclResult_t (ncclComm_t, int, int, ncclComm_t *, ncclConfig_t *)","kind":12,"name":"pncclCommSplit","range":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}},"selectionRange":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}}},{"detail":"ncclResult_t (ncclComm_t, int, int, ncclComm_t *, ncclConfig_t *)","kind":12,"name":"ncclCommSplit","range":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}},"selectionRange":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}}}],"detail":"(ncclResult_t, ncclCommSplit, ncclComm_t comm, int color, int key, ncclComm_t *newcomm ...)","kind":21,"name":"NCCL_API","range":{"end":{"character":117,"line":2205},"start":{"character":0,"line":2205}},"selectionRange":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}}},{"detail":"ncclResult_t (ncclComm_t, int, int, ncclComm_t *, ncclConfig_t *)","kind":12,"name":"ncclCommSplit","range":{"end":{"character":1,"line":2268},"start":{"character":0,"line":2206}},"selectionRange":{"end":{"character":26,"line":2206},"start":{"character":13,"line":2206}}},{"children":[{"detail":"const char *(ncclResult_t)","kind":12,"name":"pncclGetErrorString","range":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}},"selectionRange":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}}},{"detail":"const char *(ncclResult_t)","kind":12,"name":"ncclGetErrorString","range":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}},"selectionRange":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}}}],"detail":"(const char*, ncclGetErrorString, ncclResult_t code)","kind":21,"name":"NCCL_API","range":{"end":{"character":60,"line":2270},"start":{"character":0,"line":2270}},"selectionRange":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}}},{"detail":"const char *(ncclResult_t)","kind":12,"name":"ncclGetErrorString","range":{"end":{"character":1,"line":2283},"start":{"character":0,"line":2271}},"selectionRange":{"end":{"character":30,"line":2271},"start":{"character":12,"line":2271}}},{"children":[{"detail":"const char *(const ncclComm_t)","kind":12,"name":"pncclGetLastError","range":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}},"selectionRange":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}}},{"detail":"const char *(const ncclComm_t)","kind":12,"name":"ncclGetLastError","range":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}},"selectionRange":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}}}],"detail":"(const char*, ncclGetLastError, const ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":62,"line":2288},"start":{"character":0,"line":2288}},"selectionRange":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}}},{"detail":"const char *(ncclComm_t)","kind":12,"name":"ncclGetLastError","range":{"end":{"character":1,"line":2291},"start":{"character":0,"line":2289}},"selectionRange":{"end":{"character":28,"line":2289},"start":{"character":12,"line":2289}}},{"children":[{"detail":"ncclResult_t (ncclComm_t, ncclResult_t *)","kind":12,"name":"pncclCommGetAsyncError","range":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}},"selectionRange":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}}},{"detail":"ncclResult_t (ncclComm_t, ncclResult_t *)","kind":12,"name":"ncclCommGetAsyncError","range":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}},"selectionRange":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}}}],"detail":"(ncclResult_t, ncclCommGetAsyncError, ncclComm_t comm, ncclResult_t *asyncError)","kind":21,"name":"NCCL_API","range":{"end":{"character":88,"line":2293},"start":{"character":0,"line":2293}},"selectionRange":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}}},{"detail":"ncclResult_t (ncclComm_t, ncclResult_t *)","kind":12,"name":"ncclCommGetAsyncError","range":{"end":{"character":1,"line":2301},"start":{"character":0,"line":2294}},"selectionRange":{"end":{"character":34,"line":2294},"start":{"character":13,"line":2294}}},{"children":[{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"pncclCommCount","range":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}},"selectionRange":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCount","range":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}},"selectionRange":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}}}],"detail":"(ncclResult_t, ncclCommCount, const ncclComm_t comm, int* count)","kind":21,"name":"NCCL_API","range":{"end":{"character":72,"line":2303},"start":{"character":0,"line":2303}},"selectionRange":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCount","range":{"end":{"character":1,"line":2315},"start":{"character":0,"line":2304}},"selectionRange":{"end":{"character":26,"line":2304},"start":{"character":13,"line":2304}}},{"children":[{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"pncclCommCuDevice","range":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}},"selectionRange":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCuDevice","range":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}},"selectionRange":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}}}],"detail":"(ncclResult_t, ncclCommCuDevice, const ncclComm_t comm, int* devid)","kind":21,"name":"NCCL_API","range":{"end":{"character":75,"line":2317},"start":{"character":0,"line":2317}},"selectionRange":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCuDevice","range":{"end":{"character":1,"line":2328},"start":{"character":0,"line":2318}},"selectionRange":{"end":{"character":29,"line":2318},"start":{"character":13,"line":2318}}},{"children":[{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"pncclCommUserRank","range":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}},"selectionRange":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommUserRank","range":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}},"selectionRange":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}}}],"detail":"(ncclResult_t, ncclCommUserRank, const ncclComm_t comm, int* rank)","kind":21,"name":"NCCL_API","range":{"end":{"character":74,"line":2330},"start":{"character":0,"line":2330}},"selectionRange":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommUserRank","range":{"end":{"character":1,"line":2341},"start":{"character":0,"line":2331}},"selectionRange":{"end":{"character":29,"line":2331},"start":{"character":13,"line":2331}}},{"children":[{"detail":"ncclResult_t (void **, size_t)","kind":12,"name":"pncclMemAlloc","range":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}},"selectionRange":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}}},{"detail":"ncclResult_t (void **, size_t)","kind":12,"name":"ncclMemAlloc","range":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}},"selectionRange":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}}}],"detail":"(ncclResult_t, ncclMemAlloc, void **ptr, size_t size)","kind":21,"name":"NCCL_API","range":{"end":{"character":61,"line":2343},"start":{"character":0,"line":2343}},"selectionRange":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}}},{"detail":"ncclResult_t (void **, size_t)","kind":12,"name":"ncclMemAlloc","range":{"end":{"character":1,"line":2418},"start":{"character":0,"line":2344}},"selectionRange":{"end":{"character":26,"line":2344},"start":{"character":14,"line":2344}}},{"children":[{"detail":"ncclResult_t (void *)","kind":12,"name":"pncclMemFree","range":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}},"selectionRange":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}}},{"detail":"ncclResult_t (void *)","kind":12,"name":"ncclMemFree","range":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}},"selectionRange":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}}}],"detail":"(ncclResult_t, ncclMemFree, void *ptr)","kind":21,"name":"NCCL_API","range":{"end":{"character":46,"line":2420},"start":{"character":0,"line":2420}},"selectionRange":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}}},{"detail":"ncclResult_t (void *)","kind":12,"name":"ncclMemFree","range":{"end":{"character":1,"line":2454},"start":{"character":0,"line":2421}},"selectionRange":{"end":{"character":25,"line":2421},"start":{"character":14,"line":2421}}}]}

V[15:12:28.803] ASTWorker running DocumentLinks on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:28.803] --> reply:textDocument/documentLink(2) 1595 ms
V[15:12:28.804] >>> {"id":2,"jsonrpc":"2.0","result":[{"range":{"end":{"character":17,"line":6},"start":{"character":9,"line":6}},"target":"file:///root/code/nccl-trace/include/nccl.h"},{"range":{"end":{"character":20,"line":7},"start":{"character":9,"line":7}},"target":"file:///root/code/nccl-trace/src/include/channel.h"},{"range":{"end":{"character":21,"line":8},"start":{"character":9,"line":8}},"target":"file:///root/code/nccl-trace/src/include/nvmlwrap.h"},{"range":{"end":{"character":20,"line":9},"start":{"character":9,"line":9}},"target":"file:///root/code/nccl-trace/src/include/gdrwrap.h"},{"range":{"end":{"character":22,"line":10},"start":{"character":9,"line":10}},"target":"file:///root/code/nccl-trace/src/include/bootstrap.h"},{"range":{"end":{"character":22,"line":11},"start":{"character":9,"line":11}},"target":"file:///root/code/nccl-trace/src/include/transport.h"},{"range":{"end":{"character":18,"line":12},"start":{"character":9,"line":12}},"target":"file:///root/code/nccl-trace/src/include/group.h"},{"range":{"end":{"character":16,"line":13},"start":{"character":9,"line":13}},"target":"file:///root/code/nccl-trace/src/include/net.h"},{"range":{"end":{"character":21,"line":14},"start":{"character":9,"line":14}},"target":"file:///root/code/nccl-trace/src/include/coll_net.h"},{"range":{"end":{"character":20,"line":15},"start":{"character":9,"line":15}},"target":"file:///root/code/nccl-trace/src/include/enqueue.h"},{"range":{"end":{"character":18,"line":16},"start":{"character":9,"line":16}},"target":"file:///root/code/nccl-trace/src/include/graph.h"},{"range":{"end":{"character":21,"line":17},"start":{"character":9,"line":17}},"target":"file:///root/code/nccl-trace/src/include/argcheck.h"},{"range":{"end":{"character":18,"line":18},"start":{"character":9,"line":18}},"target":"file:///root/code/nccl-trace/src/include/tuner.h"},{"range":{"end":{"character":18,"line":19},"start":{"character":9,"line":19}},"target":"file:///usr/include/fcntl.h"},{"range":{"end":{"character":19,"line":20},"start":{"character":9,"line":20}},"target":"file:///usr/include/string.h"},{"range":{"end":{"character":18,"line":21},"start":{"character":9,"line":21}},"target":"file:///usr/include/errno.h"},{"range":{"end":{"character":19,"line":22},"start":{"character":9,"line":22}},"target":"file:///usr/include/assert.h"},{"range":{"end":{"character":18,"line":23},"start":{"character":9,"line":23}},"target":"file:///usr/include/dlfcn.h"},{"range":{"end":{"character":22,"line":24},"start":{"character":9,"line":24}},"target":"file:///usr/include/x86_64-linux-gnu/sys/types.h"},{"range":{"end":{"character":21,"line":25},"start":{"character":9,"line":25}},"target":"file:///usr/include/x86_64-linux-gnu/sys/stat.h"},{"range":{"end":{"character":19,"line":26},"start":{"character":9,"line":26}},"target":"file:///usr/include/unistd.h"},{"range":{"end":{"character":18,"line":27},"start":{"character":9,"line":27}},"target":"file:///root/code/nccl-trace/src/include/param.h"},{"range":{"end":{"character":20,"line":29},"start":{"character":9,"line":29}},"target":"file:///root/code/nccl-trace/include/nccl_tp.h"},{"range":{"end":{"character":17,"line":831},"start":{"character":9,"line":831}},"target":"file:///usr/local/cuda-12.2/targets/x86_64-linux/include/cuda.h"},{"range":{"end":{"character":21,"line":832},"start":{"character":9,"line":832}},"target":"file:///root/code/nccl-trace/src/include/cudawrap.h"}]}

V[15:12:28.804] ASTWorker running InlayHints on version 1 of /root/code/nccl-trace/src/init.cc
V[15:12:28.809] indexed preamble AST for /root/code/nccl-trace/src/init.cc version 1:
  symbol slab: 21592 symbols, 8109966 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 14 relations, 296 bytes
I[15:12:28.809] --> reply:textDocument/inlayHint(3) 1600 ms
V[15:12:28.809] >>> {"id":3,"jsonrpc":"2.0","result":[{"kind":2,"label":"me:","paddingLeft":false,"paddingRight":true,"position":{"character":76,"line":132}},{"kind":2,"label":"ptr:","paddingLeft":false,"paddingRight":true,"position":{"character":25,"line":140}},{"kind":2,"label":"me:","paddingLeft":false,"paddingRight":true,"position":{"character":76,"line":144}},{"kind":2,"label":"ptr:","paddingLeft":false,"paddingRight":true,"position":{"character":25,"line":152}},{"kind":2,"label":"me:","paddingLeft":false,"paddingRight":true,"position":{"character":76,"line":156}},{"kind":2,"label":"gdrHandle:","paddingLeft":false,"paddingRight":true,"position":{"character":28,"line":164}},{"kind":2,"label":"me:","paddingLeft":false,"paddingRight":true,"position":{"character":76,"line":168}},{"kind":2,"label":"th:","paddingLeft":false,"paddingRight":true,"position":{"character":17,"line":184}},{"kind":2,"label":"thread_return:","paddingLeft":false,"paddingRight":true,"position":{"character":43,"line":184}},{"kind":2,"label":"th:","paddingLeft":false,"paddingRight":true,"position":{"character":19,"line":187}},{"kind":2,"label":"thread_return:","paddingLeft":false,"paddingRight":true,"position":{"character":48,"line":187}},{"kind":2,"label":"system:","paddingLeft":false,"paddingRight":true,"position":{"character":17,"line":198}},{"kind":2,"label":"commState:","paddingLeft":false,"paddingRight":true,"position":{"character":29,"line":208}},{"kind":2,"label":"channel:","paddingLeft":false,"paddingRight":true,"position":{"character":26,"line":211}},{"kind":2,"label":"nRanks:","paddingLeft":false,"paddingRight":true,"position":{"character":50,"line":211}},{"kind":2,"label":"collnetNRanks:","paddingLeft":false,"paddingRight":true,"position":{"character":64,"line":211}},{"kind":2,"label":"nvlsNRanks:","paddingLeft":false,"paddingRight":true,"position":{"character":67,"line":211}},{"kind":2,"label":"refs:","paddingLeft":false,"paddingRight":true,"position":{"character":36,"line":214}},{"kind":2,"label":"ptr:","paddingLeft":false,"paddingRight":true,"position":{"character":55,"line":217}},{"kind":2,"label":"ss:","paddingLeft":false,"paddingRight":true,"position":{"character":41,"line":220}},{"kind":2,"label":"ss:","paddingLeft":false,"paddingRight":true,"position":{"character":41,"line":221}},{"kind":2,"label":"me:","paddingLeft":false,"paddingRight":true,"position":{"character":26,"line":235}},{"kind":2,"label":"me:","paddingLeft":false,"paddingRight":true,"position":{"character":26,"line":236}},{"kind":2,"label":"refs:","paddingLeft":false,"paddingRight":true,"position":{"character":34,"line":238}},{"kind":2,"label":"ptr:","paddingLeft":false,"paddingRight":true,"position":{"character":31,"line":239}}]}

V[15:12:28.809] ASTWorker running codeAction on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:28.809] --> reply:textDocument/codeAction(4) 1601 ms
V[15:12:28.809] >>> {"id":4,"jsonrpc":"2.0","result":[]}

V[15:12:28.809] ASTWorker running SemanticHighlights on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:28.821] --> reply:textDocument/semanticTokens/full(5) 1445 ms
V[15:12:28.823] >>> {"id":5,"jsonrpc":"2.0","result":{"data":[31,8,4,19,131073,1,8,3,19,131073,0,7,4,19,131072,2,4,14,19,131072,1,8,22,19,131073,5,12,11,0,131091,0,12,18,19,131072,1,12,11,0,131091,0,12,19,19,131072,1,12,12,0,131091,0,13,18,19,131072,2,0,10,19,131072,0,49,22,19,131072,2,0,10,19,131072,1,0,10,19,131072,0,42,21,19,131072,2,7,12,10,131072,0,13,11,3,65537,0,12,10,12,65536,0,11,4,2,16387,2,7,8,18,66048,0,9,12,3,65539,0,13,12,8,131072,0,20,2,2,16403,1,14,5,1,16403,0,21,1,21,0,0,1,2,2,16400,1,2,8,18,66048,0,9,1,1,16387,1,10,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,14,12,8,131072,0,15,1,1,16384,0,1,2,21,0,1,4,1,1,16384,0,2,2,21,0,0,3,1,1,16384,0,2,2,21,0,1,4,1,1,16384,0,2,2,21,0,1,4,1,1,16384,0,2,2,21,0,0,3,5,1,16400,0,6,1,1,16384,2,9,1,1,16384,4,0,10,19,131072,3,0,5,12,65536,0,6,11,0,131075,0,14,4,19,131072,2,0,12,10,131072,0,13,11,3,131075,1,6,22,3,131072,0,25,2,21,0,1,4,11,0,131072,0,12,1,21,0,0,2,11,3,65536,2,9,11,11,131088,3,0,15,8,131584,0,16,8,0,131075,0,11,25,19,131072,1,12,11,0,65539,2,7,12,10,131072,0,13,8,3,65539,1,22,1,21,0,0,1,11,0,65536,0,13,16,19,131072,0,26,11,11,131088,1,2,18,3,131584,0,19,1,21,0,0,1,8,0,133120,1,6,1,21,0,0,1,11,0,65536,1,4,7,3,131072,1,4,11,3,131072,2,4,9,19,131072,0,10,16,3,131072,1,4,9,19,131072,0,10,17,3,131072,2,4,23,3,131072,1,21,1,21,0,0,1,11,0,65536,0,19,16,19,131072,2,2,20,3,131584,0,21,1,21,0,0,1,8,0,133120,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,14,3,131073,0,21,7,2,16387,1,0,12,10,131072,0,13,14,3,131075,0,20,7,2,16387,1,6,7,2,16384,0,8,2,21,0,0,3,4,19,131072,0,13,19,11,131088,1,2,1,21,0,0,1,7,2,16384,0,8,1,21,0,0,2,17,19,131072,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,15,3,131073,0,17,12,8,131072,0,14,3,2,16387,1,0,12,10,131072,0,13,15,3,131075,0,16,12,8,131072,0,14,3,2,16387,1,2,9,19,131072,0,10,8,3,65536,1,2,9,19,131072,0,10,8,3,131072,0,9,3,2,18432,1,2,12,10,131072,0,13,3,1,16387,0,6,20,3,131072,0,29,19,8,131072,0,21,3,2,16384,1,2,10,19,131072,0,58,12,3,65536,0,13,1,21,0,0,1,3,2,16384,1,9,3,1,16384,4,7,9,19,131072,1,8,16,19,131073,5,5,16,19,131072,0,17,10,3,131075,0,11,10,12,65536,0,11,4,2,16387,2,2,4,2,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,7,6,32768,0,8,1,21,0,0,2,4,2,16384,0,6,5,6,32768,0,6,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,7,1,21,0,0,2,1,21,0,1,2,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,4,2,16384,0,6,8,6,32768,0,9,1,21,0,3,7,16,19,131072,3,7,12,10,131072,0,13,20,3,65539,0,28,14,8,131072,0,16,4,2,16387,1,2,4,14,256,0,5,4,2,16384,0,6,3,6,32768,1,9,11,11,131088,2,5,16,3,131075,0,24,8,8,131072,0,10,4,2,16387,0,12,3,2,16387,1,9,14,8,131072,0,16,4,1,16387,0,7,20,3,131072,0,20,1,22,0,0,8,14,8,131072,0,14,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,34816,1,2,4,1,16384,0,6,2,6,32768,0,3,1,21,0,0,2,20,3,65536,1,2,4,1,16384,0,6,3,6,32768,0,4,1,21,0,0,2,3,2,16384,1,2,4,1,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,14,6,32768,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,2,4,1,16384,3,7,12,10,131072,0,13,24,3,65539,0,32,14,8,131072,0,16,4,2,16387,1,2,9,19,131072,0,10,12,3,131072,0,13,4,2,16384,0,6,3,6,34816,1,9,11,11,131088,2,5,20,3,131075,0,28,8,8,131072,0,10,4,2,16387,0,12,3,2,16387,1,9,14,8,131072,0,16,4,1,16387,0,7,20,3,131072,0,20,1,22,0,0,8,14,8,131072,0,14,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,34816,1,2,4,1,16384,0,6,2,6,32768,0,3,1,21,0,0,2,24,3,65536,1,2,4,1,16384,0,6,3,6,32768,0,4,1,21,0,0,2,3,2,16384,1,2,4,1,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,14,6,32768,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,2,4,1,16384,3,7,12,10,131072,0,13,28,3,65539,0,36,14,8,131072,0,16,4,2,16387,1,2,9,19,131072,0,10,12,3,131072,0,13,4,2,16384,0,6,3,6,34816,1,9,11,11,131088,2,5,24,3,131075,0,32,8,8,131072,0,10,4,2,16387,0,12,3,2,16387,1,9,14,8,131072,0,16,4,1,16387,0,7,20,3,131072,0,20,1,22,0,0,8,14,8,131072,0,14,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,34816,1,2,4,1,16384,0,6,2,6,32768,0,3,1,21,0,0,2,28,3,65536,1,2,4,1,16384,0,6,3,6,32768,0,4,1,21,0,0,2,3,2,16384,1,2,4,1,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,14,6,32768,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,2,4,1,16384,3,7,12,10,131072,0,13,27,3,65539,0,35,14,8,131072,0,16,4,2,16387,1,2,9,19,131072,0,10,15,3,65536,0,16,4,2,16384,0,6,3,6,34816,1,9,11,11,131088,2,5,23,3,131075,0,31,8,8,131072,0,10,4,2,16387,0,12,6,2,16387,1,9,14,8,131072,0,16,4,1,16387,0,7,20,3,131072,0,20,1,22,0,0,8,14,8,131072,0,14,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,34816,1,2,4,1,16384,0,6,2,6,32768,0,3,1,21,0,0,2,27,3,65536,1,2,4,1,16384,0,6,3,6,32768,0,4,1,21,0,0,2,6,2,16384,1,2,4,1,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,14,6,32768,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,2,4,1,16384,3,7,12,10,131072,0,13,8,3,65539,0,9,10,12,65536,0,11,4,2,16387,2,6,4,2,16384,0,5,2,21,0,0,3,4,19,131072,1,11,11,11,131088,5,6,4,2,16384,0,6,10,6,32768,0,11,2,21,0,0,3,4,2,16384,0,6,16,6,32768,0,17,2,21,0,0,5,2,21,0,0,3,4,2,16384,0,6,10,6,32768,0,12,6,6,32768,1,4,12,3,131584,0,13,4,2,16384,0,6,10,6,32768,0,12,6,6,32768,1,8,4,2,16384,0,6,10,6,32768,0,12,9,6,32768,2,6,12,3,131584,0,13,4,2,16384,0,6,10,6,32768,0,12,9,6,32768,4,2,6,21,0,0,9,4,2,16384,0,6,10,6,32768,2,2,4,14,256,0,5,4,2,16384,0,6,11,6,32768,1,2,4,14,256,0,5,4,2,16384,0,6,11,6,32768,2,2,4,14,256,0,5,4,2,16384,0,6,8,6,32768,1,6,4,2,16384,0,6,4,6,32768,1,4,12,3,131072,0,13,4,2,16384,0,6,4,6,34816,1,6,4,2,16384,0,6,9,6,32768,1,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,0,4,4,14,256,0,5,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,15,6,32768,1,4,4,14,256,0,5,4,2,16384,0,6,9,6,32768,2,2,4,14,256,0,5,4,2,16384,0,6,10,6,32768,1,2,4,14,256,0,5,4,2,16384,0,6,15,6,32768,1,2,4,14,256,0,5,4,2,16384,0,6,12,6,32768,2,6,4,2,16384,0,6,9,6,32768,1,4,9,19,131072,0,10,14,3,131072,0,15,4,2,16384,0,6,9,6,34816,2,11,7,1,16387,0,11,7,1,16384,0,7,1,21,0,0,1,11,19,131072,0,13,7,1,16384,0,7,2,21,0,1,4,9,19,131072,0,10,11,3,131072,0,12,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,7,1,16384,0,9,4,2,16384,0,6,6,6,32768,0,11,4,2,16384,0,6,10,6,32768,2,6,4,2,16384,0,6,9,6,32768,1,8,27,3,131072,0,28,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,8,6,34816,0,10,2,21,0,1,15,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,11,19,131072,0,13,1,1,16384,0,1,2,21,0,1,12,4,2,16384,0,6,9,6,32768,0,11,5,6,32768,0,6,1,1,16384,0,4,4,14,256,0,5,4,2,16384,0,6,9,6,32768,0,11,5,6,32768,0,6,1,1,16384,1,12,4,2,16384,0,6,9,6,32768,0,11,8,6,32768,0,9,1,1,16384,0,4,12,3,131072,0,13,4,2,16384,0,6,9,6,32768,0,11,8,6,32768,0,9,1,1,16384,2,6,4,14,256,0,5,4,2,16384,0,6,9,6,32768,0,11,17,6,32768,1,6,9,19,131072,0,10,24,3,131072,0,25,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,10,6,34816,1,6,9,19,131072,0,10,24,3,131072,0,25,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,12,6,34816,1,6,9,19,131072,0,10,16,3,131072,0,17,4,2,18432,1,6,4,14,256,0,5,4,2,16384,0,6,9,6,32768,4,6,4,2,16384,0,6,11,6,32768,0,13,9,19,131072,0,10,12,3,131072,0,13,4,2,18432,2,9,14,8,131072,0,16,4,1,16387,0,7,4,2,16384,0,6,14,6,32768,1,9,4,1,16384,0,5,2,21,0,1,4,9,19,131072,0,10,4,1,16384,0,6,2,6,32768,0,3,4,1,16384,1,4,4,1,16384,0,5,1,21,0,0,2,4,1,16384,0,6,4,6,32768,3,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,9,6,34816,1,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,12,6,34816,2,6,27,3,131072,0,28,4,2,16384,0,6,17,6,34816,0,19,2,21,0,1,4,9,19,131072,0,10,16,3,131072,0,25,4,2,16384,0,6,9,6,32768,1,4,4,14,256,0,5,4,2,16384,0,6,17,6,32768,2,2,4,14,256,0,12,4,2,16384,0,6,6,6,32768,0,7,7,6,32784,2,2,4,14,256,0,5,4,2,16384,0,6,14,6,32768,1,2,4,14,256,0,5,4,2,16384,0,6,19,6,32768,2,2,9,19,131072,0,10,14,3,131072,0,15,4,2,18432,2,2,10,3,131072,0,11,4,2,18432,1,2,4,14,256,0,5,4,2,16384,2,9,11,11,131088,3,0,10,19,131072,2,0,10,19,131072,1,0,10,19,131072,0,47,2,21,0,1,5,14,10,131072,0,15,19,0,131075,2,0,10,19,131072,3,7,12,10,131072,0,13,15,3,65539,0,23,8,8,131072,0,10,4,2,16387,1,6,21,3,131072,0,24,2,21,0,0,5,2,21,0,0,3,4,2,16384,0,6,7,6,32768,0,9,11,6,32768,0,12,2,21,0,0,3,4,19,131072,0,5,2,21,0,0,3,19,3,131072,0,22,2,21,0,0,3,11,11,131088,0,20,17,11,131088,1,4,12,19,131072,1,6,4,1,16387,1,2,8,18,65536,0,9,3,1,16387,1,6,17,1,16387,1,2,9,19,131072,0,10,20,3,131072,0,21,1,21,0,0,1,17,1,18432,1,6,5,19,131072,0,19,2,21,0,0,3,4,19,131072,0,5,2,21,0,0,3,17,1,16384,0,18,1,21,0,0,16,17,11,131088,1,2,7,19,131072,0,20,1,21,0,0,1,3,1,16384,0,5,4,2,16384,0,6,7,6,32768,2,9,5,19,131072,0,27,1,21,0,0,1,4,1,16384,0,6,37,11,131088,0,39,3,1,16384,1,6,4,1,16384,0,5,2,21,0,0,13,17,11,131088,1,2,4,19,131072,0,5,9,11,131088,0,52,4,2,16384,0,6,7,6,32768,1,9,11,11,131088,2,9,17,11,131088,3,0,12,10,131072,0,13,19,3,131075,0,20,10,12,65536,0,11,4,2,16387,2,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,22,4,2,16384,0,6,9,6,32768,0,11,16,19,131072,1,4,17,3,131072,0,18,4,2,16384,0,6,8,6,34816,2,4,9,19,131072,0,10,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,3,1,18432,1,8,3,1,16384,0,4,2,21,0,0,3,11,11,131088,2,6,4,19,131072,1,10,3,1,16384,0,4,2,21,0,0,3,14,11,131088,0,16,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,11,4,23,16384,3,8,4,2,16384,0,6,8,6,32768,1,6,9,19,131072,0,10,20,3,131072,0,21,4,2,16384,0,6,8,6,34816,1,6,4,2,16384,0,6,8,6,32768,0,9,1,21,0,0,2,4,19,131072,4,0,4,23,16385,1,9,3,1,16384,3,7,12,10,131072,0,13,9,3,65539,0,17,8,8,131072,0,10,4,2,16387,0,13,8,8,131072,0,10,6,2,16387,0,12,4,2,16387,0,10,4,2,16387,1,6,4,2,16384,0,5,1,21,0,1,4,4,19,131072,0,44,4,2,16384,1,11,19,11,131088,2,6,4,2,16384,0,5,2,21,0,0,3,4,2,16384,0,5,2,21,0,0,3,4,2,16384,0,5,1,21,0,1,4,4,19,131072,0,32,4,2,16384,0,6,4,2,16384,1,11,19,11,131088,3,2,24,3,131072,0,25,1,21,0,0,1,4,2,16384,0,6,12,6,34816,1,2,24,3,131072,0,25,1,21,0,0,1,4,2,16384,0,6,9,6,34816,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,1,2,4,2,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,1,2,4,2,16384,0,6,6,6,32768,0,7,1,21,0,0,2,4,2,16384,2,2,9,19,131072,0,10,11,3,131072,0,12,4,2,18432,1,2,4,19,131072,0,5,9,11,131088,0,31,4,2,16384,0,6,7,6,32768,0,9,4,6,32784,2,6,6,2,16384,0,7,2,21,0,0,3,6,2,16384,0,8,6,6,32768,0,7,10,6,32768,1,8,6,2,16384,0,8,7,6,32768,0,8,2,21,0,0,3,4,2,16384,0,6,7,6,32768,1,6,4,19,131072,0,99,6,2,16384,0,8,7,6,32768,0,9,4,6,32784,0,6,4,2,16384,0,6,7,6,32768,0,9,4,6,32784,1,13,16,11,131088,5,2,9,19,131072,0,10,13,3,131072,0,14,1,21,0,0,1,4,2,16384,0,6,7,6,34816,2,2,9,19,131072,0,10,8,3,131072,0,9,4,2,16384,0,6,7,6,32768,0,9,1,21,0,0,1,4,2,16384,0,6,5,6,34816,1,2,12,12,65536,0,13,7,1,16387,1,7,5,1,16387,0,6,34,19,131072,1,2,9,19,131072,0,10,12,3,131072,0,13,4,2,16384,0,6,5,6,32768,0,7,5,1,18432,1,2,9,19,131072,0,10,33,3,131072,0,34,5,1,16384,0,7,1,21,0,0,1,7,1,18432,1,2,9,19,131072,0,10,22,3,131072,0,23,7,1,18432,0,24,1,21,0,0,1,4,2,16384,0,6,7,6,32768,2,2,4,2,16384,0,6,7,6,32768,0,8,1,21,0,0,2,15,3,131072,1,2,5,19,131072,0,6,9,11,131088,0,71,4,2,16384,0,6,4,2,16384,0,6,4,2,16384,0,6,4,2,16384,0,6,7,6,32768,0,9,4,2,16384,0,6,5,6,32768,0,7,4,2,16384,0,6,7,6,32768,2,2,4,2,16384,0,6,13,6,32768,0,14,1,21,0,0,2,22,3,131072,0,25,2,21,0,0,5,1,21,0,0,7,1,21,0,1,2,4,2,16384,0,6,13,6,32768,0,14,1,21,0,0,3,15,3,65536,0,16,4,2,18432,0,6,2,21,0,0,3,11,11,131088,0,13,1,21,0,0,7,1,21,0,2,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,1,2,6,3,131584,0,7,4,2,16384,0,6,20,6,34816,0,32,4,2,16384,0,6,20,6,32768,2,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,22,6,34816,1,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,19,6,34816,1,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,23,6,34816,1,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,26,6,34816,1,2,23,3,131072,0,24,1,21,0,0,1,4,2,16384,0,6,29,6,34816,2,2,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,18,1,22,0,0,8,8,8,131072,0,9,1,22,0,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,18,1,22,0,0,8,8,8,131072,0,9,1,22,0,2,16,11,19,131072,0,12,2,21,0,0,10,1,21,0,0,1,4,2,16384,0,6,11,6,32768,0,12,1,21,0,1,16,11,19,131072,0,12,2,21,0,0,10,1,21,0,0,1,4,2,16384,0,6,11,6,32768,0,12,1,21,0,1,2,9,19,131072,0,10,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,11,6,34816,0,13,4,2,16384,0,6,6,6,32768,1,2,9,19,131072,0,10,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,11,6,34816,0,13,4,2,16384,0,6,6,6,32768,3,11,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,2,11,19,131072,0,13,1,1,16384,0,1,2,21,0,0,4,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,2,6,32768,0,3,1,21,0,0,2,1,21,0,2,6,6,2,16384,0,7,2,21,0,0,3,4,19,131072,0,5,2,21,0,0,3,1,21,0,0,1,6,2,16384,0,8,6,6,32768,0,7,10,6,32768,1,11,19,8,131072,0,21,9,1,16387,0,12,4,19,131072,1,4,9,19,131072,0,10,10,19,131072,0,11,1,21,0,0,1,9,1,18432,2,4,9,1,16384,0,11,5,6,32768,0,6,1,21,0,0,2,4,2,16384,1,4,9,1,16384,0,11,8,6,32768,0,9,1,21,0,0,2,4,2,16384,0,6,6,6,32768,1,4,9,19,131072,0,10,10,19,131072,0,11,1,21,0,0,1,9,1,16384,0,11,17,6,34816,0,19,4,2,16384,0,6,6,6,32768,1,4,9,19,131072,0,10,25,3,131072,0,26,1,21,0,0,1,9,1,16384,0,11,12,6,34816,1,4,9,19,131072,0,10,25,3,131072,0,26,1,21,0,0,1,9,1,16384,0,11,10,6,34816,1,4,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,2,9,1,16384,1,4,9,1,16384,0,11,8,6,32768,0,9,1,21,0,2,4,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,2,6,2,16384,0,8,9,6,32768,1,4,27,3,131072,0,28,1,21,0,0,1,6,2,16384,0,8,9,6,32768,0,11,8,6,34816,3,6,4,2,16384,0,6,14,6,32768,0,15,2,21,0,0,3,4,19,131072,1,4,9,19,131072,0,10,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,14,6,34816,0,16,4,2,16384,0,6,6,6,32768,1,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,8,2,21,0,0,2,1,1,16384,1,6,4,2,16384,0,6,14,6,32768,0,15,1,1,16384,0,3,1,21,0,0,2,1,1,16384,3,2,27,3,131072,0,28,1,21,8192,0,1,4,2,16384,2,2,4,2,16384,0,6,8,6,32768,0,9,8,6,32768,0,9,1,21,0,0,2,7,3,131584,0,8,12,19,131072,1,9,11,11,131088,3,7,12,10,131072,0,13,12,3,65539,0,13,10,12,65536,0,11,4,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,6,6,1,16387,0,9,4,2,16384,0,6,6,6,32768,1,9,22,8,131072,0,23,15,1,16387,1,9,22,8,131072,0,24,15,1,16387,0,18,4,19,131072,2,2,13,19,131072,0,14,33,3,131072,0,34,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,12,6,34816,0,15,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,19,19,131072,0,20,1,21,0,0,1,15,1,18432,0,20,4,2,16384,0,6,9,6,32768,0,11,12,6,32768,0,13,10,6,34816,0,13,3,1,16384,0,5,4,23,16384,1,2,20,3,131072,0,21,4,2,18432,0,6,15,1,18432,1,2,4,2,16384,0,6,7,6,32768,0,8,1,21,0,0,2,1,21,0,0,1,15,1,16384,0,17,4,6,32768,1,2,15,1,16384,0,16,4,6,32768,0,5,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,4,6,32768,1,2,15,1,16384,0,16,4,6,32768,0,5,6,6,32768,0,7,1,21,0,0,2,6,1,16384,1,2,15,1,16384,0,16,4,6,32768,0,5,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,4,6,32768,1,2,15,1,16384,0,16,4,6,32768,0,5,6,6,32768,0,7,1,21,0,0,2,4,2,16384,0,6,6,6,32768,1,2,15,1,16384,0,16,4,6,32768,0,5,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,9,6,32768,1,11,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,2,18,19,131072,0,20,1,1,16384,0,1,2,21,0,1,4,15,1,16384,0,16,4,6,32768,0,5,9,6,32768,0,10,1,1,16384,0,3,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,2,2,15,1,16384,0,16,4,6,32768,0,5,12,6,32768,0,13,1,21,0,0,2,4,2,16384,0,6,12,6,32768,1,2,15,1,16384,0,16,4,6,32768,0,5,8,6,32768,0,9,1,21,0,0,2,1,21,0,0,1,15,1,16384,0,17,8,6,32768,2,2,4,2,16384,0,6,13,6,32768,0,14,1,21,0,0,2,22,3,131072,1,8,2,21,0,0,4,4,2,16384,0,6,13,6,32768,0,14,1,21,0,0,3,4,2,16384,0,6,13,6,32768,0,13,1,21,0,1,4,4,19,131072,0,81,4,2,16384,0,6,13,6,32768,1,4,4,2,16384,0,6,13,6,32768,0,14,1,21,0,0,4,2,21,0,2,2,15,1,16384,0,16,4,6,32768,0,5,13,6,32768,0,14,1,21,0,0,2,4,2,16384,0,6,13,6,32768,2,6,11,0,131072,0,12,2,21,0,0,3,4,19,131072,0,5,2,21,0,0,3,26,3,131072,0,29,2,21,0,2,4,13,19,131072,0,14,17,3,65536,0,18,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,14,1,21,0,0,1,4,2,16384,0,6,15,6,34816,0,17,4,2,16384,0,6,13,6,32768,0,15,1,21,0,0,1,4,2,16384,0,6,21,6,34816,0,24,3,1,16384,0,5,4,23,16384,1,4,23,3,131072,0,24,4,2,18432,0,6,4,2,16384,0,6,21,6,34816,3,4,4,2,16384,0,6,21,6,32768,0,22,1,21,0,1,4,13,19,131072,0,14,18,19,131072,0,19,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,14,4,2,16384,0,6,13,6,32768,0,16,3,1,16384,0,5,4,23,16384,1,4,24,3,131072,0,25,4,2,18432,0,6,4,2,16384,0,6,12,6,34816,1,4,4,2,16384,0,6,15,6,32768,0,16,1,21,0,0,2,4,2,16384,0,6,12,6,32768,2,2,15,1,16384,0,16,4,6,32768,0,5,12,6,32768,0,13,1,21,0,0,2,4,2,16384,0,6,15,6,32768,2,2,13,19,131072,0,14,18,19,131072,0,19,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,14,11,19,131072,0,14,3,1,16384,0,5,4,23,16384,1,2,24,3,131072,0,25,4,2,18432,0,6,4,2,16384,0,6,12,6,34816,1,2,4,2,16384,0,6,12,6,32768,0,13,1,21,0,1,2,4,2,16384,0,6,15,6,32768,0,16,1,21,0,2,6,4,2,16384,0,6,22,6,32768,0,23,2,21,0,1,4,13,19,131072,0,14,19,19,131072,0,20,1,21,0,0,1,15,1,16384,0,16,4,6,32768,0,5,22,6,34816,0,24,6,1,16384,0,8,4,2,16384,0,6,9,6,32768,0,11,12,6,32768,0,13,10,6,34816,0,13,3,1,16384,0,5,4,23,16384,1,4,20,3,131072,0,21,4,2,18432,0,6,15,1,16384,0,16,4,6,32768,0,5,22,6,34816,1,4,13,19,131072,0,14,19,3,131072,0,20,15,1,16384,0,16,4,6,32768,0,5,22,6,34816,0,24,4,2,16384,0,6,22,6,34816,0,24,6,1,16384,0,8,4,2,16384,0,6,9,6,32768,0,11,12,6,32768,0,13,10,6,34816,0,13,3,1,16384,0,5,4,23,16384,3,11,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,2,11,19,131072,0,13,1,1,16384,0,1,2,21,0,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,5,6,32768,0,6,1,21,0,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,8,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,1,21,8192,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,16,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,1,21,8192,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,12,6,32768,0,13,1,21,8192,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,12,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,13,6,32768,0,14,1,21,8192,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,13,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,1,21,8192,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,1,4,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,12,6,32768,0,13,1,21,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,32768,0,13,1,1,16384,2,8,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,9,6,32768,0,10,2,21,0,1,6,13,19,131072,0,14,19,3,131072,0,20,15,1,16384,0,16,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,9,6,34816,0,11,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,9,6,34816,0,11,6,1,16384,0,8,4,2,16384,0,6,9,6,32768,0,11,12,6,32768,0,13,10,6,34816,0,13,3,1,16384,0,5,4,23,16384,4,2,13,19,131072,0,14,19,3,131072,0,20,15,1,18432,0,17,1,21,0,0,1,15,1,18432,0,20,4,2,16384,0,6,9,6,32768,0,11,12,6,32768,0,13,10,6,34816,0,13,3,1,16384,0,5,4,23,16384,1,0,4,23,16385,1,2,9,19,131072,0,10,27,3,131072,0,28,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,12,6,34816,1,2,9,19,131072,0,10,23,3,131072,0,24,17,3,131072,0,21,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,12,6,34816,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,4,8,14,19,131073,0,31,3,19,131072,0,4,10,19,131072,0,16,3,19,131072,0,4,10,19,131072,0,16,3,19,131072,0,4,10,19,131072,0,12,11,19,131072,0,20,3,19,131072,0,4,10,19,131072,0,16,3,19,131072,0,4,10,19,131072,1,12,11,3,65539,1,13,5,1,16419,1,6,5,1,16416,0,6,2,21,0,0,5,2,21,0,0,3,14,0,131072,0,15,2,21,0,0,3,16,11,131088,1,4,6,3,131584,0,15,14,19,131072,1,4,6,3,131584,0,7,6,19,131072,1,8,13,0,131072,0,14,2,21,0,0,3,6,19,131072,1,6,4,19,131072,0,5,8,11,131088,0,15,14,19,131072,1,4,5,1,16416,0,6,1,21,0,4,7,12,10,131072,0,13,8,3,65539,0,16,8,8,131072,0,10,4,2,16387,0,13,12,8,131072,0,14,4,2,16387,0,6,8,18,66048,0,9,8,2,16387,1,2,4,2,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,4,6,32768,1,2,4,2,16384,0,6,7,6,32768,0,8,1,21,0,0,2,4,2,16384,0,6,7,6,32768,1,2,4,2,16384,0,6,7,6,32768,0,8,1,21,0,0,2,4,2,16384,0,6,7,6,32768,1,2,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,11,3,131072,0,13,1,21,0,0,1,8,2,16384,1,2,4,2,16384,0,6,7,6,32768,0,7,1,21,0,0,1,10,3,131072,0,12,1,21,0,0,1,8,2,16384,5,9,4,8,131584,0,5,7,1,16387,1,2,8,19,131072,0,9,4,3,131584,0,17,1,21,0,0,1,7,1,18432,1,2,4,2,16384,0,6,6,6,32768,0,7,1,21,0,0,2,7,1,16384,0,8,6,6,33280,2,2,4,2,16384,0,6,5,6,32768,0,6,1,21,0,0,2,4,2,16384,0,6,5,6,32768,2,2,9,19,131072,0,10,17,3,131072,0,18,4,2,18432,0,6,1,21,0,0,1,4,2,16384,0,6,10,6,34816,1,2,4,2,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,1,2,4,2,16384,0,6,11,6,32768,0,12,1,21,0,0,2,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,4,2,16384,0,6,7,6,32768,5,9,5,1,16387,0,6,34,19,131072,1,4,12,12,65536,0,13,7,1,16387,1,4,9,19,131072,0,10,12,3,131072,0,13,4,2,16384,0,6,5,6,32768,0,7,5,1,18432,1,4,9,19,131072,0,10,33,3,131072,0,34,5,1,16384,0,7,1,21,0,0,1,7,1,18432,1,4,4,2,16384,0,6,10,6,32768,0,11,5,6,32768,0,6,1,21,0,0,2,35,19,131072,1,11,31,3,131072,0,32,7,1,18432,0,9,1,21,0,0,1,4,2,16384,0,6,10,6,34816,1,8,4,2,16384,0,6,10,6,32768,0,11,5,6,32768,0,6,2,21,0,0,3,35,19,131072,1,6,4,19,131072,0,5,9,11,131088,1,11,4,2,16384,0,6,5,6,32768,1,20,1,21,0,0,1,4,2,16384,0,6,10,6,32768,0,11,11,6,32768,0,26,1,21,0,0,1,4,2,16384,0,6,10,6,32768,0,11,11,6,32768,1,11,4,2,16384,0,6,10,6,32768,0,11,8,6,32768,0,10,4,2,16384,0,6,10,6,32768,0,11,5,6,32768,0,7,4,2,16384,0,6,10,6,32768,0,11,10,6,32768,4,9,11,11,131088,3,7,12,10,131072,0,13,12,3,65539,0,20,8,8,131072,0,10,4,2,16387,0,10,9,2,16387,0,15,4,2,16387,0,10,6,2,16387,0,13,9,2,16387,1,2,5,19,131072,0,6,9,11,131088,0,32,4,2,16384,0,6,6,2,16384,1,2,9,19,131072,0,10,11,3,131072,0,12,4,2,18432,0,6,9,2,16384,2,9,8,8,131072,0,10,4,1,16387,0,7,1,21,0,0,1,4,2,16384,0,6,8,6,32768,0,9,9,2,16384,0,11,4,6,32768,2,6,6,1,16387,0,10,6,1,16387,1,11,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,2,6,2,16384,0,8,1,1,16384,0,1,2,21,0,1,8,9,2,16384,0,10,1,1,16384,0,3,2,21,0,0,6,6,1,16384,0,7,1,21,0,0,2,1,1,16384,1,8,9,2,16384,0,10,1,1,16384,0,3,2,21,0,0,3,4,2,16384,0,6,6,1,16384,0,7,1,21,0,0,2,1,1,16384,2,2,4,1,16384,0,6,5,6,32768,0,6,1,21,0,0,3,6,1,16384,0,6,1,21,0,0,1,6,1,16384,0,7,1,21,0,0,2,6,2,16384,0,7,1,21,0,0,1,6,2,16384,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,6,2,16384,0,8,1,1,16384,0,1,2,21,0,1,4,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,1,21,0,0,2,9,2,16384,0,11,1,1,16384,0,1,1,21,0,0,1,6,1,16384,0,7,1,21,0,0,1,6,2,16384,2,9,11,11,131088,3,8,19,19,131073,0,21,24,19,131072,0,25,20,19,131072,0,21,10,19,131072,1,8,22,19,131073,0,24,27,19,131072,0,28,23,19,131072,0,24,10,19,131072,1,8,16,19,131073,1,0,10,19,131072,0,33,1,21,0,1,0,10,19,131072,0,38,1,21,0,1,0,10,19,131072,0,44,1,21,0,2,0,10,19,131072,0,52,2,21,0,1,0,10,19,131072,0,52,2,21,0,1,0,10,19,131072,0,52,2,21,0,2,7,12,10,131072,0,13,16,3,65539,0,24,8,8,131072,0,10,4,2,16387,1,6,7,1,16387,0,9,9,1,16387,0,11,8,1,16387,1,2,9,19,131072,0,10,15,3,131072,0,16,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,7,1,18432,0,9,1,21,0,0,1,9,1,18432,0,11,1,21,0,0,1,8,1,18432,2,2,7,18,66048,0,8,4,1,16387,0,5,18,19,131072,0,24,19,3,131072,0,23,22,3,131072,0,26,17,3,131072,1,6,8,1,16387,0,9,18,19,131072,0,24,19,19,131072,0,21,22,19,131072,0,24,16,19,131072,2,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,18,19,131072,0,20,1,1,16384,0,1,2,21,0,1,4,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,1,21,0,0,2,4,1,16384,0,5,1,1,16384,0,3,2,21,0,0,3,1,21,0,0,3,1,21,0,0,2,4,1,16384,0,5,1,1,16384,0,3,1,21,0,0,2,8,1,16384,0,9,1,1,16384,3,6,4,2,16384,0,6,6,6,32768,0,7,1,21,0,0,5,4,2,16384,0,6,12,6,32768,0,13,1,21,0,0,2,24,3,131072,1,11,21,3,131072,0,22,4,2,16384,0,6,4,6,34816,0,7,4,2,16384,0,6,12,6,32768,0,13,1,21,0,0,2,24,3,131072,1,7,4,2,16384,0,6,12,6,32768,0,13,1,21,0,0,2,24,3,131072,3,6,4,2,16384,0,6,12,6,32768,0,13,1,21,0,0,2,10,19,131072,0,11,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,17,19,131072,0,20,4,2,16384,0,6,12,6,32768,0,13,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,17,19,131072,0,18,1,21,0,0,1,10,19,131072,2,6,4,2,16384,0,6,9,6,32768,0,11,5,6,32768,0,6,2,21,0,0,3,4,2,16384,2,4,4,2,16384,0,6,12,6,32768,0,13,1,21,8192,0,11,4,2,16384,0,6,12,6,32768,0,14,4,2,16384,0,6,9,6,32768,0,11,14,6,32768,2,4,4,2,16384,0,6,9,6,32768,0,11,14,6,32768,0,15,1,21,0,0,2,4,2,16384,0,6,12,6,32768,3,2,4,19,131072,0,5,9,11,131088,0,38,4,2,16384,0,6,12,6,32768,1,9,11,11,131088,3,0,10,19,131072,1,0,10,19,131072,1,0,10,19,131072,1,0,10,19,131072,2,7,12,10,131072,0,13,22,3,65539,0,23,10,12,65536,0,11,4,2,16387,1,6,4,1,16387,0,7,4,2,16384,0,6,4,6,32768,1,2,8,18,66048,0,9,11,1,16387,0,20,2,21,0,0,3,4,2,16384,0,6,10,6,32768,0,12,1,21,0,2,2,4,2,16384,0,6,22,6,32768,0,23,1,21,0,0,2,20,3,131072,0,20,1,22,0,0,4,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,14,4,2,16384,0,6,6,6,32768,1,2,4,2,16384,0,6,22,6,32768,0,23,1,21,0,0,2,20,3,131072,0,20,1,22,0,0,4,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,14,4,2,16384,0,6,6,6,32768,2,2,4,2,16384,0,6,22,6,32768,0,23,4,1,16384,0,6,1,21,0,0,2,1,21,0,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,15,6,32768,0,17,1,1,16384,0,1,2,21,0,1,4,11,1,16384,0,12,2,21,0,0,8,2,21,0,0,3,4,2,16384,0,6,15,6,32768,0,16,4,2,16384,0,6,12,6,32768,0,13,1,1,16384,1,8,4,2,16384,0,6,12,6,32768,0,13,1,1,16384,0,3,2,21,0,0,3,4,1,16384,0,8,4,2,16384,0,6,22,6,32768,0,23,4,1,16384,0,6,1,21,0,0,2,1,1,16384,2,6,4,2,16384,0,6,22,6,32768,0,23,4,1,16384,0,6,2,21,0,0,3,1,21,0,1,4,4,2,16384,0,6,22,6,32768,0,23,4,1,16384,0,6,1,21,0,0,2,20,3,131584,0,21,11,1,16384,0,12,1,21,0,0,9,2,21,0,0,3,4,2,16384,0,6,9,6,32768,0,11,1,21,0,2,2,4,2,16384,0,6,22,6,32768,0,23,4,1,16384,0,6,2,21,0,0,3,4,2,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,10,6,32768,2,2,9,19,131072,0,10,18,3,131072,0,19,4,2,16384,0,6,9,6,34816,0,11,4,2,16384,0,6,22,6,34816,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,4,4,2,16384,0,6,22,6,32768,0,23,4,2,16384,0,6,22,6,32768,0,23,1,1,16384,0,4,1,21,0,0,2,1,1,16384,2,9,11,11,131088,3,7,12,10,131072,0,13,15,3,65539,0,16,10,12,65536,0,11,4,2,16387,0,6,10,12,65536,0,11,6,2,16387,0,15,13,8,131072,0,15,12,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,6,4,1,16387,0,7,4,2,16384,0,6,4,6,32768,1,6,16,1,16387,1,6,12,1,16387,0,13,20,19,131072,0,26,13,19,131072,2,6,12,1,16387,1,7,11,1,16387,0,14,4,19,131072,1,6,21,1,16387,0,23,21,1,16387,1,7,4,1,16387,1,7,5,1,16387,2,9,16,8,16387,1,8,12,6,32769,1,8,8,6,32769,2,9,16,8,16384,0,18,5,1,16387,0,8,4,19,131072,2,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,11,1,18432,0,13,12,2,16384,0,14,9,6,32768,0,12,3,1,16384,0,5,4,23,16384,1,4,8,18,66048,0,9,4,1,16387,2,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,12,2,16384,0,14,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,10,4,1,16387,0,7,12,2,16384,0,14,5,6,32768,0,6,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,10,6,32768,0,11,1,21,0,1,6,6,19,131072,0,7,4,2,16384,0,6,10,6,32768,0,11,4,1,16384,0,6,2,21,0,0,3,4,2,16384,0,6,4,6,32768,1,6,8,18,66048,0,9,5,1,16387,0,8,4,1,16384,1,6,4,1,16384,0,5,2,21,0,0,7,2,21,0,0,2,4,2,16384,0,6,15,6,32768,0,16,4,1,16384,1,10,4,1,16384,0,5,2,21,0,0,3,5,1,16384,0,7,11,1,16384,0,12,12,1,16384,0,12,2,21,0,0,4,1,21,0,0,2,4,1,16384,4,2,4,2,16384,0,6,12,6,32768,0,13,1,21,0,0,2,11,1,16384,1,2,4,2,16384,0,6,15,6,32768,0,16,1,21,0,0,2,12,1,16384,1,6,6,2,16384,0,7,2,21,0,0,3,6,2,16384,0,8,14,6,32768,0,15,2,21,0,0,3,6,2,16384,0,8,6,6,32768,0,7,10,6,32768,0,11,2,21,0,0,3,6,2,16384,0,8,6,6,32768,0,7,2,21,0,0,3,4,2,16384,0,6,6,6,32768,1,4,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,5,1,18432,0,7,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,4,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,12,1,16384,0,14,2,21,0,0,2,1,1,16384,1,10,4,1,16387,0,7,7,19,131072,1,13,16,8,16384,0,18,6,1,16387,2,6,5,1,16384,0,6,1,21,0,1,6,6,1,16384,0,7,1,21,0,0,2,5,1,16384,0,6,1,21,0,0,2,4,2,16384,0,6,4,6,32768,1,6,6,3,131584,0,7,6,1,18432,0,25,16,8,16384,2,10,11,1,16384,0,12,1,1,16384,0,3,2,21,0,0,3,4,2,16384,0,6,4,6,32768,1,8,6,1,16384,0,8,12,6,32768,0,13,1,21,0,0,2,1,21,0,1,8,6,1,16384,0,8,8,6,32768,0,9,1,21,0,1,17,2,1,16387,0,8,2,1,16384,0,3,1,21,0,0,2,6,2,16384,0,8,15,6,32768,0,17,2,21,0,0,2,2,1,16384,1,14,6,2,16384,0,8,14,6,32768,0,15,6,2,16384,0,8,12,6,32768,0,13,2,1,16384,0,5,2,21,0,0,3,4,2,16384,0,6,14,6,32768,0,15,4,2,16384,0,6,4,6,32768,1,12,6,1,16384,0,8,12,6,32768,0,13,1,21,0,0,2,2,1,16384,5,6,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,9,6,34816,0,11,5,1,18432,0,21,16,8,16384,0,20,3,1,16384,0,5,4,23,16384,1,15,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,8,2,21,0,0,2,1,1,16384,1,12,5,1,16384,0,6,1,1,16384,0,3,8,6,32768,1,14,4,1,16384,0,5,2,21,0,0,3,7,19,131072,1,12,4,1,16384,0,5,1,21,0,0,2,5,1,16384,0,6,1,1,16384,0,3,12,6,32768,2,14,5,1,16384,0,6,1,1,16384,0,3,12,6,32768,0,13,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,1,16384,0,5,2,21,0,0,3,5,1,16384,0,6,1,1,16384,0,3,12,6,32768,1,12,5,1,16384,0,6,1,21,0,6,10,5,1,16384,1,12,6,1,16384,0,8,8,6,32768,1,10,4,2,16384,0,6,16,6,32768,0,17,1,21,0,0,2,6,2,16384,0,8,16,6,32768,1,19,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,2,21,0,0,2,1,1,16384,1,12,13,19,131072,0,14,18,3,131072,0,19,4,2,18432,0,6,1,1,16384,0,3,6,2,18432,0,15,3,1,16384,0,5,4,23,16384,3,8,13,19,131072,0,14,22,3,65536,0,23,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,5,8,16,1,16384,0,17,1,21,0,1,12,4,2,16384,0,6,4,6,32768,0,5,2,21,0,1,10,4,19,131072,0,88,4,2,16384,0,6,6,6,32768,0,8,6,2,16384,0,8,6,6,32768,2,13,4,23,16384,3,4,5,1,16384,0,6,1,21,0,3,4,9,19,131072,0,10,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,16,6,34816,1,4,4,2,16384,0,6,16,6,32768,0,18,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,9,6,32768,1,4,4,2,16384,0,6,16,6,32768,0,18,8,6,32768,0,9,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,17,19,131072,2,4,13,19,131072,0,14,22,3,65536,0,23,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,2,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,13,11,8,131072,0,13,7,1,16387,0,10,4,2,16384,0,6,8,6,32768,0,9,1,21,0,0,2,1,1,16384,1,6,13,19,131072,0,14,18,3,131072,0,19,4,2,18432,0,6,1,1,16384,0,3,6,2,18432,0,16,3,1,16384,0,5,4,23,16384,1,15,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,12,1,16384,0,14,1,1,16384,0,1,2,21,0,1,18,4,1,16403,0,7,11,1,16384,0,12,1,1,16384,1,8,11,8,131072,0,12,7,1,16387,1,8,16,1,16384,0,17,2,21,0,0,3,25,3,131072,0,26,4,2,18432,0,6,12,2,18432,0,14,7,1,18432,0,9,4,1,16400,0,6,4,1,16400,0,6,1,1,16384,0,3,11,11,65552,0,13,1,21,0,0,1,7,1,18432,1,12,1,21,0,0,1,16,1,16384,0,18,16,1,16384,0,17,2,21,0,0,3,25,3,131072,0,26,4,2,18432,0,6,12,2,18432,0,14,7,1,18432,0,9,4,1,16400,0,6,4,1,16400,0,6,1,1,16384,0,3,11,11,65552,0,13,1,21,0,0,1,7,1,18432,3,10,1,1,16384,0,2,2,21,0,1,8,13,19,131072,0,14,25,3,131072,0,26,4,2,18432,0,6,16,1,16384,0,19,3,1,16384,0,5,4,23,16384,3,4,5,1,16384,0,6,1,21,0,3,6,5,1,16384,1,4,6,3,131584,0,7,4,2,16384,0,6,20,6,34816,0,22,6,2,16384,0,8,20,6,32768,0,29,4,2,16384,0,6,20,6,32768,6,12,11,10,131072,0,12,6,1,16403,0,12,7,11,131088,0,9,8,11,131088,0,10,7,11,131088,0,9,7,11,131088,1,6,7,18,66048,0,9,6,1,16387,0,11,12,11,131088,1,11,6,1,16387,1,6,6,1,16384,0,7,1,21,0,1,6,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,6,1,18432,0,8,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,10,23,16384,1,15,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,12,1,16384,0,14,1,1,16384,0,1,2,21,0,0,4,6,1,16384,0,7,2,21,0,0,4,11,1,16384,0,12,1,1,16384,0,3,2,21,0,0,3,4,2,16384,0,6,4,6,32768,1,10,6,1,16384,1,17,2,1,16387,0,6,2,1,16384,0,3,1,21,0,0,2,12,11,131088,0,14,2,1,16384,0,2,2,21,0,1,19,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,5,1,1,16384,0,1,2,21,0,1,16,7,1,16387,1,12,13,19,131072,0,14,20,3,65536,0,21,4,2,18432,0,7,14,10,131072,0,15,2,1,16384,0,4,6,1,16400,0,7,1,1,16384,0,4,1,21,0,0,1,7,1,18432,0,10,3,1,16384,0,5,10,23,16384,2,12,6,1,16384,0,7,4,1,16384,0,6,6,1,16400,0,7,1,1,16384,0,4,2,1,16384,0,4,1,21,0,0,3,2,21,0,0,3,7,1,16384,0,8,1,21,0,0,4,1,21,0,4,6,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,9,6,34816,0,11,6,1,18432,0,15,1,21,0,0,1,6,1,16384,0,10,3,1,16384,0,5,10,23,16384,1,15,2,1,16387,0,6,2,1,16384,0,3,1,21,0,0,2,12,11,131088,0,14,2,1,16384,0,2,2,21,0,1,17,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,5,1,1,16384,0,1,2,21,0,1,14,2,1,16387,0,5,6,1,16400,0,7,1,1,16384,1,10,7,18,66048,0,8,5,1,16387,1,19,1,1,16387,0,5,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,0,4,5,1,16384,0,6,2,21,0,0,3,6,1,16384,0,7,1,1,16384,0,3,2,1,16384,0,4,2,1,16384,2,10,4,2,16384,0,6,20,6,32768,0,21,2,1,16384,0,4,2,1,16384,0,4,1,21,0,0,3,5,1,16384,0,6,2,21,0,0,5,2,21,0,3,4,10,23,16385,1,6,4,14,256,0,5,6,1,16384,1,10,3,1,16384,0,4,2,21,0,0,3,11,11,131088,0,18,4,23,16384,5,2,13,19,131072,0,14,25,3,131072,0,26,4,2,18432,0,6,16,1,16384,0,19,3,1,16384,0,5,4,23,16384,1,2,5,19,131072,0,6,9,11,131088,0,51,4,1,16384,2,2,4,1,16384,0,8,1,21,0,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,8,8,131072,0,10,5,1,16387,0,8,1,21,0,0,1,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,12,6,32768,1,4,8,3,131584,0,9,4,1,16384,0,5,1,21,0,0,2,6,3,131584,0,7,4,1,16384,0,12,1,21,0,0,2,6,3,131584,0,7,4,1,16384,1,6,1,1,16384,0,3,5,1,16384,0,7,4,6,32768,0,9,4,1,16384,0,6,5,1,16384,0,7,2,6,32768,2,2,4,1,16384,0,11,1,21,0,2,2,4,19,131072,0,5,9,11,131088,0,32,4,1,16384,2,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,11,8,131072,0,13,7,1,16387,0,10,4,2,16384,0,6,8,6,32768,0,9,1,21,0,0,2,1,1,16384,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,6,1,21,0,0,1,7,1,16384,0,9,12,6,32768,0,13,2,6,34816,0,7,7,1,16384,0,9,12,6,32768,0,13,4,6,34816,0,10,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,12,2,18432,0,18,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,11,8,131072,0,13,7,1,16387,0,10,4,2,16384,0,6,8,6,32768,0,9,1,21,0,0,2,1,1,16384,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,6,7,1,16384,0,9,12,6,32768,0,13,4,6,34816,0,9,1,21,0,0,1,7,1,16384,0,9,12,6,32768,0,13,2,6,34816,0,8,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,12,2,18432,0,18,3,1,16384,0,5,4,23,16384,1,2,4,19,131072,0,5,9,11,131088,3,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,11,8,131072,0,13,11,1,16387,0,14,4,2,16384,0,6,8,6,32768,0,9,1,21,0,0,2,1,1,16384,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,3,21,19,131072,0,23,11,1,16384,0,13,13,6,32768,0,14,2,6,34816,0,4,21,19,131072,0,23,11,1,16384,0,13,13,6,32768,0,14,4,6,34816,0,10,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,12,2,18432,0,17,1,21,0,0,1,21,1,18432,0,24,3,1,16384,0,5,4,23,16384,2,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,11,8,131072,0,13,11,1,16387,0,14,4,2,16384,0,6,8,6,32768,0,9,1,21,0,0,2,1,1,16384,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,3,21,19,131072,0,23,11,1,16384,0,13,13,6,32768,0,14,4,6,34816,0,6,21,19,131072,0,23,11,1,16384,0,13,13,6,32768,0,14,2,6,34816,0,8,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,12,2,18432,0,17,1,21,0,0,1,21,1,18432,0,24,3,1,16384,0,5,4,23,16384,4,2,4,2,16384,0,6,25,6,32768,0,26,1,21,0,0,2,12,1,16384,0,13,4,2,16384,0,6,9,6,32768,0,11,1,21,0,0,2,21,1,16384,0,22,1,21,0,0,2,21,1,16384,0,22,1,21,0,0,2,21,1,16384,0,22,1,21,0,0,2,21,1,16384,1,6,5,1,16384,1,4,4,2,16384,0,6,25,6,32768,0,26,1,21,8192,0,11,4,2,16384,0,6,25,6,32768,0,27,6,2,16384,0,8,25,6,32768,2,2,13,19,131072,0,14,27,3,131072,0,28,4,2,16384,0,6,9,6,34816,0,11,4,2,16384,0,6,15,6,34816,0,17,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,10,6,32768,0,12,12,1,18432,0,28,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,10,6,32768,0,12,1,1,16384,0,1,2,21,0,1,8,12,1,16384,0,13,1,1,16384,0,3,1,21,0,0,2,4,2,16384,0,6,25,6,32768,1,6,4,2,16384,0,6,25,6,32768,0,26,1,21,0,0,2,12,1,16384,0,13,1,1,16384,3,2,4,19,131072,0,5,9,11,131088,0,40,4,1,16384,2,0,4,23,16385,1,2,4,14,256,0,5,5,1,16384,1,9,3,1,16384,1,0,4,23,16385,1,2,24,3,131072,0,25,4,2,18432,1,2,4,2,16384,0,6,14,6,32768,0,15,1,21,0,1,7,4,23,16384,4,0,10,19,131072,2,4,14,19,131072,6,11,10,3,65539,0,18,8,8,131072,0,10,4,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,3,6,1,21,0,0,1,15,3,131072,3,6,7,1,16387,1,6,4,1,16387,1,2,8,18,65536,0,9,10,1,16387,1,2,9,19,131072,0,10,13,3,131072,0,14,1,21,0,0,1,7,1,18432,1,2,7,19,131072,0,20,1,21,0,0,1,10,1,16384,0,12,7,1,16384,2,9,5,19,131072,0,27,1,21,0,0,1,4,1,16384,0,56,10,1,16384,1,6,1,21,0,0,1,4,1,16384,2,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,8,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,10,6,32768,0,11,5,6,32768,0,6,2,21,0,0,3,31,19,131072,4,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,7,5,6,32768,0,7,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,2,4,2,16384,0,6,6,6,32768,0,7,2,6,32768,0,3,1,21,0,0,2,4,2,16384,0,6,8,6,32768,0,9,4,2,16384,0,6,4,6,32768,0,6,10,6,32768,0,11,8,6,32768,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,4,20,8,65536,0,22,11,1,16387,0,14,1,21,0,0,1,4,2,16384,0,6,8,6,32768,0,9,4,2,16384,0,6,4,6,32768,0,6,10,6,32768,1,4,20,8,65536,0,22,11,1,16387,0,14,1,21,0,0,1,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,10,6,32768,3,18,1,21,0,0,1,11,1,16384,0,13,11,6,32768,0,15,1,21,0,0,10,11,1,16384,0,13,11,6,32768,0,17,2,21,0,0,11,4,23,16384,1,9,6,3,131584,0,7,11,1,16384,0,13,11,6,32768,0,13,11,1,16384,0,13,11,6,32768,0,13,24,19,131072,0,26,2,21,0,0,6,2,21,0,1,9,11,1,16384,0,13,8,6,32768,0,9,2,21,0,0,3,11,1,16384,0,13,8,6,32768,1,10,1,1,16384,0,2,2,21,0,0,3,4,2,16384,0,6,4,6,32768,1,8,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,7,4,6,32768,2,6,4,2,16384,0,6,6,6,32768,0,7,5,6,32768,0,6,4,2,16384,0,6,6,6,32768,0,7,4,6,32768,0,4,2,21,0,0,4,1,21,0,0,2,1,1,16384,4,2,4,2,16384,0,6,5,6,32768,0,6,1,21,0,0,2,20,3,131072,0,23,2,21,0,0,5,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,7,4,6,32768,0,5,1,21,0,0,4,1,21,0,0,2,20,3,131072,1,2,4,19,131072,0,5,9,11,131088,0,64,4,2,16384,0,6,5,6,32768,0,7,4,2,16384,0,6,6,6,32768,0,7,2,6,32768,0,4,4,2,16384,0,6,6,6,32768,0,7,4,6,32768,0,6,4,2,16384,0,6,10,6,32768,2,6,4,2,16384,0,6,5,6,32768,2,4,19,0,131072,0,20,1,21,0,0,2,25,19,131072,3,9,4,2,16384,0,6,5,6,32768,2,0,4,23,16385,1,6,4,2,16384,0,6,6,6,32768,0,7,5,6,32768,0,7,4,14,256,0,5,4,2,16384,0,6,6,6,32768,0,7,5,6,32768,10,7,12,10,131072,0,13,18,3,65539,0,26,8,8,131072,0,10,4,2,16387,0,13,8,8,131072,0,10,6,2,16387,0,9,4,19,131072,4,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,6,4,1,16387,0,7,4,2,16384,0,6,4,6,32768,1,6,6,1,16387,0,9,4,2,16384,0,6,6,6,32768,1,6,6,1,16387,1,2,9,8,131584,0,10,12,1,16387,1,9,13,8,131072,0,14,9,1,16387,1,9,13,8,131072,0,14,9,1,16387,1,9,13,8,131072,0,14,12,1,16387,1,9,13,8,131072,0,14,9,1,16387,1,9,13,8,131072,0,15,6,1,16387,0,13,1,21,0,0,1,9,1,16384,0,11,1,21,0,0,1,9,1,16384,0,11,1,21,0,0,1,12,1,16384,0,14,1,21,0,0,1,12,1,16384,0,14,1,21,0,0,1,9,1,16384,0,11,1,21,0,0,1,9,1,16384,2,9,9,8,16387,1,8,7,6,32769,1,8,9,6,32769,1,8,12,6,32769,1,10,7,6,32769,1,10,7,6,32769,1,8,9,6,32769,1,8,9,6,32769,1,8,8,6,32769,3,9,13,8,16387,1,11,9,8,16384,0,10,9,6,32769,0,10,19,19,131072,1,11,13,8,131072,0,14,9,6,32769,3,6,13,1,16387,1,9,13,8,16384,0,15,14,1,16387,0,17,4,19,131072,1,9,13,8,131072,0,16,12,1,16387,0,15,4,19,131072,1,7,14,1,16387,0,17,4,19,131072,0,7,17,1,16387,0,20,4,19,131072,1,7,5,1,16387,0,8,4,19,131072,1,7,8,1,16387,0,11,4,19,131072,1,9,18,8,131072,0,19,9,1,16387,1,7,8,1,16387,0,11,4,19,131072,1,7,19,1,16387,0,22,4,19,131072,1,6,11,1,16387,3,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,8,6,32768,0,10,6,1,16384,0,6,1,21,0,0,5,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,8,3,65536,0,9,4,2,18432,0,6,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,4,1,16384,0,6,4,2,16384,0,6,8,6,32768,0,11,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,9,6,34816,0,11,4,2,16384,0,6,8,6,34816,0,24,12,8,131072,0,16,3,1,16384,0,5,4,23,16384,2,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,8,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,8,6,32768,0,9,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,8,6,32768,0,10,6,1,16384,0,6,2,21,0,1,9,1,1,16384,0,2,2,21,0,0,3,4,1,16384,0,6,2,21,0,0,4,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,8,6,32768,0,9,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,8,6,32768,0,10,2,21,0,0,4,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,5,6,32768,0,6,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,5,6,32768,1,6,4,19,131072,0,77,4,1,16384,0,6,1,1,16384,0,3,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,5,6,32768,1,6,3,1,16384,0,4,1,21,0,0,2,16,11,131088,1,11,4,23,16384,6,6,6,1,16384,0,7,1,21,0,0,4,2,21,0,0,3,1,21,0,0,1,10,3,65536,0,11,4,2,18432,0,6,2,21,0,0,3,20,3,131072,0,23,2,21,0,2,4,4,19,131072,1,4,3,1,16384,0,4,1,21,0,0,2,15,11,131088,1,9,4,23,16384,5,8,14,1,16387,0,17,1,21,0,0,4,13,1,16387,0,16,1,21,0,0,4,14,1,16387,4,4,4,2,16384,0,6,14,6,32768,0,15,1,21,0,1,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,11,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,8,6,32768,0,9,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,8,6,32768,1,10,2,21,0,0,4,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,7,6,32768,0,8,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,7,6,32768,2,12,14,1,16384,0,15,2,21,0,0,6,14,1,16384,0,15,1,21,0,0,2,1,1,16384,1,12,1,1,16384,0,2,2,21,0,0,3,4,1,16384,0,6,13,1,16384,0,14,1,21,0,0,2,14,1,16384,1,8,14,1,16384,0,14,2,21,0,1,12,14,1,16384,0,15,2,21,0,0,3,4,1,16384,0,5,2,21,0,0,3,4,1,16384,0,5,2,21,0,0,3,1,1,16384,1,10,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,6,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,9,6,32768,1,10,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,4,10,4,2,16384,0,6,14,6,32768,1,17,1,1,16387,0,4,1,1,16384,0,2,1,21,0,0,5,1,1,16384,0,2,1,21,0,0,2,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,14,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,8,6,32768,0,9,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,8,6,32768,0,9,2,21,0,1,12,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,7,6,32768,0,8,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,7,6,32768,1,12,4,2,16384,0,6,14,6,32768,0,15,1,21,0,8,8,4,2,16384,0,6,5,6,32768,0,7,4,2,16384,0,6,14,6,32768,0,15,1,21,0,2,4,5,19,131072,0,6,9,11,131088,1,8,4,1,16384,0,6,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,7,6,32768,0,9,13,1,16384,0,15,14,1,16384,0,16,14,1,16384,1,8,13,1,16384,0,14,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,14,1,16384,0,15,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,2,16384,0,6,8,6,32768,0,9,14,1,16384,0,16,4,6,32768,0,5,2,21,0,0,3,4,19,131072,1,6,4,19,131072,1,10,4,1,16384,0,6,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,8,6,32768,0,10,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,7,6,32768,1,10,13,1,16384,0,15,14,1,16384,0,16,14,1,16384,1,6,3,1,16384,0,4,1,21,0,0,2,17,11,131088,1,11,4,23,16384,2,11,8,8,131072,0,10,5,1,16387,0,8,4,2,16384,0,6,8,6,32768,0,9,14,1,16384,0,16,4,6,32768,1,4,6,19,131072,0,7,13,1,16384,0,13,2,21,0,0,4,1,21,0,0,2,4,2,16384,0,4,2,21,0,0,2,5,1,16384,0,6,1,21,0,1,4,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,5,1,16384,1,4,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,2,13,1,16384,1,4,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,14,1,16384,1,4,4,2,16384,0,6,17,6,32768,0,18,1,21,0,1,4,4,2,16384,0,6,19,6,32768,0,20,1,21,0,1,4,4,2,16384,0,6,16,6,32768,0,17,1,21,0,4,2,13,19,131072,0,14,17,3,131072,0,18,4,2,18432,0,6,1,21,0,0,1,4,2,16384,0,6,4,6,34816,0,7,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,20,3,131072,0,21,4,2,16384,0,6,4,6,34816,0,6,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,6,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,20,3,131072,0,21,4,2,16384,0,6,4,6,34816,0,6,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,7,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,13,3,131072,0,14,4,2,16384,0,6,4,6,34816,0,7,3,1,16384,0,5,4,23,16384,4,2,13,19,131072,0,14,22,3,131072,0,23,4,2,16384,0,6,4,6,34816,0,6,4,2,16384,0,6,4,6,32768,0,6,1,21,0,0,1,4,2,16384,0,6,11,6,34816,0,14,3,1,16384,0,5,4,23,16384,1,6,9,19,131072,0,10,1,21,0,0,1,4,2,16384,0,6,11,6,32768,1,4,17,3,131584,0,28,9,8,131584,0,12,1,21,0,0,1,12,1,18432,1,4,17,3,131584,0,28,9,8,131584,0,12,1,21,0,0,1,4,2,16384,0,6,11,6,32768,4,6,14,3,65536,0,15,4,2,18432,1,16,13,1,16403,0,16,10,3,131072,1,8,13,1,16400,0,14,2,21,0,0,3,4,19,131072,1,6,4,19,131072,0,5,8,11,131088,0,59,13,1,16400,1,10,6,3,131584,0,7,13,1,16400,0,20,2,21,0,1,8,4,2,16384,0,6,14,6,32768,0,15,1,21,0,6,2,9,19,131072,0,10,12,3,131072,0,13,4,2,18432,3,2,6,3,131584,0,7,1,21,0,0,1,9,1,18432,0,28,13,8,131072,1,2,9,1,16384,0,10,2,6,32768,0,3,1,21,0,1,2,9,1,16384,0,10,7,6,32768,0,8,1,21,0,0,2,22,19,131072,1,2,9,1,16384,0,10,11,6,32768,0,12,1,21,0,1,2,9,1,16384,0,10,11,6,32768,0,12,1,21,0,0,2,11,19,131072,0,11,1,21,0,1,2,13,19,131072,0,14,15,3,131072,0,16,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,2,2,6,3,131584,0,7,1,21,0,0,1,9,1,18432,0,28,13,8,131072,1,2,9,1,16384,0,10,2,6,32768,0,3,1,21,0,1,2,9,1,16384,0,10,7,6,32768,0,8,1,21,0,0,2,31,19,131072,1,2,9,1,16384,0,10,11,6,32768,0,12,1,21,0,0,2,9,1,16384,0,10,9,6,32768,1,2,9,1,16384,0,10,11,6,32768,0,12,1,21,0,0,2,9,1,16384,0,10,9,6,32768,1,2,13,19,131072,0,14,15,3,131072,0,16,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,2,2,6,3,131584,0,7,1,21,0,0,1,12,1,18432,0,31,13,8,131072,1,2,12,1,16384,0,13,2,6,32768,0,3,1,21,0,1,2,12,1,16384,0,13,7,6,32768,0,8,1,21,0,0,2,22,19,131072,1,2,12,1,16384,0,13,7,6,32768,0,8,1,21,0,1,2,12,1,16384,0,13,11,6,32768,0,12,1,21,0,0,2,12,1,16384,0,13,11,6,32768,0,12,1,21,0,0,2,9,1,16384,0,10,9,6,32768,1,6,4,2,16384,0,6,14,6,32768,1,4,13,19,131072,0,14,15,3,131072,0,16,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,12,1,18432,0,15,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,12,1,18432,0,15,3,1,16384,0,5,4,23,16384,3,2,6,3,131584,0,7,1,21,0,0,1,9,1,18432,0,28,13,8,131072,1,2,9,1,16384,0,10,2,6,32768,0,3,1,21,0,1,2,9,1,16384,0,10,7,6,32768,0,8,1,21,0,0,2,22,19,131072,1,2,9,1,16384,0,10,11,6,32768,0,12,1,21,0,1,2,9,1,16384,0,10,11,6,32768,0,12,1,21,0,0,2,11,19,131072,1,6,4,2,16384,0,6,11,6,32768,1,4,13,19,131072,0,14,15,3,131072,0,16,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,6,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,4,2,4,2,16384,0,6,20,6,32768,0,21,1,21,0,0,2,29,3,131072,0,32,2,21,0,2,6,4,2,16384,0,6,4,6,32768,0,5,2,21,0,0,3,26,3,131072,1,11,13,8,131072,0,15,10,1,16387,0,18,1,21,0,0,1,9,1,16384,0,11,1,21,0,0,1,9,1,16384,0,11,1,21,0,0,1,12,1,16384,0,14,1,21,0,0,1,9,1,16384,1,4,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,9,10,1,18432,0,13,3,1,16384,0,5,4,23,16384,4,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,14,1,16384,0,16,6,1,16384,0,9,3,1,16384,0,5,4,23,16384,2,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,19,19,131072,0,21,1,1,16384,0,1,2,21,0,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,7,6,32768,0,8,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,7,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,9,6,32768,0,10,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,9,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,12,6,32768,0,13,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,12,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,7,6,32768,0,8,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,7,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,7,6,32768,0,8,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,7,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,9,6,32768,0,10,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,9,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,9,6,32768,0,10,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,9,6,32768,1,4,14,1,16384,0,15,4,1,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,8,6,32768,0,9,1,21,0,0,2,6,1,16384,0,7,1,1,16384,0,4,8,6,32768,4,2,13,19,131072,0,14,14,3,131072,0,15,4,2,18432,0,6,6,1,18432,0,8,1,21,0,0,1,14,1,16384,0,15,4,1,16384,0,6,9,6,34816,0,12,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,9,6,34816,0,11,14,1,18432,0,23,1,21,0,0,1,14,1,16384,0,18,3,1,16384,0,5,4,23,16384,3,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,14,1,16384,0,16,6,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,17,1,16384,0,19,6,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,10,6,32768,0,12,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,8,4,1,16387,1,8,9,1,16387,0,12,14,1,16384,0,15,1,1,16384,0,3,9,6,32768,0,10,8,6,32768,1,9,4,1,16384,0,4,1,21,0,0,4,4,1,16384,0,4,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,7,2,21,0,0,3,14,1,16384,0,15,4,1,16384,0,6,2,21,0,0,3,9,1,16384,0,11,4,1,16384,0,4,2,21,0,1,8,4,1,16384,0,5,2,21,0,0,3,4,2,16384,0,6,6,6,32768,1,6,4,2,16384,0,6,6,6,32768,0,6,2,21,0,1,6,14,1,16384,0,15,4,1,16384,0,6,1,21,0,0,2,9,1,16384,2,6,17,1,16384,0,18,4,1,16384,0,6,1,21,0,0,2,14,1,16384,0,15,1,1,16384,0,3,9,6,32768,0,10,14,19,131072,0,16,7,6,32768,2,4,4,2,16384,0,6,10,6,32768,0,11,1,1,16384,0,3,1,21,0,0,2,4,1,16384,3,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,15,6,32768,0,17,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,8,4,1,16387,0,7,4,2,16384,0,6,10,6,32768,0,11,1,1,16384,1,4,4,2,16384,0,6,15,6,32768,0,16,1,1,16384,0,3,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,4,1,16384,0,6,10,6,32768,1,4,4,2,16384,0,6,9,6,32768,0,10,4,1,16384,0,6,10,6,32768,0,10,2,21,0,3,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,4,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,15,6,32768,0,17,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,10,6,32768,0,13,3,1,16384,0,5,4,23,16384,2,4,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,10,6,32768,0,11,1,21,0,3,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,8,4,1,16387,0,7,4,2,16384,0,6,10,6,32768,0,11,1,1,16384,1,4,4,2,16384,0,6,9,6,32768,0,10,4,1,16384,0,6,15,6,32768,0,16,4,2,16384,0,6,9,6,32768,0,10,4,1,16384,0,6,10,6,32768,0,10,2,21,0,0,4,1,21,0,0,2,1,1,16384,2,2,4,2,16384,0,6,4,6,32768,0,5,1,21,0,0,2,4,2,16384,0,6,10,6,32768,0,11,4,1,16384,1,2,4,2,16384,0,6,15,6,32768,0,16,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,4,2,16384,0,6,4,6,32768,0,6,15,6,32768,1,2,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,15,6,32768,0,16,4,1,16384,1,2,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,10,4,2,16384,0,6,4,6,32768,0,6,10,6,32768,2,2,5,19,131072,0,6,9,11,131088,1,8,4,1,16384,0,6,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,8,6,32768,0,10,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,10,6,32768,0,12,4,2,16384,0,6,15,6,32768,1,6,4,2,16384,0,6,9,6,32768,0,10,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,2,16384,0,6,15,6,32768,0,19,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,2,16384,0,6,10,6,32768,0,11,2,21,0,1,4,4,19,131072,1,9,4,1,16384,0,6,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,8,6,32768,0,10,4,2,16384,0,6,8,6,32768,0,9,4,1,16384,0,6,7,6,32768,1,9,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,10,6,32768,0,12,4,2,16384,0,6,15,6,32768,1,4,3,1,16384,0,4,1,21,0,0,2,17,11,131088,1,9,4,23,16384,3,2,4,19,131072,0,5,9,11,131088,1,7,4,2,16384,0,6,4,1,16384,0,6,4,2,16384,0,6,6,6,32768,0,8,4,2,16384,0,6,6,6,32768,0,8,4,2,16384,0,6,10,6,32768,0,12,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,5,6,32768,2,2,13,1,16384,0,14,1,21,0,0,2,4,2,16384,0,6,9,6,32768,1,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,12,1,16384,0,14,4,2,16384,0,6,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,4,12,1,16384,0,13,1,1,16384,0,3,1,21,0,0,2,1,21,0,0,1,14,1,16384,0,15,1,1,16384,0,3,9,6,32768,2,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,19,19,131072,0,21,1,1,16384,0,1,2,21,0,10,6,6,1,16384,0,7,23,19,131072,0,26,9,6,32768,0,10,2,21,0,0,6,4,2,16384,0,6,14,6,32768,0,15,1,21,0,1,6,6,1,16384,0,7,14,19,131072,0,17,9,6,32768,0,10,2,21,0,0,6,4,2,16384,0,6,11,6,32768,0,12,1,21,0,0,2,4,2,16384,0,6,12,6,32768,0,13,1,21,0,3,6,4,2,16384,0,6,9,6,32768,0,10,1,21,0,0,2,13,1,16384,3,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,0,4,6,3,131584,0,7,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,9,1,21,0,0,1,1,1,16384,0,3,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,13,1,16384,0,13,1,21,0,0,1,1,1,16384,0,17,11,8,131072,4,6,4,2,16384,0,6,14,6,32768,0,15,2,21,0,1,8,20,1,16387,0,23,29,3,131072,1,8,4,2,16384,0,6,6,6,32768,0,7,1,21,0,0,2,20,1,16384,1,6,4,19,131072,0,5,9,11,131088,0,104,4,2,16384,0,6,6,6,32768,0,8,20,1,16384,1,6,4,2,16384,0,6,14,6,32768,0,15,1,21,0,2,4,4,2,16384,0,6,17,6,32768,0,18,1,21,0,1,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,10,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,10,6,32768,0,11,1,21,0,0,2,21,19,131072,0,21,1,21,0,1,8,4,19,131072,0,82,21,19,131072,0,21,1,21,0,1,8,4,2,16384,0,6,14,6,32768,0,15,1,21,0,3,10,4,2,16384,0,6,9,6,32768,0,10,1,1,16384,0,3,10,6,32768,0,11,1,21,0,2,8,4,2,16384,0,6,17,6,32768,0,18,1,21,0,5,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,5,1,16384,0,7,6,1,16384,0,6,1,21,0,0,1,11,19,131072,0,14,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,15,3,131072,0,16,4,2,18432,0,6,14,1,18432,0,16,17,1,18432,0,19,12,1,18432,0,14,5,1,18432,0,7,6,1,18432,0,8,6,2,18432,0,9,3,1,16384,0,5,4,23,16384,3,2,5,19,131072,0,6,9,11,131088,0,55,4,1,16384,0,6,6,1,16384,0,8,4,2,16384,0,6,9,6,32768,2,7,4,1,16387,1,2,4,1,16384,0,7,1,21,0,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,8,8,131072,0,10,4,1,16387,0,7,1,21,0,0,1,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,1,4,8,3,131584,0,9,4,1,16384,0,4,1,21,0,0,1,6,3,131584,0,7,4,1,16384,0,11,1,21,0,0,1,6,3,131584,0,7,4,1,16384,1,8,1,1,16384,0,3,4,1,16384,0,6,4,6,32768,0,9,4,1,16384,0,6,4,6,32768,0,9,4,1,16384,0,6,4,6,32768,0,9,4,1,16384,0,6,4,1,16384,0,6,2,6,32768,1,4,4,19,131072,0,5,10,11,131088,0,42,1,1,16384,0,3,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,4,6,32768,0,6,4,2,16384,0,6,4,6,32768,0,6,4,2,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,4,6,32768,2,2,4,1,16384,0,11,1,21,0,1,2,4,19,131072,0,5,9,11,131088,0,22,4,1,16384,2,2,13,19,131072,0,14,16,3,65536,0,17,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,3,2,13,19,131072,0,14,26,3,131072,0,27,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,5,6,4,2,16384,0,6,9,6,32768,0,11,5,6,32768,0,6,2,21,0,0,3,4,2,16384,1,4,4,2,16384,0,6,9,6,32768,0,11,13,6,32768,0,14,1,21,0,0,2,4,2,16384,0,6,10,6,32768,1,4,4,2,16384,0,6,9,6,32768,0,11,5,6,32768,0,6,1,21,0,0,2,4,2,16384,0,6,5,6,32768,1,4,4,2,16384,0,6,9,6,32768,0,11,11,6,32768,0,12,1,21,0,0,2,4,2,16384,0,6,9,6,32768,1,4,4,2,16384,0,6,9,6,32768,0,11,14,6,32768,0,15,1,21,0,0,2,4,2,16384,0,6,12,6,32768,1,4,6,3,131584,0,7,4,2,16384,0,6,9,6,32768,0,11,17,6,34816,0,19,4,2,16384,0,6,15,6,32768,0,29,1,21,0,0,2,4,2,16384,0,6,6,6,32768,2,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,19,1,16384,0,21,4,2,16384,0,6,10,6,32768,0,13,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,10,6,32768,0,12,2,21,0,0,2,1,1,16384,1,8,6,1,16387,0,9,4,2,16384,0,6,14,6,32768,0,15,4,2,16384,0,6,15,6,32768,0,16,1,1,16384,1,4,19,1,16384,0,20,1,1,16384,0,3,1,21,0,0,2,4,2,16384,0,6,9,6,32768,0,11,17,6,32768,0,18,6,1,16384,2,2,4,2,16384,0,6,19,6,32768,0,20,1,21,0,0,2,19,1,16384,3,6,6,2,16384,0,7,2,21,0,0,3,6,2,16384,0,8,6,6,32768,0,7,10,6,32768,1,4,4,2,16384,0,6,10,6,32768,0,11,1,21,0,0,2,6,2,16384,0,8,9,6,32768,0,11,10,6,32768,1,4,27,3,131072,0,28,1,21,0,0,1,6,2,16384,0,8,9,6,32768,0,11,10,6,32768,0,12,8,6,32768,2,4,13,19,131072,0,14,15,3,131072,0,16,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,4,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,11,8,131072,0,13,7,1,16387,0,10,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,1,1,16384,1,4,13,19,131072,0,14,12,3,65536,0,13,4,2,18432,0,6,1,1,16384,0,3,4,1,16384,0,6,6,1,16384,0,8,5,1,16384,0,5,1,21,0,0,1,1,1,16384,0,1,1,21,0,0,1,6,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,8,4,2,16384,0,6,6,6,32768,0,7,2,21,0,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,6,1,21,0,0,1,7,1,16384,0,9,4,6,32768,0,5,4,6,34816,0,9,1,21,0,0,1,7,1,16384,0,9,4,6,32768,0,5,4,6,34816,0,10,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,9,1,18432,0,15,3,1,16384,0,5,4,23,16384,1,2,4,19,131072,0,5,9,11,131088,3,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,11,11,8,131072,0,13,7,1,16387,0,10,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,1,1,16384,1,8,4,2,16384,0,6,6,6,32768,0,7,2,21,0,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,3,19,19,131072,0,21,7,1,16384,0,9,4,6,32768,0,5,4,6,34816,0,9,1,21,0,0,1,7,1,16384,0,9,4,6,32768,0,5,2,6,34816,0,8,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,6,1,21,0,0,1,7,1,16384,0,9,4,6,32768,0,5,2,6,34816,0,4,19,19,131072,0,21,7,1,16384,0,9,4,6,32768,0,5,4,6,34816,0,10,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,9,1,18432,0,15,3,1,16384,0,5,4,23,16384,1,2,4,19,131072,0,5,9,11,131088,3,2,13,19,131072,0,14,13,3,131072,0,14,4,2,18432,0,6,6,2,18432,0,9,3,1,16384,0,5,4,23,16384,2,6,4,2,16384,0,6,11,6,32768,0,12,2,21,0,0,3,4,2,16384,0,6,6,6,32768,0,7,1,21,0,1,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,13,11,8,131072,0,13,7,1,16387,0,10,4,2,16384,0,6,8,6,32768,0,8,1,21,0,0,1,1,1,16384,1,6,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,3,24,19,131072,0,26,7,1,16384,0,9,4,6,32768,0,5,8,6,34816,0,13,1,21,0,0,1,7,1,16384,0,9,4,6,32768,0,5,6,6,34816,0,12,3,1,16384,0,5,4,23,16384,1,6,13,19,131072,0,14,23,3,131072,0,24,4,2,18432,0,6,1,1,16384,0,6,1,21,0,0,1,7,1,16384,0,9,4,6,32768,0,5,6,6,34816,0,8,24,19,131072,0,26,7,1,16384,0,9,4,6,32768,0,5,8,6,34816,0,14,3,1,16384,0,5,4,23,16384,2,4,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,9,1,18432,0,15,3,1,16384,0,5,4,23,16384,1,4,4,19,131072,0,5,9,11,131088,4,6,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,5,15,3,65536,0,16,4,2,18432,0,6,6,2,18432,0,8,1,21,0,0,1,12,1,18432,2,2,5,19,131072,0,6,9,11,131088,0,63,4,1,16384,0,6,6,1,16384,0,8,4,2,16384,0,6,9,6,32768,3,2,13,19,131072,0,14,17,3,131072,0,18,4,2,18432,0,6,4,2,16384,0,6,10,6,32768,0,12,4,2,16384,0,6,10,6,32768,0,12,6,1,18432,0,9,3,1,16384,0,5,4,23,16384,2,2,4,19,131072,0,5,9,11,131088,0,113,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,12,6,32768,0,14,4,2,16384,0,6,12,6,32768,0,14,4,2,16384,0,6,19,6,32768,3,11,9,8,131072,0,11,5,1,16387,0,8,1,21,8192,0,1,4,2,16384,1,8,4,1,16387,0,7,4,2,16384,0,6,4,6,32768,1,8,6,1,16387,0,9,4,2,16384,0,6,6,6,32768,1,11,13,8,131072,0,15,9,1,16387,0,12,4,2,16384,0,6,9,6,32768,1,8,9,1,16387,0,12,4,2,16384,0,6,9,6,32768,2,8,5,1,16387,0,8,11,19,131072,0,12,4,2,16384,0,6,13,6,32768,0,15,26,19,131072,0,26,1,21,0,1,4,5,1,16384,0,7,13,6,32768,0,14,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,7,1,21,0,0,2,5,1,16384,1,4,5,1,16384,0,7,5,6,32768,0,6,1,21,8192,0,2,20,3,131072,0,20,1,22,0,0,1,9,8,131072,0,11,4,8,32768,0,4,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,32768,0,14,5,1,16384,0,7,13,6,32768,1,4,5,1,16384,0,7,12,6,32768,0,13,1,21,8192,0,2,20,3,131072,0,20,1,22,0,0,4,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,32768,0,14,5,1,16384,0,7,13,6,32768,1,4,5,1,16384,0,7,12,6,32768,0,13,1,21,8192,0,2,20,3,131072,0,20,1,22,0,0,4,1,22,0,0,2,1,21,0,0,1,4,2,16384,0,6,12,6,32768,0,14,5,1,16384,0,7,13,6,32768,1,8,1,1,16387,3,13,1,1,16387,0,5,1,1,16384,0,2,2,21,0,0,3,6,1,16384,0,6,1,21,0,0,4,1,1,16384,0,1,2,21,0,1,10,6,1,16387,0,14,1,1,16384,0,4,6,1,16384,0,6,1,21,0,0,1,1,1,16384,0,2,1,21,0,0,1,6,1,16384,0,8,6,1,16384,0,6,1,21,0,0,2,1,21,0,0,1,1,1,16384,0,4,6,1,16384,0,6,1,21,0,0,2,6,1,16384,0,6,1,21,0,0,2,1,21,0,0,1,1,1,16384,0,3,1,21,0,0,1,6,1,16384,1,10,5,1,16387,1,10,5,1,16387,0,8,6,1,16384,0,7,5,1,16384,1,4,11,23,16385,1,10,8,1,16387,0,12,4,1,16384,0,4,1,21,0,0,1,6,1,16384,0,6,1,21,0,0,1,5,1,16384,0,6,1,21,0,0,1,6,1,16384,1,10,8,1,16387,0,12,4,1,16384,0,4,1,21,0,0,1,5,1,16384,0,6,1,21,0,0,1,6,1,16384,1,15,4,1,16387,0,8,4,1,16384,0,5,1,21,0,0,2,5,1,16384,0,7,4,1,16384,0,4,2,21,0,1,12,9,1,16387,0,13,9,1,16384,0,9,1,21,0,0,1,4,1,16384,0,4,1,21,0,0,1,5,1,16384,0,6,1,21,0,0,1,5,1,16384,1,12,8,1,16387,0,11,9,1,16384,0,10,1,21,0,0,2,9,1,16384,0,10,8,1,16384,0,10,10,6,32768,0,11,1,21,0,0,2,9,1,16384,0,10,8,1,16384,0,10,15,6,32768,0,16,9,1,16384,0,11,1,21,0,0,2,1,21,0,1,8,5,1,16384,0,7,12,6,32768,0,13,1,1,16384,0,3,1,21,0,0,2,8,1,16384,1,12,9,1,16387,0,13,9,1,16384,0,9,1,21,0,0,1,4,1,16384,0,5,1,21,0,0,1,5,1,16384,1,12,8,1,16387,0,11,9,1,16384,0,10,1,21,0,0,2,9,1,16384,0,10,8,1,16384,0,10,10,6,32768,0,11,1,21,0,0,2,9,1,16384,0,10,8,1,16384,0,10,15,6,32768,0,16,9,1,16384,0,11,1,21,0,0,2,1,21,0,1,8,5,1,16384,0,7,12,6,32768,0,13,1,1,16384,0,3,1,21,0,0,2,8,1,16384,1,8,1,1,16384,0,1,2,21,0,2,6,5,1,16384,0,5,2,21,0,1,10,5,1,16384,0,6,2,21,0,0,5,2,21,0,0,3,6,1,16384,0,10,2,21,0,0,3,6,1,16384,0,11,5,1,16384,0,5,2,21,0,1,10,5,1,16384,0,6,2,21,0,0,5,2,21,0,0,3,6,1,16384,0,10,2,21,0,0,3,6,1,16384,0,11,5,1,16384,0,5,2,21,0,1,10,5,1,16384,0,6,2,21,0,0,5,2,21,0,0,3,6,1,16384,0,10,2,21,0,0,3,6,1,16384,0,11,5,1,16384,0,5,2,21,0,1,10,5,1,16384,0,6,2,21,0,0,5,2,21,0,0,3,6,1,16384,0,10,2,21,0,0,3,6,1,16384,0,11,5,1,16384,0,5,2,21,0,1,10,5,1,16384,0,6,1,21,0,1,8,5,1,16384,0,6,1,21,0,0,2,6,1,16384,0,7,5,1,16384,1,13,11,23,16384,3,4,6,19,131072,0,7,1,1,16384,0,2,2,21,0,0,3,5,1,16384,0,7,13,6,32768,3,6,22,3,131072,2,8,9,1,16387,1,4,13,19,131072,0,14,18,3,131072,0,19,4,2,16384,0,6,4,6,34816,0,6,4,2,16384,0,6,4,6,32768,0,6,1,21,0,0,1,9,1,18432,0,11,1,21,0,0,1,8,1,18432,0,11,3,1,16384,0,5,4,23,16384,1,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,9,1,16384,0,11,1,1,16384,0,1,2,21,0,1,10,4,1,16387,0,7,8,1,16384,0,9,1,1,16384,1,10,9,1,16387,1,15,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,19,6,32768,0,21,1,1,16384,0,1,2,21,0,1,8,13,19,131072,0,14,18,3,65536,0,19,4,2,18432,0,6,4,1,16384,0,6,1,1,16384,0,3,12,11,131088,0,14,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,12,4,2,16384,0,6,8,6,32768,0,9,9,1,16384,0,11,5,6,32768,0,6,4,1,16384,0,7,4,6,32768,0,8,9,6,32768,0,10,2,21,0,1,10,4,2,16384,0,6,11,6,32768,0,12,4,1,16384,0,6,2,21,0,0,7,2,21,0,0,2,9,1,16384,3,15,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,19,6,32768,0,21,1,1,16384,0,1,2,21,0,1,8,13,19,131072,0,14,18,3,65536,0,19,4,2,18432,0,6,4,1,16384,0,6,1,1,16384,0,3,12,11,131088,0,14,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,12,4,2,16384,0,6,8,6,32768,0,9,9,1,16384,0,11,5,6,32768,0,6,4,1,16384,0,7,4,6,32768,0,8,9,6,32768,0,10,2,21,0,1,10,4,2,16384,0,6,11,6,32768,0,12,4,1,16384,0,6,2,21,0,0,7,2,21,0,0,2,9,1,16384,5,4,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,4,19,131072,0,10,3,1,16384,0,5,4,23,16384,4,2,11,1,16384,0,12,1,21,0,0,2,4,2,16384,0,6,14,6,32768,0,15,4,2,16384,0,6,4,6,32768,1,2,13,19,131072,0,14,16,3,131072,0,17,4,2,18432,0,6,13,19,131072,0,18,11,1,16384,0,13,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,9,1,18432,0,11,22,11,131088,0,24,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,27,4,19,131072,0,10,3,1,16384,0,5,4,23,16384,3,6,14,3,131072,0,15,4,2,18432,0,6,2,21,0,1,8,6,1,16387,1,4,13,19,131072,0,14,19,3,131072,0,20,4,2,18432,0,6,1,21,0,0,1,8,1,18432,0,10,1,21,0,0,1,6,1,18432,0,9,3,1,16384,0,5,4,23,16384,1,13,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,6,11,1,16384,0,12,1,21,0,0,2,4,2,16384,0,6,14,6,32768,0,15,8,1,16384,0,9,1,1,16384,1,6,13,19,131072,0,14,16,3,131072,0,17,4,2,18432,0,6,13,19,131072,0,18,11,1,16384,0,13,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,6,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,9,1,18432,0,11,22,11,131088,0,24,1,21,0,0,1,4,2,16384,0,6,12,6,34816,0,27,4,19,131072,0,10,3,1,16384,0,5,4,23,16384,4,6,4,2,16384,0,6,9,6,32768,0,10,2,21,0,1,16,3,1,16403,0,6,10,3,131072,1,9,14,10,131072,0,15,4,1,16387,0,6,7,1,16387,1,8,3,1,16400,0,4,2,21,0,0,3,10,3,131584,0,11,3,1,16400,0,14,2,21,0,1,6,4,1,16384,0,5,1,21,0,0,2,19,11,131088,2,6,4,1,16384,0,5,1,21,0,0,2,22,11,131088,4,4,7,1,16384,0,8,1,21,0,0,22,1,21,0,0,1,19,0,131072,0,21,4,1,16384,0,6,16,19,131072,1,8,7,1,16384,0,8,2,21,0,0,3,21,11,131088,0,22,2,21,0,0,3,3,1,16400,0,4,2,21,0,0,3,3,1,16400,0,6,2,21,0,1,6,4,19,131072,0,5,8,11,131088,0,55,4,1,16384,0,5,2,21,0,0,3,22,11,131088,0,23,1,21,0,0,13,1,21,0,6,2,13,19,131072,0,14,12,3,65536,0,13,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,3,2,13,19,131072,0,14,25,3,131072,0,26,4,2,16384,0,6,9,6,34816,0,11,4,2,16384,0,6,15,6,34816,0,17,4,2,16384,0,6,9,6,32768,0,11,4,2,16384,0,6,10,6,32768,0,12,4,2,16384,0,6,15,6,32768,0,21,3,1,16384,0,5,4,23,16384,4,2,5,19,131072,0,6,9,11,131088,0,39,4,1,16384,0,6,6,1,16384,2,0,4,23,16385,1,6,9,19,131072,0,10,1,21,0,0,1,4,2,16384,0,6,11,6,32768,0,14,17,3,131584,0,28,9,8,131584,0,12,1,21,0,0,1,12,1,16384,4,6,4,2,16384,0,6,9,6,32768,0,11,5,6,32768,0,6,2,21,0,0,3,4,2,16384,0,5,2,21,0,0,3,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,0,11,2,21,0,0,3,3,1,16384,0,4,2,21,0,0,3,11,11,131088,0,13,18,3,131072,0,19,4,2,18432,1,2,4,14,256,0,5,12,1,16384,1,2,4,14,256,0,5,17,1,16384,1,2,4,14,256,0,5,14,1,16384,1,2,4,14,256,0,5,14,1,16384,1,2,4,14,256,0,5,5,1,16384,1,2,4,14,256,0,5,8,1,16384,1,2,4,14,256,0,5,8,1,16384,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,0,10,19,131072,1,0,10,19,131072,0,47,21,19,131072,2,0,10,19,131072,0,32,21,19,131072,1,0,10,19,131072,0,32,21,19,131072,1,8,25,19,131073,2,7,24,8,131075,1,9,12,8,131072,0,13,4,6,32769,1,9,8,8,131072,0,10,4,6,32769,1,9,8,8,131072,0,11,7,6,32769,1,6,7,6,32769,2,6,6,6,32769,0,8,6,6,32769,1,2,12,8,131072,0,13,6,6,32769,2,9,8,8,131072,0,10,6,6,32769,1,6,5,6,32769,0,7,3,6,32769,3,7,24,8,131075,1,9,12,8,131072,0,13,4,6,32769,1,2,10,12,65536,0,11,4,6,32769,3,0,10,19,131072,0,66,21,19,131072,2,7,12,10,131072,0,13,16,3,65539,0,24,8,8,131072,0,10,4,2,16387,0,13,8,8,131072,0,10,6,2,16387,0,12,5,2,16387,0,11,3,2,16387,0,10,9,2,16387,0,16,9,2,16387,0,16,14,2,16387,1,7,6,1,16387,0,9,4,19,131072,1,7,4,1,16387,0,7,4,19,131072,1,6,6,1,16387,0,12,6,1,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,2,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,6,1,16384,0,8,6,2,16384,0,8,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,1,16384,0,6,6,2,16384,0,8,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,3,2,6,1,16384,0,7,6,2,16384,0,8,4,6,32768,0,6,1,21,0,0,2,5,2,16384,1,2,4,1,16384,0,5,6,2,16384,0,8,4,6,32768,0,6,1,21,0,0,2,3,2,16384,1,2,13,19,131072,0,14,18,3,131072,0,19,6,2,16384,0,8,9,6,34816,0,11,6,1,18432,0,22,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,18,3,131072,0,19,6,2,16384,0,8,9,6,34816,0,11,4,1,18432,0,20,3,1,16384,0,5,4,23,16384,3,6,5,2,16384,0,6,2,21,0,0,3,18,19,131072,0,25,4,23,16384,2,2,6,3,131584,0,7,14,2,18432,0,34,1,21,0,0,2,6,2,16384,0,8,6,6,32768,1,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,6,2,16384,0,8,6,6,32768,0,8,1,1,16384,0,1,2,21,0,1,8,6,1,16384,0,7,1,1,16384,0,3,2,21,0,0,3,5,2,16384,2,8,6,1,16387,1,11,6,1,16384,0,7,1,21,0,0,2,6,1,16384,0,7,2,21,0,0,3,4,1,16384,0,5,14,2,16384,0,15,6,1,16384,0,9,2,21,0,0,3,4,1,16384,0,5,1,1,16384,0,4,6,1,16384,0,6,2,21,0,2,13,1,1,16387,0,4,6,1,16384,0,8,1,1,16384,0,2,1,21,0,0,2,6,1,16384,0,8,1,1,16384,0,1,2,21,0,0,4,14,2,16384,0,15,1,1,16384,0,3,1,21,0,0,2,14,2,16384,0,15,1,1,16384,0,2,1,21,0,2,4,14,2,16384,0,15,6,1,16384,0,8,1,21,0,0,2,1,1,16384,1,4,6,1,16384,0,6,2,21,0,3,11,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,6,1,16384,0,8,1,1,16384,0,1,2,21,0,1,8,14,2,16384,0,15,1,1,16384,0,3,2,21,0,0,3,6,2,16384,0,8,4,6,32768,0,6,6,1,16384,0,7,1,21,0,0,2,1,1,16384,3,2,1,21,0,0,1,9,2,16384,0,10,1,21,0,0,2,6,1,16384,1,2,1,21,0,0,1,9,2,16384,0,10,1,21,0,0,2,6,1,16384,2,0,4,23,16385,1,2,4,14,256,0,5,6,1,16384,1,2,4,14,256,0,5,4,1,16384,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,7,12,10,131072,0,13,20,3,65539,0,28,12,8,131072,0,14,4,2,16387,1,9,24,8,131072,0,26,3,1,16387,0,14,24,8,131072,0,26,4,2,16384,1,2,10,12,65536,0,11,4,1,16387,0,7,3,1,16384,0,5,4,6,32768,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,6,9,1,16387,0,11,9,1,16387,1,2,6,18,66048,0,7,17,1,16387,1,6,7,1,16387,0,10,3,1,16384,0,5,7,6,32768,1,7,11,1,16387,0,14,4,19,131072,1,6,8,1,16387,2,2,13,19,131072,0,14,13,3,131072,0,14,7,1,16384,0,10,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,22,3,131072,0,23,1,21,0,0,1,9,1,18432,0,11,33,11,131088,0,35,7,1,16384,0,10,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,22,3,131072,0,23,1,21,0,0,1,9,1,18432,0,11,33,11,131088,0,35,7,1,16384,0,10,3,1,16384,0,5,4,23,16384,1,2,8,1,16384,0,9,1,21,0,0,5,1,21,0,0,1,9,1,16384,0,10,1,21,0,0,4,1,21,0,0,1,9,1,16384,2,2,9,19,131072,0,10,24,3,131072,0,25,8,1,16384,0,10,1,21,0,0,1,17,1,18432,3,6,17,1,16384,0,18,1,21,0,0,4,2,21,0,0,3,21,3,131072,0,24,2,21,0,1,4,5,19,131072,0,6,9,11,131088,0,48,17,1,16384,1,4,15,19,131072,0,16,18,3,131072,0,19,18,11,131088,0,20,17,1,16384,3,6,3,1,16384,0,5,6,6,32768,1,4,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,11,1,16384,0,13,3,1,16384,0,5,6,6,32768,0,8,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,16,3,65536,0,17,4,1,18432,0,6,3,1,16384,0,5,6,6,34816,0,8,3,1,16384,0,5,5,6,32768,0,7,3,1,16384,0,5,3,6,32768,0,5,1,21,0,0,1,3,1,16384,0,5,6,6,34816,0,8,1,21,0,0,1,3,1,16384,0,5,6,6,34816,0,8,11,1,18432,0,14,3,1,16384,0,5,4,23,16384,2,8,3,1,16384,0,5,5,6,32768,0,6,2,21,0,0,3,18,19,131072,0,25,4,23,16384,1,4,8,3,131584,0,16,1,21,0,0,1,3,1,16384,0,5,6,6,32768,0,15,3,1,16384,0,5,6,6,32768,0,22,3,1,16384,0,5,6,6,32768,0,8,8,6,32768,0,10,3,1,16384,0,5,5,6,32768,1,4,13,19,131072,0,14,9,3,65536,0,10,4,1,18432,0,6,3,1,16384,0,5,6,6,34816,0,8,3,1,16384,0,5,6,6,32768,0,8,3,1,16384,0,5,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,14,3,131072,0,23,19,8,131072,0,21,1,21,0,0,1,3,1,16384,0,5,6,6,32768,0,8,4,1,18432,0,6,3,1,16384,0,5,6,6,34816,0,8,3,1,16384,0,5,5,6,32768,0,7,3,1,16384,0,5,3,6,32768,0,5,11,1,18432,0,14,3,1,16384,0,5,4,23,16384,2,4,13,19,131072,0,14,9,3,65536,0,10,4,1,18432,0,6,4,19,131072,0,6,3,1,16384,0,5,6,6,32768,0,8,3,1,16384,0,5,6,6,32768,0,9,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,13,3,131072,0,22,19,8,131072,0,21,1,21,0,0,1,3,1,16384,0,5,6,6,32768,0,8,4,1,18432,0,7,3,1,16384,0,5,4,23,16384,3,2,4,1,16384,0,6,8,6,32768,0,9,1,21,0,0,2,8,1,16384,1,2,4,1,16384,0,6,8,6,32768,0,9,1,21,0,0,2,7,3,131072,0,8,3,1,16384,0,5,6,6,32768,0,7,8,6,32768,0,10,20,19,131072,2,6,3,1,16384,0,5,6,6,32768,1,4,4,19,131072,0,5,9,11,131088,1,4,4,1,16384,0,6,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,6,6,32768,0,8,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,5,6,32768,0,7,3,1,16384,0,5,6,6,32768,0,8,3,1,16384,0,5,5,6,32768,0,7,3,1,16384,0,5,3,6,32768,0,25,12,3,65536,0,13,3,1,16384,0,5,6,6,32768,2,4,4,19,131072,0,5,9,11,131088,1,4,4,1,16384,0,6,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,6,6,32768,0,8,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,5,6,32768,0,27,12,3,65536,0,13,3,1,16384,0,5,6,6,32768,3,2,13,19,131072,0,14,18,3,65536,0,19,4,1,18432,0,6,3,1,16384,0,5,6,6,34816,0,9,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,19,3,131072,0,20,1,21,0,0,1,4,1,16384,0,6,5,6,34816,0,8,3,1,16384,0,5,4,23,16384,1,6,4,1,16384,0,6,5,6,32768,1,4,9,19,131072,0,10,4,1,16384,0,6,5,6,32768,0,7,4,6,32768,0,5,4,1,16384,0,6,6,6,32768,0,8,4,1,16384,0,6,6,6,32768,0,8,12,3,131072,0,14,1,21,0,0,1,4,1,16384,0,6,12,6,32768,4,2,4,1,16384,0,6,9,6,32768,0,10,1,21,0,0,2,11,11,131088,3,6,3,1,16384,0,5,6,6,32768,2,21,1,21,0,0,1,3,1,16384,0,5,6,6,32768,0,8,14,6,32768,0,16,4,19,131072,0,6,16,19,131072,1,4,10,19,131072,1,16,3,1,16384,0,5,6,6,32768,0,8,3,1,16384,0,5,5,6,32768,0,7,3,1,16384,0,5,3,6,32768,0,5,4,1,16384,0,6,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,6,6,32768,2,4,10,19,131072,1,16,4,1,16384,0,6,4,1,16384,0,6,6,6,32768,0,28,12,3,65536,0,13,3,1,16384,0,5,6,6,32768,0,9,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,7,6,32768,3,6,3,1,16384,0,5,6,6,32768,1,4,4,19,131072,0,5,9,11,131088,1,4,4,1,16384,0,6,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,6,6,32768,0,8,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,5,6,32768,0,7,3,1,16384,0,5,6,6,32768,0,8,3,1,16384,0,5,5,6,32768,0,7,3,1,16384,0,5,3,6,32768,0,25,12,3,65536,0,13,3,1,16384,0,5,6,6,32768,2,4,4,19,131072,0,5,9,11,131088,1,4,4,1,16384,0,6,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,6,6,32768,0,8,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,7,6,32768,0,9,4,1,16384,0,6,5,6,32768,0,27,12,3,65536,0,13,3,1,16384,0,5,6,6,32768,3,2,10,19,131072,0,27,4,1,16384,0,6,8,6,32768,0,10,4,1,16384,0,6,10,6,32768,0,12,4,1,16384,0,6,6,6,32768,0,8,4,1,16384,0,6,9,6,32768,0,11,4,1,16384,0,6,12,6,32768,0,14,4,1,16384,0,6,19,6,32768,1,6,12,1,16387,1,6,12,1,16387,0,15,1,21,0,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,1,16384,0,6,9,6,32768,0,11,1,1,16384,0,1,2,21,0,1,6,12,1,16384,0,13,1,1,16384,0,3,1,21,0,0,2,4,1,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,4,6,32768,1,6,12,1,16384,0,13,1,1,16384,0,1,1,21,0,0,4,1,21,0,0,2,4,1,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,2,6,32768,1,6,12,1,16384,0,13,1,1,16384,0,1,1,21,0,0,2,1,21,0,0,4,1,21,0,0,2,4,1,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,4,6,32768,1,6,12,1,16384,0,13,1,1,16384,0,1,1,21,0,0,2,1,21,0,0,4,1,21,0,0,2,4,1,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,4,6,32768,1,6,12,1,16384,0,13,1,1,16384,0,1,1,21,0,0,2,1,21,0,0,4,1,21,0,0,2,4,1,16384,0,6,8,6,32768,0,9,1,1,16384,0,3,4,6,32768,0,5,4,6,32768,2,2,10,19,131072,0,30,4,1,16384,0,6,8,6,32768,0,10,4,1,16384,0,6,4,6,32768,0,6,4,1,16384,0,6,9,6,32768,0,11,12,1,16384,0,14,12,1,16384,2,0,4,23,16385,1,6,3,1,16384,0,5,7,6,32768,2,21,3,1,16384,0,5,7,6,32768,0,9,4,1,16384,0,6,16,19,131072,2,2,4,14,256,0,5,11,1,16384,1,9,3,1,16384,1,0,4,23,16385,1,2,4,1,16384,0,6,9,6,32768,0,10,1,21,0,0,2,3,1,16384,1,7,4,23,16384,3,8,19,19,131073,4,4,4,19,131072,3,7,12,10,131072,0,13,17,3,65539,0,18,10,12,65536,0,11,4,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,14,10,1,16403,0,13,4,2,16384,0,6,6,6,32768,0,7,7,6,32784,1,14,10,1,16403,1,6,11,1,16387,1,6,17,1,16387,1,6,10,1,16387,1,6,10,1,16387,1,6,13,1,16387,3,2,11,1,16384,0,12,1,21,0,0,2,21,3,131072,1,6,11,1,16384,0,12,2,21,0,0,5,2,21,0,0,3,11,1,16384,0,12,2,21,0,1,4,4,2,16384,0,6,6,6,32768,0,7,8,6,32768,0,9,1,21,0,0,2,11,1,16384,2,2,17,1,16384,0,18,1,21,0,0,2,23,3,131072,1,8,2,21,0,0,3,17,1,16384,0,18,2,21,0,0,3,17,1,16384,0,18,2,21,0,0,3,25,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,14,6,32768,0,15,1,21,0,0,2,17,1,16384,1,13,17,1,16384,0,18,1,21,0,0,2,25,19,131072,1,4,4,19,131072,0,73,17,1,16384,0,19,25,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,14,6,32768,0,15,1,21,0,0,2,25,19,131072,3,2,10,1,16384,0,11,1,21,0,0,2,16,3,131072,1,6,10,1,16384,0,11,2,21,0,0,3,21,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,10,1,16384,3,2,10,1,16384,0,11,1,21,0,0,2,16,3,131072,1,6,10,1,16384,0,11,2,21,0,0,3,21,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,10,1,16384,3,2,10,1,16400,0,11,1,21,0,0,2,10,3,131072,1,6,10,1,16400,1,4,10,1,16400,0,11,1,21,0,0,2,10,1,16400,1,6,10,1,16400,0,11,2,21,0,0,3,4,19,131072,1,8,10,1,16387,0,13,6,3,131584,0,7,10,1,16400,0,12,1,21,0,1,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32784,0,8,1,21,0,0,9,6,14,256,0,7,10,1,16384,1,4,6,3,131584,0,14,4,2,16384,0,6,6,6,32768,0,7,7,6,32784,0,9,10,1,16400,0,12,10,1,16384,2,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32784,0,8,1,21,0,0,2,4,19,131072,3,2,13,1,16384,0,14,1,21,0,0,2,32,3,131072,1,6,13,1,16384,0,14,2,21,0,0,3,21,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,0,11,1,21,0,0,2,13,1,16384,4,6,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,11,19,131072,1,4,4,19,131072,0,73,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,9,11,19,131072,0,13,11,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,11,19,131072,3,6,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,11,19,131072,1,4,4,19,131072,0,73,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,9,11,19,131072,0,13,11,19,131072,1,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,11,19,131072,3,6,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,1,4,4,19,131072,0,61,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,9,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,9,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,1,4,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,3,6,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,0,11,2,21,0,0,5,2,21,0,0,3,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,0,11,2,21,0,1,4,4,19,131072,0,62,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,1,4,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,0,11,1,21,0,3,9,3,1,16384,3,7,12,10,131072,0,13,14,3,65539,0,15,10,12,65536,0,11,9,2,16387,0,11,10,12,65536,0,11,6,2,16387,1,2,6,3,131584,0,7,1,21,0,0,1,9,2,16384,0,11,6,6,34816,0,8,1,21,0,0,1,6,2,16384,0,8,6,6,32768,0,15,12,8,65536,1,2,9,19,131072,0,10,17,3,65536,0,18,9,2,18432,1,9,11,11,131088,3,7,12,10,131072,0,13,15,3,65539,0,16,10,12,65536,0,11,4,2,16387,0,6,12,8,65536,0,14,6,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,2,2,12,8,65536,0,13,13,1,16387,0,16,23,19,131072,1,2,12,8,65536,0,13,14,1,16387,0,17,23,19,131072,1,2,12,8,65536,0,14,17,1,16387,1,2,6,18,66048,0,7,8,1,16387,2,2,17,1,16384,0,18,1,21,0,0,2,1,21,0,0,1,14,1,16384,1,6,6,2,16384,1,4,6,3,131584,0,14,1,21,0,0,1,8,1,16384,0,17,6,2,16384,0,15,6,18,66048,1,4,8,1,16384,0,9,1,21,0,0,2,8,1,16384,0,9,1,21,0,0,9,12,8,65536,0,14,1,21,0,0,9,12,8,65536,0,14,1,21,0,0,2,8,1,16384,1,4,6,3,131584,0,14,17,1,16384,0,26,6,2,16384,0,8,8,1,16384,1,8,17,1,16384,0,19,5,6,32768,0,6,2,21,0,1,6,4,19,131072,1,6,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,11,4,23,16384,4,8,17,1,16384,0,19,7,6,32768,0,8,1,21,0,0,2,12,19,131072,1,6,17,1,16384,0,19,8,6,32768,0,9,1,21,0,0,2,13,1,16384,0,14,8,6,32768,3,8,17,1,16384,0,19,7,6,32768,0,8,1,21,0,0,2,12,19,131072,1,6,17,1,16384,0,19,14,6,32768,0,15,1,21,0,0,2,13,1,16384,0,14,14,6,32768,1,6,17,1,16384,0,19,7,6,32768,0,8,1,21,0,0,2,13,1,16384,0,14,7,6,32768,1,6,17,1,16384,0,19,7,6,32768,0,8,1,21,0,0,2,13,1,16384,0,14,7,6,32768,1,6,17,1,16384,0,19,7,6,32784,0,8,1,21,0,0,2,13,1,16384,0,14,7,6,32784,5,6,17,1,16384,0,19,8,6,32768,0,9,2,21,0,0,3,21,19,131072,0,22,2,21,0,0,3,17,1,16384,0,19,8,6,32768,0,9,2,21,0,0,5,2,21,0,0,3,17,1,16384,0,19,8,6,32768,0,9,2,21,0,1,4,4,19,131072,0,51,17,1,16384,0,19,8,6,32768,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,3,6,17,1,16384,0,19,14,6,32768,0,15,2,21,0,0,3,21,19,131072,0,22,2,21,0,0,3,17,1,16384,0,19,14,6,32768,0,15,1,21,0,1,4,4,19,131072,0,57,17,1,16384,0,19,14,6,32768,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,3,7,17,1,16384,0,19,7,6,32768,0,8,2,21,0,0,3,21,19,131072,0,22,2,21,0,1,4,17,1,16384,0,19,7,6,32768,0,8,2,21,0,0,6,2,21,0,1,5,17,1,16384,0,19,7,6,32768,0,8,2,21,0,0,3,21,19,131072,0,22,2,21,0,1,6,17,1,16384,0,19,7,6,32768,0,8,2,21,0,0,6,2,21,0,1,5,17,1,16384,0,19,7,6,32768,0,8,1,21,0,0,2,17,1,16384,0,19,7,6,32768,1,4,4,19,131072,0,62,17,1,16384,0,19,7,6,32768,0,9,17,1,16384,0,19,7,6,32768,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,3,6,17,1,16384,0,19,10,6,32768,0,11,2,21,0,0,3,21,19,131072,0,22,2,21,0,0,3,17,1,16384,0,19,10,6,32768,0,11,2,21,0,0,5,2,21,0,0,3,17,1,16384,0,19,10,6,32768,0,11,2,21,0,1,4,4,19,131072,0,53,17,1,16384,0,19,10,6,32768,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,4,2,19,19,131072,0,20,17,1,16384,0,19,8,6,32768,0,10,21,19,131072,1,2,19,19,131072,0,20,17,1,16384,0,19,14,6,32768,0,16,21,19,131072,1,2,19,19,131072,0,20,17,1,16384,0,19,7,6,32768,0,9,21,19,131072,1,2,19,19,131072,0,20,17,1,16384,0,19,7,6,32768,0,9,21,19,131072,0,23,11,19,131072,1,2,19,19,131072,0,20,17,1,16384,0,19,7,6,32784,0,9,21,19,131072,0,23,4,19,131072,1,2,19,19,131072,0,20,17,1,16384,0,19,10,6,32768,0,12,21,19,131072,3,2,4,2,16384,0,6,6,6,32768,0,7,8,6,32768,0,9,1,21,0,0,2,17,1,16384,0,19,8,6,32768,1,2,4,2,16384,0,6,6,6,32768,0,7,14,6,32768,0,15,1,21,0,0,2,17,1,16384,0,19,14,6,32768,1,2,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,17,1,16384,0,19,7,6,32768,1,2,4,2,16384,0,6,6,6,32768,0,7,7,6,32768,0,8,1,21,0,0,2,17,1,16384,0,19,7,6,32768,1,2,4,2,16384,0,6,6,6,32768,0,7,7,6,32784,0,8,1,21,0,0,2,17,1,16384,0,19,7,6,32784,1,2,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,0,11,1,21,0,0,2,17,1,16384,0,19,10,6,32768,2,2,13,19,131072,0,14,17,3,65536,0,18,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,7,12,10,131072,0,13,19,3,65539,0,20,10,12,65536,0,12,7,2,16387,0,13,6,2,16387,0,8,12,8,131072,0,13,6,2,16387,0,12,6,2,16387,0,12,7,2,16387,0,9,12,8,65536,0,14,6,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,2,10,12,65536,0,11,4,1,16387,0,7,4,19,131072,1,9,24,8,131072,0,26,3,1,16387,0,6,4,19,131072,1,14,3,1,16403,0,6,10,3,131072,1,6,3,1,16400,0,4,2,21,0,0,3,6,2,16384,0,7,2,21,0,1,4,4,19,131072,0,5,8,11,131088,0,51,3,1,16400,1,4,13,19,131072,0,14,19,3,131072,0,28,19,8,131072,0,21,1,21,0,0,1,6,2,16384,0,15,3,1,16384,0,5,4,23,16384,3,2,13,19,131072,0,14,8,3,65536,0,12,3,1,16384,0,5,4,23,16384,1,6,6,2,16384,0,7,2,21,0,0,6,11,3,65536,3,2,13,19,131072,0,14,8,3,131072,0,9,4,19,131072,0,7,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,8,3,131072,0,9,7,2,18432,0,37,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,8,3,131072,0,9,6,2,18432,0,35,3,1,16384,0,5,4,23,16384,1,6,6,2,16384,0,7,1,21,0,0,4,2,21,0,0,3,6,2,16384,0,7,1,21,0,0,4,2,21,0,0,3,6,2,16384,0,7,2,21,0,0,3,6,2,16384,1,4,4,19,131072,0,39,6,2,16384,0,8,6,2,16384,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,3,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,4,1,16384,0,10,3,1,16384,0,5,4,23,16384,1,2,4,1,16384,0,6,10,6,32768,0,11,1,21,0,0,2,4,1,16384,0,6,8,6,32768,0,9,1,21,0,0,2,10,19,131072,1,2,13,19,131072,0,14,18,19,131072,0,20,8,18,66048,0,11,1,21,0,0,1,4,1,16384,0,6,9,6,32768,0,15,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,10,19,131072,0,12,8,18,66048,0,11,1,21,0,0,1,4,1,16384,0,6,17,6,32768,0,23,3,1,16384,0,5,4,23,16384,1,2,1,21,0,0,1,4,1,16384,0,6,17,6,32768,0,18,1,21,0,1,2,13,19,131072,0,14,15,3,65536,0,16,4,1,18432,0,6,6,2,18432,0,9,3,1,16384,0,5,4,23,16384,2,2,4,1,16384,0,6,9,6,32768,0,10,1,21,0,0,2,17,11,131088,1,2,1,21,0,0,1,7,2,16384,0,8,1,21,0,0,2,4,1,16384,2,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,3,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,2,3,1,16384,0,5,4,6,32768,0,5,1,21,0,0,2,4,1,16384,1,2,3,1,16384,0,5,6,6,32768,0,7,1,21,0,0,2,6,2,16384,1,2,3,1,16384,0,5,6,6,32768,0,7,1,21,8192,0,2,6,2,16384,1,2,3,1,16384,0,5,6,6,32768,0,7,1,21,0,0,2,6,2,16384,1,2,3,1,16384,0,5,7,6,32768,0,8,1,21,0,0,2,7,2,16384,1,2,13,19,131072,0,64,4,19,131072,0,19,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,9,17,3,131072,0,18,3,1,16384,1,0,4,23,16385,1,6,4,1,16384,1,8,4,1,16384,0,6,9,6,32768,0,11,16,3,131072,0,25,4,1,16384,0,6,9,6,32768,1,8,4,1,16384,0,6,17,6,32768,0,19,4,14,256,0,5,4,1,16384,0,6,17,6,32768,1,4,4,14,256,0,5,4,1,16384,2,6,7,2,16384,0,9,1,21,0,0,1,7,2,16384,0,8,1,21,0,0,2,4,19,131072,1,7,4,23,16384,3,7,22,8,131075,2,6,4,6,32769,1,6,6,6,32769,1,6,7,6,32769,2,10,24,8,65536,0,25,18,0,65555,1,6,27,19,131072,1,6,27,19,131072,0,57,8,19,131072,0,9,22,8,131072,1,6,27,19,131072,0,56,8,19,131072,0,9,22,8,131072,3,0,8,19,131072,0,9,12,10,131072,0,14,16,3,131073,0,18,10,12,65536,0,12,7,2,16387,0,13,6,2,16387,0,8,12,8,131072,0,13,6,2,16387,0,12,6,2,16387,1,0,12,10,131072,0,13,16,3,131075,0,17,10,12,65536,0,12,7,2,16387,0,13,6,2,16387,0,8,12,8,131072,0,13,6,2,16387,0,12,6,2,16387,2,8,19,3,131072,2,6,7,1,16387,1,2,12,8,65536,0,13,6,1,16387,0,9,23,19,131072,1,2,9,19,131072,0,10,13,3,131072,0,14,1,21,0,0,1,7,1,18432,2,2,22,8,131072,0,23,7,1,16387,0,8,6,2,16384,0,8,6,2,16384,0,8,7,1,16384,1,2,22,19,131072,0,57,7,1,16384,2,2,9,19,131072,0,10,19,3,65536,0,20,7,2,18432,0,9,6,2,16384,0,8,6,2,16384,0,8,6,2,16384,0,8,7,1,16384,0,9,1,21,0,0,1,6,1,18432,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,15,3,131073,0,17,10,12,65536,0,12,5,2,16387,0,11,4,2,16387,0,17,7,2,16403,1,0,12,10,131072,0,13,15,3,131075,0,16,10,12,65536,0,12,5,2,16387,0,11,4,2,16387,0,17,7,2,16403,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,6,9,1,16387,1,7,8,1,16387,0,11,4,19,131072,1,2,12,8,65536,0,13,6,1,16387,0,9,23,19,131072,2,12,24,8,65536,0,25,17,1,16403,1,8,27,19,131072,2,2,22,19,131072,0,55,4,2,16384,3,8,19,3,131072,2,2,13,19,131072,0,14,8,3,131072,0,9,5,2,18432,0,32,3,1,16384,0,5,4,23,16384,1,6,4,2,16384,0,5,1,21,0,1,4,4,19,131072,0,44,4,2,16384,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,3,2,13,19,131072,0,14,18,3,131072,0,19,1,21,0,0,1,9,1,18432,0,12,3,1,16384,0,5,4,23,16384,1,6,7,2,16400,1,4,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,8,1,16384,0,10,9,1,16384,0,12,3,1,16384,0,5,4,23,16384,1,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,2,16384,0,6,2,21,0,0,2,1,1,16384,2,10,7,2,16400,0,8,1,1,16384,0,3,1,21,0,0,4,2,21,0,0,3,7,2,16400,0,8,1,1,16384,0,3,2,21,0,0,3,9,1,16384,1,8,3,1,16384,0,4,1,21,0,0,2,22,11,131088,1,13,4,23,16384,4,10,8,1,16384,0,9,7,2,16400,0,8,1,1,16384,0,4,2,21,0,1,8,3,1,16384,0,4,1,21,0,0,2,16,11,131088,1,13,4,23,16384,3,6,8,1,16384,0,9,7,2,16400,0,8,1,1,16384,0,4,1,21,0,2,4,4,14,256,0,5,8,1,16384,1,4,8,1,16384,0,9,1,21,0,3,2,12,8,131072,0,13,8,1,16387,1,2,13,19,131072,0,14,15,3,131072,0,16,1,21,0,0,1,8,1,18432,0,11,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,14,3,131072,0,18,3,1,16384,0,5,4,23,16384,1,11,1,1,16387,0,5,1,1,16384,0,1,1,21,0,0,1,4,2,16384,0,6,1,1,16384,0,1,2,21,0,2,4,19,3,65536,0,20,5,2,16384,0,5,1,21,0,0,1,1,1,16384,0,3,4,2,16384,0,6,8,1,16384,0,10,1,1,16384,0,3,7,2,16400,0,8,1,21,0,0,2,7,2,16400,0,8,1,1,16384,0,3,1,21,0,0,2,1,1,16384,0,3,1,21,0,0,1,6,1,18432,2,2,13,19,131072,0,14,12,3,131072,0,16,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,2,4,14,256,0,5,8,1,16384,1,9,3,1,16384,3,0,12,10,131072,0,13,21,3,131075,0,22,10,12,65536,0,11,4,2,16387,0,6,12,10,131072,0,13,9,2,16387,1,6,9,2,16384,0,10,1,21,0,0,4,2,21,0,0,3,9,2,16384,0,10,2,21,0,0,3,14,11,131088,0,15,2,21,0,0,3,4,2,16384,0,5,2,21,0,0,3,4,19,131072,1,4,4,19,131072,0,59,4,2,16384,0,6,9,2,16384,1,11,19,11,131088,3,19,1,21,0,0,1,4,2,16384,0,6,11,6,32768,0,13,9,2,16384,0,11,16,19,131072,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,22,3,131073,0,24,10,12,65536,0,12,4,2,16387,0,10,6,2,16387,0,8,12,8,131072,0,13,6,2,16387,0,12,6,2,16387,0,8,12,8,65536,0,14,6,2,16387,1,0,12,10,131072,0,13,22,3,131075,0,23,10,12,65536,0,12,7,2,16387,0,13,6,2,16387,0,8,12,8,131072,0,13,6,2,16387,0,12,6,2,16387,0,8,12,8,65536,0,14,6,2,16387,1,2,19,19,131072,0,20,11,8,131072,1,6,7,1,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,2,12,8,65536,0,13,14,1,16387,0,17,23,19,131072,1,2,12,8,65536,0,14,17,1,16387,0,20,4,19,131072,1,2,9,19,131072,0,10,22,3,131072,2,8,19,3,131072,1,2,13,19,131072,0,14,13,3,131072,0,14,1,21,0,0,1,7,1,18432,0,10,3,1,16384,0,5,4,23,16384,2,6,6,2,16384,0,7,2,21,0,0,3,4,19,131072,1,4,17,1,16384,0,18,1,21,0,0,2,1,21,0,0,1,14,1,16384,2,4,17,1,16384,0,18,1,21,0,0,2,6,2,16384,1,2,13,19,131072,0,14,19,3,65536,0,20,7,2,18432,0,9,6,2,16384,0,8,6,2,16384,0,8,6,2,16384,0,8,7,1,16384,0,9,17,1,18432,0,20,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,2,17,3,131072,0,18,3,1,16384,1,2,9,19,131072,0,10,20,3,131072,1,6,7,2,16384,0,8,2,21,0,0,3,1,21,0,0,1,7,2,16384,0,8,2,21,0,0,3,1,21,0,0,2,1,21,0,0,1,7,2,16384,0,10,6,6,32768,0,7,8,6,32768,0,17,21,3,131072,0,22,1,21,0,0,1,7,2,16384,0,9,1,21,0,0,1,3,1,18432,1,9,3,1,16384,1,0,4,23,16385,1,6,7,2,16384,0,8,2,21,0,0,3,1,21,0,0,1,7,2,16384,0,8,2,21,0,0,3,1,21,0,0,2,1,21,0,0,1,7,2,16384,0,10,6,6,32768,0,7,8,6,32768,0,17,21,3,131072,0,22,1,21,0,0,1,7,2,16384,0,9,3,1,16384,1,7,4,23,16384,3,7,12,10,131072,0,13,15,3,65539,0,23,12,8,131072,0,14,4,2,16387,1,9,24,8,131072,0,26,3,1,16387,0,14,24,8,131072,0,27,4,2,16384,1,2,10,12,65536,0,11,4,1,16387,0,7,3,1,16384,0,5,4,6,32768,1,6,11,1,16387,1,6,10,1,16387,0,13,4,1,16384,0,6,7,6,32768,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,2,2,13,19,131072,0,14,13,3,131072,0,14,1,21,0,0,1,11,1,18432,0,14,3,1,16384,0,5,4,23,16384,1,6,11,1,16384,0,12,2,21,0,0,3,10,1,16384,1,4,13,19,131072,0,14,13,3,131072,0,14,10,1,16384,0,13,3,1,16384,0,5,4,23,16384,3,2,5,19,131072,0,6,9,11,131088,0,69,4,1,16384,0,6,4,1,16384,0,6,4,6,32768,0,6,1,21,0,0,1,4,1,16384,0,6,9,6,32768,0,11,4,1,16384,0,6,11,6,32768,2,6,4,1,16384,0,6,9,6,32768,0,10,2,21,0,0,3,11,11,131088,1,4,13,19,131072,0,14,27,3,131072,0,28,1,21,0,0,1,4,1,16384,0,6,9,6,32768,0,11,10,6,34816,0,13,3,1,16384,0,5,4,23,16384,1,4,13,19,131072,0,14,27,3,131072,0,28,1,21,0,0,1,4,1,16384,0,6,9,6,32768,0,11,12,6,34816,0,15,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,21,3,131072,0,22,4,1,18432,0,14,3,1,16384,0,5,4,23,16384,2,9,4,1,16384,0,6,14,6,32768,0,15,2,21,0,1,4,13,19,131072,0,14,21,3,131072,0,22,4,1,18432,0,26,3,1,16384,0,5,4,23,16384,3,6,11,1,16384,0,12,2,21,0,0,3,10,1,16384,1,4,13,19,131072,0,14,13,3,131072,0,14,11,1,16384,0,14,3,1,16384,0,5,4,23,16384,3,2,4,1,16384,0,6,14,6,32768,0,15,1,21,0,1,0,4,23,16385,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,7,12,10,131072,0,13,11,3,65539,0,12,10,12,65536,0,11,4,2,16387,1,6,11,1,16387,1,6,10,1,16387,0,13,4,2,16384,0,6,7,6,32768,2,2,9,19,131072,0,10,13,3,131072,0,14,1,21,0,0,1,11,1,18432,1,6,11,1,16384,0,12,2,21,0,0,3,10,1,16384,1,4,9,19,131072,0,10,13,3,131072,0,14,10,1,16384,3,6,4,2,16384,0,6,5,6,32768,0,6,2,21,0,0,3,4,19,131072,1,4,9,19,131072,0,10,4,2,16384,0,6,5,6,32768,0,7,7,6,32768,0,8,4,2,16384,0,6,12,6,32768,1,4,9,19,131072,0,10,21,3,131072,0,22,1,21,0,0,1,4,2,16384,0,6,5,6,34816,3,2,9,19,131072,0,10,8,3,65536,0,9,4,2,18432,2,6,11,1,16384,0,12,2,21,0,0,3,10,1,16384,1,4,9,19,131072,0,10,13,3,131072,0,14,11,1,16384,3,9,11,11,131088,3,7,12,10,131072,0,13,12,3,65539,0,13,10,12,65536,0,11,4,2,16387,0,11,10,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,9,24,8,131072,0,26,3,1,16387,0,6,4,19,131072,3,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,3,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,2,3,1,16384,0,5,4,6,32768,0,5,1,21,0,0,2,4,2,16384,2,6,10,2,16384,1,4,13,19,131072,0,59,4,19,131072,0,19,3,1,16384,0,5,4,23,16384,2,4,13,19,131072,0,14,15,3,65536,0,16,1,21,0,0,1,3,1,16384,0,5,4,6,34816,0,7,3,1,16384,0,5,4,23,16384,1,4,4,14,256,0,5,3,1,16384,3,0,4,23,16385,1,9,17,3,131072,0,18,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,0,8,19,131072,0,9,12,10,131072,0,14,16,3,131073,0,18,10,12,65536,0,11,4,2,16387,1,0,12,10,131072,0,13,16,3,131075,0,17,10,12,65536,0,11,4,2,16387,1,2,19,19,131072,0,20,11,8,131072,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,2,2,9,19,131072,0,10,22,3,131072,1,6,4,2,16384,0,5,2,21,0,0,3,4,19,131072,0,11,4,23,16384,3,2,13,19,131072,0,14,19,3,131072,0,20,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,3,6,4,2,16384,0,6,14,6,32768,1,4,3,1,16384,0,4,1,21,0,0,2,19,11,131088,1,9,4,23,16384,4,2,3,1,16384,0,4,1,21,0,0,2,12,3,65536,0,13,4,2,18432,2,0,4,23,16385,1,2,17,3,131072,0,18,3,1,16384,1,2,9,19,131072,0,10,20,3,131072,1,6,4,2,16384,0,5,2,21,0,0,3,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,7,8,6,32768,0,12,9,19,131072,0,10,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,3,1,18432,1,9,3,1,16384,1,0,4,23,16385,1,6,4,2,16384,0,5,2,21,0,0,3,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,7,8,6,32768,0,17,21,3,131072,0,22,4,2,18432,0,6,3,1,16384,1,7,4,23,16384,3,7,12,10,131072,0,13,11,3,65539,0,12,10,12,65536,0,11,4,2,16387,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,2,12,10,131072,0,13,5,1,16387,1,6,7,1,16387,2,2,13,19,131072,0,14,21,3,131072,0,22,4,2,18432,0,6,1,21,0,0,1,5,1,18432,0,8,3,1,16384,0,5,4,23,16384,1,2,5,19,131072,0,6,9,11,131088,0,60,4,2,16384,0,6,4,2,16384,0,6,4,6,32768,0,6,5,1,16384,1,6,5,1,16384,0,6,2,21,0,0,3,11,11,131088,0,12,2,21,0,0,19,4,2,16384,0,6,9,6,32768,0,11,16,19,131072,0,18,2,21,0,0,5,2,21,0,0,3,4,2,16384,0,6,14,6,32768,0,15,2,21,0,3,4,13,19,131072,0,14,12,3,65536,0,13,4,2,18432,0,14,3,1,16384,0,5,4,23,16384,3,6,4,2,16384,0,6,10,6,32768,0,11,2,21,0,0,3,4,19,131072,1,8,10,1,16387,1,8,10,1,16387,0,13,4,2,16384,0,6,10,6,32768,1,4,10,12,65536,0,11,10,1,16387,0,13,4,2,16384,0,6,10,6,32768,1,9,15,1,16387,0,18,1,21,0,0,1,10,1,16384,0,12,15,6,32768,2,4,6,19,131072,0,7,10,1,16384,0,11,2,21,0,0,3,4,19,131072,0,5,2,21,0,0,3,15,1,16384,0,16,2,21,0,0,3,4,19,131072,1,4,10,1,16384,0,11,1,21,0,0,21,15,1,16384,0,20,16,19,131072,1,8,10,1,16384,0,11,2,21,0,0,3,10,1,16384,1,6,10,12,65536,0,11,12,1,16387,1,6,10,12,65536,0,11,13,1,16387,0,16,10,1,16384,4,13,13,1,16384,1,8,12,1,16384,0,13,1,21,0,0,2,13,1,16384,1,8,7,1,16384,0,8,1,21,0,0,2,12,1,16384,0,14,4,6,32768,1,8,13,1,16384,0,14,1,21,0,0,2,13,1,16384,0,15,9,6,32768,2,12,12,1,16384,0,14,14,6,32768,0,15,2,21,0,1,17,24,8,131072,0,25,3,1,16387,1,10,3,1,16384,0,4,4,6,32768,0,5,1,21,0,0,2,12,1,16384,2,15,3,1,16384,0,4,1,21,0,0,2,15,3,65536,0,24,12,8,131072,0,15,1,21,0,0,1,3,1,16384,0,6,2,21,0,0,3,11,11,131088,1,12,4,19,131072,0,60,12,1,16384,0,14,7,1,16384,0,9,3,1,16384,15,6,13,1,16384,0,14,1,21,0,0,2,10,1,16384,1,13,13,1,16384,1,8,12,1,16384,0,13,1,21,0,0,2,13,1,16384,1,8,7,1,16384,0,8,1,21,0,0,2,12,1,16384,0,14,4,6,32768,1,8,13,1,16384,0,14,1,21,0,0,2,13,1,16384,0,15,9,6,32768,3,13,3,1,16384,0,4,1,21,0,0,2,13,3,131072,0,14,12,1,18432,0,15,2,21,0,0,3,11,11,131088,1,10,4,19,131072,0,74,12,1,16384,0,14,7,1,16384,0,9,3,1,16384,5,6,13,1,16384,0,14,1,21,0,0,2,10,1,16384,1,13,13,1,16384,1,8,12,1,16384,0,13,1,21,0,0,2,13,1,16384,1,8,7,1,16384,0,8,1,21,0,0,2,12,1,16384,0,14,4,6,32768,1,8,13,1,16384,0,14,1,21,0,0,2,13,1,16384,0,15,9,6,32768,2,13,3,1,16384,0,4,1,21,0,0,2,11,3,65536,0,12,12,1,18432,0,15,2,21,0,0,3,11,11,131088,1,10,4,19,131072,0,79,12,1,16384,0,14,7,1,16384,0,9,3,1,16384,6,0,4,23,16385,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,0,8,19,131072,0,9,12,10,131072,0,14,15,3,131073,0,17,10,12,65536,0,11,4,2,16387,1,0,12,10,131072,0,13,15,3,131075,0,16,10,12,65536,0,11,4,2,16387,1,6,4,2,16384,0,5,2,21,0,0,3,4,19,131072,1,4,19,19,131072,0,20,11,8,131072,1,11,11,11,131088,3,6,4,1,16387,0,7,4,2,16384,0,6,4,6,32768,0,6,6,1,16387,0,9,4,2,16384,0,6,6,6,32768,0,8,7,1,16387,0,10,4,2,16384,0,6,7,6,32768,2,2,22,8,131072,0,23,7,1,16387,0,8,4,1,16384,0,6,6,1,16384,0,8,7,1,16384,1,2,22,19,131072,0,56,7,1,16384,2,2,7,18,66048,0,8,5,1,16387,0,8,4,2,16384,0,6,5,6,32768,1,2,5,19,131072,0,6,9,11,131088,0,61,4,2,16384,0,6,4,1,16384,0,6,6,1,16384,0,8,7,1,16384,0,9,5,1,16384,2,6,4,2,16384,0,6,4,6,32768,0,5,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,2,16384,0,6,6,6,32768,0,7,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,2,16384,0,6,7,6,32768,0,8,2,21,0,0,3,1,21,0,0,3,2,21,0,0,3,4,2,16384,0,6,5,6,32768,0,6,2,21,0,0,3,1,21,0,1,4,4,19,131072,0,43,4,2,16384,1,11,19,11,131088,4,2,9,19,131072,0,10,19,3,131072,0,20,4,2,18432,2,2,9,19,131072,0,10,11,3,65536,0,12,4,2,18432,1,2,4,19,131072,0,5,9,11,131088,0,79,4,2,16384,0,6,4,1,16384,0,6,6,1,16384,0,8,7,1,16384,0,9,5,1,16384,2,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,13,3,131073,0,15,10,12,65536,0,11,4,2,16387,1,0,12,10,131072,0,13,13,3,131075,0,14,10,12,65536,0,11,4,2,16387,1,6,4,2,16384,0,5,2,21,0,0,3,4,19,131072,1,4,19,19,131072,0,20,11,8,131072,1,11,11,11,131088,3,11,8,18,66048,0,10,14,1,16387,1,6,4,1,16387,0,7,4,2,16384,0,6,4,6,32768,0,6,6,1,16387,0,9,4,2,16384,0,6,6,6,32768,0,8,7,1,16387,0,10,4,2,16384,0,6,7,6,32768,2,2,22,8,131072,0,23,7,1,16387,0,8,4,1,16384,0,6,6,1,16384,0,8,7,1,16384,1,2,22,19,131072,0,54,7,1,16384,2,2,7,18,66048,0,8,5,1,16387,0,8,4,2,16384,0,6,5,6,32768,1,2,5,19,131072,0,6,9,11,131088,0,61,4,2,16384,0,6,4,1,16384,0,6,6,1,16384,0,8,7,1,16384,0,9,5,1,16384,3,2,14,1,16384,0,15,1,21,0,0,18,1,21,0,0,1,4,2,16384,0,6,14,6,32768,0,16,16,19,131072,1,6,14,1,16384,0,15,2,21,0,0,3,4,19,131072,1,21,14,1,16384,0,19,16,19,131072,2,19,4,2,16384,0,6,9,6,32768,0,14,16,19,131072,3,2,19,3,131072,0,20,4,2,18432,2,9,11,3,65536,0,12,4,2,18432,1,2,4,19,131072,0,5,9,11,131088,0,77,4,2,16384,0,6,4,1,16384,0,6,6,1,16384,0,8,7,1,16384,0,9,5,1,16384,2,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,13,3,131073,0,15,10,12,65536,0,11,4,2,16387,0,10,5,2,16387,0,11,3,2,16387,0,5,10,12,65536,0,12,7,2,16387,0,9,12,8,65536,0,14,6,2,16387,1,0,12,10,131072,0,13,13,3,131075,0,14,10,12,65536,0,11,4,2,16387,0,10,5,2,16387,0,11,3,2,16387,0,5,10,12,65536,0,12,7,2,16387,0,9,12,8,65536,0,14,6,2,16387,1,9,24,8,131072,0,26,3,1,16387,0,6,4,19,131072,1,9,8,8,131072,0,10,9,1,16387,0,12,14,19,131072,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,2,2,9,19,131072,0,10,22,3,131072,1,2,13,19,131072,0,14,9,3,131072,0,10,4,2,18432,0,28,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,8,3,131072,0,9,7,2,18432,0,34,3,1,16384,0,5,4,23,16384,1,2,13,19,131072,0,14,19,3,131072,0,20,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,3,2,1,21,0,0,1,7,2,16384,0,8,1,21,0,0,2,14,19,131072,1,6,5,2,16384,0,6,2,21,0,0,3,18,19,131072,1,4,4,19,131072,0,5,9,11,131088,0,89,4,2,16384,0,6,4,6,32768,2,4,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,9,1,16384,0,15,3,1,16384,0,5,4,23,16384,1,4,9,1,16384,0,11,10,6,32768,0,11,1,21,0,0,2,9,1,16384,0,11,8,6,32768,0,9,1,21,0,0,2,10,19,131072,1,8,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,1,6,9,1,16384,0,11,9,6,32768,0,10,1,21,0,0,2,4,2,16384,0,6,9,6,32768,1,6,9,1,16384,0,11,17,6,32768,0,18,1,21,0,0,2,4,2,16384,0,6,17,6,32768,1,6,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,2,4,19,131072,1,6,27,3,131072,0,28,4,2,16384,0,6,17,6,32768,2,6,13,19,131072,0,14,18,19,131072,0,20,8,18,66048,0,11,1,21,0,0,1,9,1,16384,0,11,9,6,32768,0,15,3,1,16384,0,5,4,23,16384,1,6,13,19,131072,0,14,10,19,131072,0,12,8,18,66048,0,11,1,21,0,0,1,9,1,16384,0,11,17,6,32768,0,23,3,1,16384,0,5,4,23,16384,2,6,4,2,16384,0,6,14,6,32768,0,15,1,21,0,0,2,9,1,16384,0,11,9,6,32768,1,6,1,21,0,0,1,9,1,16384,0,11,17,6,32768,0,18,1,21,0,2,8,6,2,16384,0,7,2,21,0,0,3,4,19,131072,1,6,13,19,131072,0,14,14,3,65536,0,15,9,1,18432,0,11,4,2,18432,0,7,3,1,16384,0,5,4,23,16384,2,6,13,19,131072,0,14,15,3,65536,0,16,9,1,18432,0,11,6,2,18432,0,9,3,1,16384,0,5,4,23,16384,4,4,9,1,16384,0,11,9,6,32768,0,10,1,21,0,0,2,17,11,131088,3,2,13,19,131072,0,14,10,19,131072,0,11,1,21,0,0,1,3,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,2,3,1,16384,0,5,4,6,32768,0,5,1,21,0,0,2,9,1,16384,1,2,3,1,16384,0,5,7,6,32768,0,8,1,21,0,0,2,7,2,16384,1,2,3,1,16384,0,5,6,6,32768,0,7,1,21,0,0,2,4,2,16384,1,2,3,1,16384,0,5,5,6,32768,0,6,1,21,0,0,2,5,2,16384,1,2,3,1,16384,0,5,3,6,32768,0,4,1,21,0,0,2,3,2,16384,1,2,3,1,16384,0,5,7,6,32768,0,8,1,21,0,0,2,4,2,16384,0,6,7,6,32768,1,2,13,19,131072,0,64,4,19,131072,0,19,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,2,17,3,131072,0,18,3,1,16384,1,2,9,19,131072,0,10,20,3,131072,1,9,3,1,16384,1,0,4,23,16385,1,6,9,1,16384,1,8,4,2,16384,0,5,2,21,0,0,3,1,21,0,0,1,4,2,16384,0,6,6,6,32768,0,7,10,6,32768,1,10,9,1,16384,0,11,9,6,32768,0,11,16,3,131072,0,24,9,1,16384,0,11,9,6,32768,1,10,9,1,16384,0,11,17,6,32768,0,19,4,14,256,0,5,9,1,16384,0,11,17,6,32768,2,4,4,14,256,0,5,9,1,16384,2,6,7,2,16384,0,9,1,21,0,0,1,7,2,16384,0,8,1,21,0,0,2,4,19,131072,1,7,4,23,16384,3,0,8,19,131072,0,22,18,3,131073,0,20,12,10,131072,0,13,4,2,16387,1,12,18,3,131075,0,19,12,10,131072,0,13,4,2,16387,1,10,4,2,16384,1,9,11,11,131088,1,9,22,11,131088,1,9,15,11,131088,1,9,17,11,131088,1,9,19,11,131088,1,9,16,11,131088,1,9,15,11,131088,1,9,14,11,131088,8,0,8,19,131072,0,22,16,3,131073,0,24,10,12,65536,0,11,4,2,16403,1,12,16,3,131075,0,17,10,12,65536,0,11,4,2,16387,1,9,13,0,131072,3,0,8,19,131072,0,9,12,10,131072,0,14,21,3,131073,0,23,10,12,65536,0,11,4,2,16387,0,6,12,10,131072,0,14,10,2,16387,1,0,12,10,131072,0,13,21,3,131075,0,22,10,12,65536,0,11,4,2,16387,0,6,12,10,131072,0,14,10,2,16387,1,2,9,19,131072,0,10,9,3,131072,0,10,4,2,18432,1,2,9,19,131072,0,10,8,3,131072,0,9,10,2,18432,2,2,1,21,0,0,1,10,2,16384,0,11,1,21,0,0,18,1,21,0,0,1,4,2,16384,0,6,11,6,32768,0,13,16,19,131072,1,6,1,21,0,0,1,10,2,16384,0,11,2,21,0,0,3,11,11,131088,0,12,2,21,0,0,3,4,2,16384,0,6,10,6,32768,0,12,1,21,0,0,1,10,2,16384,0,11,1,21,0,0,18,1,21,0,0,1,4,2,16384,0,6,10,6,32768,0,12,11,6,32768,0,13,16,19,131072,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,13,3,131073,0,21,10,12,65536,0,11,4,2,16403,0,11,5,2,16387,1,0,12,10,131072,0,13,13,3,131075,0,20,10,12,65536,0,11,4,2,16403,0,11,5,2,16387,1,2,19,19,131072,0,20,11,8,131072,2,2,9,19,131072,0,10,9,3,131072,0,10,4,2,18448,1,2,9,19,131072,0,10,8,3,131072,0,9,5,2,18432,3,2,9,19,131072,0,10,19,3,131072,0,20,4,2,18448,2,2,1,21,0,0,1,5,2,16384,0,6,1,21,0,0,2,4,2,16400,0,6,6,6,32768,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,16,3,131073,0,24,10,12,65536,0,11,4,2,16403,0,11,5,2,16387,1,0,12,10,131072,0,13,16,3,131075,0,23,10,12,65536,0,11,4,2,16403,0,11,5,2,16387,1,2,19,19,131072,0,20,11,8,131072,2,2,9,19,131072,0,10,9,3,131072,0,10,4,2,18448,1,2,9,19,131072,0,10,8,3,131072,0,9,5,2,18432,2,2,9,19,131072,0,10,19,3,131072,0,20,4,2,18448,2,2,1,21,0,0,1,5,2,16384,0,6,1,21,0,0,2,4,2,16400,0,6,7,6,32768,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,16,3,131073,0,24,10,12,65536,0,11,4,2,16403,0,11,4,2,16387,1,0,12,10,131072,0,13,16,3,131075,0,23,10,12,65536,0,11,4,2,16403,0,11,4,2,16387,1,2,19,19,131072,0,20,11,8,131072,2,2,9,19,131072,0,10,9,3,131072,0,10,4,2,18448,1,2,9,19,131072,0,10,8,3,131072,0,9,4,2,18432,2,2,9,19,131072,0,10,19,3,131072,0,20,4,2,18448,2,2,1,21,0,0,1,4,2,16384,0,5,1,21,0,0,2,4,2,16400,0,6,4,6,32768,1,9,11,11,131088,3,0,8,19,131072,0,9,12,10,131072,0,14,12,3,131073,0,21,3,2,16387,0,5,6,18,66048,0,7,4,2,16387,1,0,12,10,131072,0,14,12,3,131075,0,20,3,2,16387,0,5,6,18,66048,0,7,4,2,16387,1,2,19,19,131072,0,20,11,8,131072,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,2,4,14,19,131072,1,2,6,18,66048,0,7,7,1,16387,1,2,6,18,66048,0,7,6,1,16387,1,2,8,18,65536,0,9,10,1,16387,1,2,19,8,65536,0,20,7,1,16387,1,2,21,8,65536,0,22,6,1,16387,1,2,15,8,65536,0,16,10,1,16387,1,2,28,18,65536,0,29,6,1,16387,1,6,7,1,16387,1,6,4,1,16387,1,6,4,1,16387,1,6,9,1,16387,2,6,3,2,16384,0,4,2,21,0,0,3,4,19,131072,0,5,2,21,0,0,3,4,2,16384,0,5,2,21,0,0,11,8,23,16384,2,6,19,3,131072,0,22,2,21,0,0,3,11,11,131088,0,18,8,23,16384,2,2,9,19,131072,0,10,13,3,131072,0,14,1,21,0,0,1,7,1,18432,1,2,7,19,131072,0,20,1,21,0,0,1,10,1,16384,0,12,7,1,16384,1,6,5,19,131072,0,25,2,21,0,0,3,4,19,131072,1,4,7,19,131072,0,29,1,21,0,0,1,9,1,16384,0,11,39,11,131088,0,41,10,1,16384,2,6,9,1,16384,1,4,7,1,16384,0,8,4,6,32768,0,5,1,21,0,0,2,29,11,131088,1,4,7,1,16384,0,8,8,6,32768,0,9,4,6,32768,0,5,1,21,0,0,2,27,11,131088,1,4,7,1,16384,0,8,20,6,32768,0,21,1,21,0,0,2,19,0,131072,1,4,7,1,16384,0,8,8,6,32768,0,9,2,6,32768,0,3,1,21,0,0,2,10,1,16384,2,4,7,19,131072,0,29,1,21,0,0,1,4,1,16384,0,6,45,11,131088,0,47,10,1,16384,1,8,4,1,16384,0,6,7,1,16384,0,8,10,6,32768,0,11,20,6,32768,0,21,1,21,0,1,4,7,19,131072,0,38,1,21,0,0,1,7,1,16384,0,9,1,21,0,0,1,7,1,16384,0,9,36,11,131088,3,4,9,19,131072,0,10,18,3,131072,0,19,1,21,0,0,1,4,1,18432,1,4,6,1,16384,0,7,4,6,32768,0,5,1,21,0,0,2,4,2,16384,2,4,6,1,16384,0,7,10,6,32768,0,11,1,21,0,0,2,4,1,16384,1,4,6,1,16384,0,7,11,6,32768,0,12,1,21,0,0,2,19,0,131072,1,4,6,1,16384,0,7,5,6,32768,0,6,1,21,0,1,4,7,19,131072,0,34,1,21,0,0,1,6,1,16384,0,8,1,21,0,0,1,6,1,16384,0,8,36,11,131088,3,4,10,19,131072,0,11,4,2,16384,0,6,6,1,16384,2,4,7,19,131072,0,20,1,21,0,0,1,6,1,16384,0,8,4,2,16384,0,6,1,21,0,0,1,7,1,16384,2,4,7,19,131072,0,29,11,18,65536,0,13,3,2,16384,0,5,4,2,16384,0,6,7,1,16384,2,4,7,19,131072,0,18,11,18,65536,0,12,1,21,0,0,1,3,2,16384,0,5,4,2,16384,0,9,6,1,16384,2,13,1,1,16387,0,7,1,1,16384,0,2,1,21,0,0,2,4,1,16384,0,6,2,21,0,0,2,1,1,16384,1,10,3,1,16387,1,10,1,1,16384,0,2,2,21,0,0,3,7,1,16384,0,8,2,21,0,0,5,23,3,131072,0,24,1,21,0,0,1,3,1,18432,0,5,7,1,16384,0,9,1,1,16384,0,3,2,21,0,0,3,11,11,131088,0,13,2,21,0,0,3,3,1,16384,1,8,10,1,16384,0,11,8,6,32768,0,9,4,6,32768,0,5,1,21,0,0,2,27,11,131088,1,8,10,1,16384,0,11,8,6,32768,0,9,2,6,32768,0,3,1,21,0,0,2,1,1,16384,1,8,10,1,16384,0,11,5,6,32768,0,6,1,21,0,0,2,34,11,131088,1,8,7,19,131072,0,24,11,18,65536,0,12,1,21,0,0,1,3,2,16384,0,5,4,2,16384,0,6,1,21,0,0,1,10,1,16384,3,9,4,23,16384,3,0,8,23,16385,2,2,13,19,131072,0,14,10,3,131072,0,11,3,2,18432,0,5,4,2,16384,0,7,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384,3,0,8,19,131072,0,9,12,10,131072,0,14,11,3,131073,0,19,3,2,16387,1,0,12,10,131072,0,14,11,3,131075,0,18,3,2,16387,1,2,19,19,131072,0,20,11,8,131072,1,2,12,10,131072,0,13,3,1,16387,0,6,11,11,131088,1,6,10,1,16387,2,2,9,19,131072,0,10,13,3,131072,0,14,1,21,0,0,1,10,1,18432,1,4,14,19,131072,1,2,8,18,65536,0,9,6,1,16387,1,6,9,1,16387,2,6,3,2,16384,0,4,2,21,0,0,3,4,19,131072,0,11,8,23,16384,2,6,19,3,131072,0,22,2,21,0,0,3,11,11,131088,0,18,8,23,16384,2,2,11,19,131072,0,41,1,21,0,0,1,6,1,16384,0,8,35,11,131088,0,38,11,18,65536,0,12,3,2,16384,0,6,3,1,16384,0,5,4,23,16384,1,6,5,19,131072,0,25,2,21,0,0,3,4,19,131072,1,4,11,19,131072,0,33,1,21,0,0,1,9,1,16384,0,11,39,11,131088,0,41,6,1,16384,0,9,3,1,16384,0,5,4,23,16384,2,2,13,19,131072,0,14,13,3,131072,0,19,6,1,16384,0,9,3,1,16384,0,5,4,23,16384,1,6,9,1,16384,1,4,13,19,131072,0,14,13,3,65536,0,14,3,2,18432,0,6,3,1,16384,0,5,4,23,16384,1,9,4,23,16384,3,0,8,23,16385,2,2,13,19,131072,0,14,8,3,131072,0,9,3,2,18432,0,6,3,1,16384,0,5,4,23,16384,2,0,4,23,16385,1,2,13,3,131072,0,14,10,1,16384,1,9,3,1,16384,1,0,4,23,16385,1,7,4,23,16384],"resultId":"1"}}

V[15:12:28.823] ASTWorker running DocumentSymbols on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:28.828] --> reply:textDocument/documentSymbol(7) 1325 ms
V[15:12:28.829] >>> {"id":7,"jsonrpc":"2.0","result":[{"detail":"const char *[5]","kind":13,"name":"ncclFuncStr","range":{"end":{"character":114,"line":40},"start":{"character":0,"line":40}},"selectionRange":{"end":{"character":23,"line":40},"start":{"character":12,"line":40}}},{"detail":"const char *[6]","kind":13,"name":"ncclAlgoStr","range":{"end":{"character":118,"line":41},"start":{"character":0,"line":41}},"selectionRange":{"end":{"character":23,"line":41},"start":{"character":12,"line":41}}},{"detail":"const char *[3]","kind":13,"name":"ncclProtoStr","range":{"end":{"character":74,"line":42},"start":{"character":0,"line":42}},"selectionRange":{"end":{"character":24,"line":42},"start":{"character":12,"line":42}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGroupCudaStream","range":{"end":{"character":10,"line":44},"start":{"character":0,"line":44}},"selectionRange":{"end":{"character":10,"line":44},"start":{"character":0,"line":44}}}],"detail":"(GroupCudaStream, \"GROUP_CUDA_STREAM\", NCCL_GROUP_CUDA_STREAM)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":72,"line":44},"start":{"character":0,"line":44}},"selectionRange":{"end":{"character":10,"line":44},"start":{"character":0,"line":44}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCheckPointers","range":{"end":{"character":10,"line":46},"start":{"character":0,"line":46}},"selectionRange":{"end":{"character":10,"line":46},"start":{"character":0,"line":46}}}],"detail":"(CheckPointers, \"CHECK_POINTERS\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":46,"line":46},"start":{"character":0,"line":46}},"selectionRange":{"end":{"character":10,"line":46},"start":{"character":0,"line":46}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCommBlocking","range":{"end":{"character":10,"line":47},"start":{"character":0,"line":47}},"selectionRange":{"end":{"character":10,"line":47},"start":{"character":0,"line":47}}}],"detail":"(CommBlocking, \"COMM_BLOCKING\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":64,"line":47},"start":{"character":0,"line":47}},"selectionRange":{"end":{"character":10,"line":47},"start":{"character":0,"line":47}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commReclaim","range":{"end":{"character":48,"line":49},"start":{"character":0,"line":49}},"selectionRange":{"end":{"character":31,"line":49},"start":{"character":20,"line":49}}},{"detail":"uint64_t (const ncclUniqueId &)","kind":12,"name":"hashUniqueId","range":{"end":{"character":1,"line":60},"start":{"character":0,"line":51}},"selectionRange":{"end":{"character":28,"line":51},"start":{"character":16,"line":51}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGdrCopyEnable","range":{"end":{"character":10,"line":63},"start":{"character":0,"line":63}},"selectionRange":{"end":{"character":10,"line":63},"start":{"character":0,"line":63}}}],"detail":"(GdrCopyEnable, \"GDRCOPY_ENABLE\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":46,"line":63},"start":{"character":0,"line":63}},"selectionRange":{"end":{"character":10,"line":63},"start":{"character":0,"line":63}}},{"detail":"gdr_t","kind":13,"name":"ncclGdrCopy","range":{"end":{"character":24,"line":66},"start":{"character":0,"line":66}},"selectionRange":{"end":{"character":17,"line":66},"start":{"character":6,"line":66}}},{"detail":"ncclResult_t ()","kind":12,"name":"initGdrCopy","range":{"end":{"character":1,"line":73},"start":{"character":0,"line":68}},"selectionRange":{"end":{"character":24,"line":68},"start":{"character":13,"line":68}}},{"detail":"pthread_mutex_t","kind":13,"name":"initLock","range":{"end":{"character":52,"line":75},"start":{"character":0,"line":75}},"selectionRange":{"end":{"character":24,"line":75},"start":{"character":16,"line":75}}},{"detail":"bool","kind":13,"name":"initialized","range":{"end":{"character":31,"line":76},"start":{"character":0,"line":76}},"selectionRange":{"end":{"character":23,"line":76},"start":{"character":12,"line":76}}},{"detail":"ncclResult_t ()","kind":12,"name":"ncclInit","range":{"end":{"character":1,"line":93},"start":{"character":0,"line":78}},"selectionRange":{"end":{"character":28,"line":78},"start":{"character":20,"line":78}}},{"children":[{"detail":"ncclResult_t (int *)","kind":12,"name":"pncclGetVersion","range":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}},"selectionRange":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}}},{"detail":"ncclResult_t (int *)","kind":12,"name":"ncclGetVersion","range":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}},"selectionRange":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}}}],"detail":"(ncclResult_t, ncclGetVersion, int* version)","kind":21,"name":"NCCL_API","range":{"end":{"character":52,"line":95},"start":{"character":0,"line":95}},"selectionRange":{"end":{"character":8,"line":95},"start":{"character":0,"line":95}}},{"detail":"ncclResult_t (int *)","kind":12,"name":"ncclGetVersion","range":{"end":{"character":1,"line":100},"start":{"character":0,"line":96}},"selectionRange":{"end":{"character":27,"line":96},"start":{"character":13,"line":96}}},{"children":[{"detail":"ncclResult_t (ncclUniqueId *)","kind":12,"name":"pncclGetUniqueId","range":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}},"selectionRange":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}}},{"detail":"ncclResult_t (ncclUniqueId *)","kind":12,"name":"ncclGetUniqueId","range":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}},"selectionRange":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}}}],"detail":"(ncclResult_t, ncclGetUniqueId, ncclUniqueId* out)","kind":21,"name":"NCCL_API","range":{"end":{"character":58,"line":102},"start":{"character":0,"line":102}},"selectionRange":{"end":{"character":8,"line":102},"start":{"character":0,"line":102}}},{"detail":"ncclResult_t (ncclUniqueId *)","kind":12,"name":"ncclGetUniqueId","range":{"end":{"character":1,"line":109},"start":{"character":0,"line":103}},"selectionRange":{"end":{"character":28,"line":103},"start":{"character":13,"line":103}}},{"detail":"void (ncclComm_t)","kind":12,"name":"commPoison","range":{"end":{"character":1,"line":122},"start":{"character":0,"line":118}},"selectionRange":{"end":{"character":32,"line":118},"start":{"character":22,"line":118}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnFree","range":{"end":{"character":1,"line":130},"start":{"character":0,"line":127}},"selectionRange":{"end":{"character":40,"line":127},"start":{"character":20,"line":127}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushFree","range":{"end":{"character":1,"line":137},"start":{"character":0,"line":131}},"selectionRange":{"end":{"character":21,"line":131},"start":{"character":5,"line":131}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnCudaFree","range":{"end":{"character":1,"line":142},"start":{"character":0,"line":139}},"selectionRange":{"end":{"character":44,"line":139},"start":{"character":20,"line":139}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushCudaFree","range":{"end":{"character":1,"line":149},"start":{"character":0,"line":143}},"selectionRange":{"end":{"character":25,"line":143},"start":{"character":5,"line":143}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnCudaHostFree","range":{"end":{"character":1,"line":154},"start":{"character":0,"line":151}},"selectionRange":{"end":{"character":48,"line":151},"start":{"character":20,"line":151}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushCudaHostFree","range":{"end":{"character":1,"line":161},"start":{"character":0,"line":155}},"selectionRange":{"end":{"character":29,"line":155},"start":{"character":5,"line":155}}},{"detail":"ncclResult_t (struct ncclDestructor *)","kind":12,"name":"ncclDestructorFnCudaGdrFree","range":{"end":{"character":1,"line":166},"start":{"character":0,"line":163}},"selectionRange":{"end":{"character":47,"line":163},"start":{"character":20,"line":163}}},{"detail":"void (struct ncclComm *, void *)","kind":12,"name":"ncclCommPushCudaGdrFree","range":{"end":{"character":1,"line":173},"start":{"character":0,"line":167}},"selectionRange":{"end":{"character":28,"line":167},"start":{"character":5,"line":167}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commFree","range":{"end":{"character":1,"line":253},"start":{"character":0,"line":175}},"selectionRange":{"end":{"character":28,"line":175},"start":{"character":20,"line":175}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamDisableGraphHelper","range":{"end":{"character":10,"line":255},"start":{"character":0,"line":255}},"selectionRange":{"end":{"character":10,"line":255},"start":{"character":0,"line":255}}}],"detail":"(DisableGraphHelper, \"GRAPH_HELPER_DISABLE\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":57,"line":255},"start":{"character":0,"line":255}},"selectionRange":{"end":{"character":10,"line":255},"start":{"character":0,"line":255}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGdrCopyFifoEnable","range":{"end":{"character":10,"line":257},"start":{"character":0,"line":257}},"selectionRange":{"end":{"character":10,"line":257},"start":{"character":0,"line":257}}}],"detail":"(GdrCopyFifoEnable, \"GDRCOPY_FIFO_ENABLE\", 1)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":55,"line":257},"start":{"character":0,"line":257}},"selectionRange":{"end":{"character":10,"line":257},"start":{"character":0,"line":257}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamWorkFifoDepth","range":{"end":{"character":10,"line":258},"start":{"character":0,"line":258}},"selectionRange":{"end":{"character":10,"line":258},"start":{"character":0,"line":258}}}],"detail":"(WorkFifoDepth, \"WORK_FIFO_DEPTH\", 64<<10)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":52,"line":258},"start":{"character":0,"line":258}},"selectionRange":{"end":{"character":10,"line":258},"start":{"character":0,"line":258}}},{"detail":"enum ncclLaunchMode","kind":13,"name":"ncclParamLaunchMode","range":{"end":{"character":39,"line":259},"start":{"character":0,"line":259}},"selectionRange":{"end":{"character":39,"line":259},"start":{"character":20,"line":259}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamDmaBufEnable","range":{"end":{"character":10,"line":261},"start":{"character":0,"line":261}},"selectionRange":{"end":{"character":10,"line":261},"start":{"character":0,"line":261}}}],"detail":"(DmaBufEnable, \"DMABUF_ENABLE\", 1)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":44,"line":261},"start":{"character":0,"line":261}},"selectionRange":{"end":{"character":10,"line":261},"start":{"character":0,"line":261}}},{"detail":"ncclResult_t (struct ncclComm *)","kind":12,"name":"dmaBufSupported","range":{"end":{"character":1,"line":280},"start":{"character":0,"line":264}},"selectionRange":{"end":{"character":35,"line":264},"start":{"character":20,"line":264}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommEnsureReady","range":{"end":{"character":1,"line":304},"start":{"character":0,"line":282}},"selectionRange":{"end":{"character":32,"line":282},"start":{"character":13,"line":282}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclComm *, int, int)","kind":12,"name":"commAlloc","range":{"end":{"character":1,"line":394},"start":{"character":0,"line":306}},"selectionRange":{"end":{"character":29,"line":306},"start":{"character":20,"line":306}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"devCommSetup","range":{"end":{"character":1,"line":470},"start":{"character":0,"line":396}},"selectionRange":{"end":{"character":32,"line":396},"start":{"character":20,"line":396}}},{"detail":"void ()","kind":12,"name":"showVersion","range":{"end":{"character":1,"line":483},"start":{"character":0,"line":474}},"selectionRange":{"end":{"character":23,"line":474},"start":{"character":12,"line":474}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclPeerInfo *, uint64_t)","kind":12,"name":"fillInfo","range":{"end":{"character":1,"line":523},"start":{"character":0,"line":485}},"selectionRange":{"end":{"character":28,"line":485},"start":{"character":20,"line":485}}},{"detail":"ncclResult_t (struct ncclComm *, int, int, int, int *)","kind":12,"name":"setupChannel","range":{"end":{"character":1,"line":541},"start":{"character":0,"line":525}},"selectionRange":{"end":{"character":32,"line":525},"start":{"character":20,"line":525}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamBuffSize","range":{"end":{"character":10,"line":546},"start":{"character":0,"line":546}},"selectionRange":{"end":{"character":10,"line":546},"start":{"character":0,"line":546}}}],"detail":"(BuffSize, \"BUFFSIZE\", -2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":36,"line":546},"start":{"character":0,"line":546}},"selectionRange":{"end":{"character":10,"line":546},"start":{"character":0,"line":546}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamLlBuffSize","range":{"end":{"character":10,"line":547},"start":{"character":0,"line":547}},"selectionRange":{"end":{"character":10,"line":547},"start":{"character":0,"line":547}}}],"detail":"(LlBuffSize, \"LL_BUFFSIZE\", -2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":41,"line":547},"start":{"character":0,"line":547}},"selectionRange":{"end":{"character":10,"line":547},"start":{"character":0,"line":547}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamLl128BuffSize","range":{"end":{"character":10,"line":548},"start":{"character":0,"line":548}},"selectionRange":{"end":{"character":10,"line":548},"start":{"character":0,"line":548}}}],"detail":"(Ll128BuffSize, \"LL128_BUFFSIZE\", -2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":47,"line":548},"start":{"character":0,"line":548}},"selectionRange":{"end":{"character":10,"line":548},"start":{"character":0,"line":548}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamP2pNetChunkSize","range":{"end":{"character":10,"line":550},"start":{"character":0,"line":550}},"selectionRange":{"end":{"character":10,"line":550},"start":{"character":0,"line":550}}}],"detail":"(P2pNetChunkSize, \"P2P_NET_CHUNKSIZE\", (1 << 17))","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":59,"line":550},"start":{"character":0,"line":550}},"selectionRange":{"end":{"character":10,"line":550},"start":{"character":0,"line":550}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamP2pPciChunkSize","range":{"end":{"character":10,"line":551},"start":{"character":0,"line":551}},"selectionRange":{"end":{"character":10,"line":551},"start":{"character":0,"line":551}}}],"detail":"(P2pPciChunkSize, \"P2P_PCI_CHUNKSIZE\", (1 << 17))","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":59,"line":551},"start":{"character":0,"line":551}},"selectionRange":{"end":{"character":10,"line":551},"start":{"character":0,"line":551}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamP2pNvlChunkSize","range":{"end":{"character":10,"line":552},"start":{"character":0,"line":552}},"selectionRange":{"end":{"character":10,"line":552},"start":{"character":0,"line":552}}}],"detail":"(P2pNvlChunkSize, \"P2P_NVL_CHUNKSIZE\", (1 << 19))","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":59,"line":552},"start":{"character":0,"line":552}},"selectionRange":{"end":{"character":10,"line":552},"start":{"character":0,"line":552}}},{"detail":"ncclResult_t (struct ncclComm *)","kind":12,"name":"computeBuffSizes","range":{"end":{"character":1,"line":581},"start":{"character":0,"line":554}},"selectionRange":{"end":{"character":36,"line":554},"start":{"character":20,"line":554}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamGraphDumpFileRank","range":{"end":{"character":10,"line":583},"start":{"character":0,"line":583}},"selectionRange":{"end":{"character":10,"line":583},"start":{"character":0,"line":583}}}],"detail":"(GraphDumpFileRank, \"GRAPH_DUMP_FILE_RANK\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":56,"line":583},"start":{"character":0,"line":583}},"selectionRange":{"end":{"character":10,"line":583},"start":{"character":0,"line":583}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCollNetNodeThreshold","range":{"end":{"character":10,"line":584},"start":{"character":0,"line":584}},"selectionRange":{"end":{"character":10,"line":584},"start":{"character":0,"line":584}}}],"detail":"(CollNetNodeThreshold, \"COLLNET_NODE_THRESHOLD\", 2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":61,"line":584},"start":{"character":0,"line":584}},"selectionRange":{"end":{"character":10,"line":584},"start":{"character":0,"line":584}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamNvbPreconnect","range":{"end":{"character":10,"line":585},"start":{"character":0,"line":585}},"selectionRange":{"end":{"character":10,"line":585},"start":{"character":0,"line":585}}}],"detail":"(NvbPreconnect, \"NVB_PRECONNECT\", 1)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":46,"line":585},"start":{"character":0,"line":585}},"selectionRange":{"end":{"character":10,"line":585},"start":{"character":0,"line":585}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamAllocP2pNetLLBuffers","range":{"end":{"character":10,"line":586},"start":{"character":0,"line":586}},"selectionRange":{"end":{"character":10,"line":586},"start":{"character":0,"line":586}}}],"detail":"(AllocP2pNetLLBuffers, \"ALLOC_P2P_NET_LL_BUFFERS\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":63,"line":586},"start":{"character":0,"line":586}},"selectionRange":{"end":{"character":10,"line":586},"start":{"character":0,"line":586}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"collNetInitRailRankMap","range":{"end":{"character":1,"line":610},"start":{"character":0,"line":588}},"selectionRange":{"end":{"character":42,"line":588},"start":{"character":20,"line":588}}},{"detail":"ncclResult_t (ncclComm_t, ncclComm_t, struct ncclTopoGraph *)","kind":12,"name":"collNetTrySetup","range":{"end":{"character":1,"line":824},"start":{"character":0,"line":612}},"selectionRange":{"end":{"character":35,"line":612},"start":{"character":20,"line":612}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamMNNVLEnable","range":{"end":{"character":10,"line":827},"start":{"character":0,"line":827}},"selectionRange":{"end":{"character":10,"line":827},"start":{"character":0,"line":827}}}],"detail":"(MNNVLEnable, \"MNNVL_ENABLE\", 2)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":42,"line":827},"start":{"character":0,"line":827}},"selectionRange":{"end":{"character":10,"line":827},"start":{"character":0,"line":827}}},{"detail":"int (struct ncclComm *)","kind":12,"name":"checkMNNVL","range":{"end":{"character":1,"line":886},"start":{"character":0,"line":835}},"selectionRange":{"end":{"character":21,"line":835},"start":{"character":11,"line":835}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclComm *)","kind":12,"name":"initTransportsRank","range":{"end":{"character":1,"line":1427},"start":{"character":0,"line":894}},"selectionRange":{"end":{"character":38,"line":894},"start":{"character":20,"line":894}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamSetStackSize","range":{"end":{"character":10,"line":1429},"start":{"character":0,"line":1429}},"selectionRange":{"end":{"character":10,"line":1429},"start":{"character":0,"line":1429}}}],"detail":"(SetStackSize, \"SET_STACK_SIZE\", 0)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":45,"line":1429},"start":{"character":0,"line":1429}},"selectionRange":{"end":{"character":10,"line":1429},"start":{"character":0,"line":1429}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCGAClusterSize","range":{"end":{"character":10,"line":1430},"start":{"character":0,"line":1430}},"selectionRange":{"end":{"character":10,"line":1430},"start":{"character":0,"line":1430}}}],"detail":"(CGAClusterSize, \"CGA_CLUSTER_SIZE\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":69,"line":1430},"start":{"character":0,"line":1430}},"selectionRange":{"end":{"character":10,"line":1430},"start":{"character":0,"line":1430}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamMaxCTAs","range":{"end":{"character":10,"line":1432},"start":{"character":0,"line":1432}},"selectionRange":{"end":{"character":10,"line":1432},"start":{"character":0,"line":1432}}}],"detail":"(MaxCTAs, \"MAX_CTAS\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":54,"line":1432},"start":{"character":0,"line":1432}},"selectionRange":{"end":{"character":10,"line":1432},"start":{"character":0,"line":1432}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamMinCTAs","range":{"end":{"character":10,"line":1433},"start":{"character":0,"line":1433}},"selectionRange":{"end":{"character":10,"line":1433},"start":{"character":0,"line":1433}}}],"detail":"(MinCTAs, \"MIN_CTAS\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":54,"line":1433},"start":{"character":0,"line":1433}},"selectionRange":{"end":{"character":10,"line":1433},"start":{"character":0,"line":1433}}},{"children":[{"detail":"struct ncclAsyncJob","kind":8,"name":"base","range":{"end":{"character":26,"line":1437},"start":{"character":2,"line":1437}},"selectionRange":{"end":{"character":26,"line":1437},"start":{"character":22,"line":1437}}},{"detail":"struct ncclComm *","kind":8,"name":"comm","range":{"end":{"character":23,"line":1438},"start":{"character":2,"line":1438}},"selectionRange":{"end":{"character":23,"line":1438},"start":{"character":19,"line":1438}}},{"detail":"struct ncclComm **","kind":8,"name":"newcomm","range":{"end":{"character":27,"line":1439},"start":{"character":2,"line":1439}},"selectionRange":{"end":{"character":27,"line":1439},"start":{"character":20,"line":1439}}},{"detail":"int","kind":8,"name":"cudaDev","range":{"end":{"character":13,"line":1440},"start":{"character":2,"line":1440}},"selectionRange":{"end":{"character":13,"line":1440},"start":{"character":6,"line":1440}}},{"detail":"int","kind":8,"name":"nranks","range":{"end":{"character":12,"line":1442},"start":{"character":2,"line":1442}},"selectionRange":{"end":{"character":12,"line":1442},"start":{"character":6,"line":1442}}},{"detail":"int","kind":8,"name":"myrank","range":{"end":{"character":20,"line":1442},"start":{"character":2,"line":1442}},"selectionRange":{"end":{"character":20,"line":1442},"start":{"character":14,"line":1442}}},{"detail":"ncclUniqueId","kind":8,"name":"commId","range":{"end":{"character":21,"line":1443},"start":{"character":2,"line":1443}},"selectionRange":{"end":{"character":21,"line":1443},"start":{"character":15,"line":1443}}},{"detail":"struct ncclComm *","kind":8,"name":"parent","range":{"end":{"character":25,"line":1445},"start":{"character":2,"line":1445}},"selectionRange":{"end":{"character":25,"line":1445},"start":{"character":19,"line":1445}}},{"detail":"int","kind":8,"name":"color","range":{"end":{"character":11,"line":1446},"start":{"character":2,"line":1446}},"selectionRange":{"end":{"character":11,"line":1446},"start":{"character":6,"line":1446}}},{"detail":"int","kind":8,"name":"key","range":{"end":{"character":16,"line":1446},"start":{"character":2,"line":1446}},"selectionRange":{"end":{"character":16,"line":1446},"start":{"character":13,"line":1446}}}],"detail":"struct","kind":23,"name":"ncclCommInitRankAsyncJob","range":{"end":{"character":1,"line":1447},"start":{"character":0,"line":1436}},"selectionRange":{"end":{"character":31,"line":1436},"start":{"character":7,"line":1436}}},{"children":[{"detail":"struct ncclAsyncJob","kind":8,"name":"base","range":{"end":{"character":26,"line":1450},"start":{"character":2,"line":1450}},"selectionRange":{"end":{"character":26,"line":1450},"start":{"character":22,"line":1450}}},{"detail":"ncclComm_t","kind":8,"name":"comm","range":{"end":{"character":17,"line":1451},"start":{"character":2,"line":1451}},"selectionRange":{"end":{"character":17,"line":1451},"start":{"character":13,"line":1451}}}],"detail":"struct","kind":23,"name":"ncclCommFinalizeAsyncJob","range":{"end":{"character":1,"line":1452},"start":{"character":0,"line":1449}},"selectionRange":{"end":{"character":31,"line":1449},"start":{"character":7,"line":1449}}},{"children":[{"detail":"int64_t ()","kind":12,"name":"ncclParamCommSplitShareResources","range":{"end":{"character":10,"line":1454},"start":{"character":0,"line":1454}},"selectionRange":{"end":{"character":10,"line":1454},"start":{"character":0,"line":1454}}}],"detail":"(CommSplitShareResources, \"COMM_SPLIT_SHARE_RESOURCES\", NCCL_CONFIG_UNDEF_INT)","kind":21,"name":"NCCL_PARAM","range":{"end":{"character":88,"line":1454},"start":{"character":0,"line":1454}},"selectionRange":{"end":{"character":10,"line":1454},"start":{"character":0,"line":1454}}},{"detail":"ncclResult_t (struct ncclComm *, struct ncclComm *, int, int, int *, int *, int *)","kind":12,"name":"commGetSplitInfo","range":{"end":{"character":1,"line":1500},"start":{"character":0,"line":1456}},"selectionRange":{"end":{"character":36,"line":1456},"start":{"character":20,"line":1456}}},{"detail":"ncclResult_t (struct ncclAsyncJob *)","kind":12,"name":"ncclCommInitRankFunc","range":{"end":{"character":1,"line":1600},"start":{"character":0,"line":1502}},"selectionRange":{"end":{"character":40,"line":1502},"start":{"character":20,"line":1502}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"envConfigOverride","range":{"end":{"character":1,"line":1680},"start":{"character":0,"line":1609}},"selectionRange":{"end":{"character":37,"line":1609},"start":{"character":20,"line":1609}}},{"detail":"ncclResult_t (ncclComm_t, ncclComm_t)","kind":12,"name":"copyCommConfig","range":{"end":{"character":1,"line":1686},"start":{"character":0,"line":1682}},"selectionRange":{"end":{"character":34,"line":1682},"start":{"character":20,"line":1682}}},{"detail":"ncclResult_t (ncclComm_t, ncclConfig_t *)","kind":12,"name":"parseCommConfig","range":{"end":{"character":1,"line":1771},"start":{"character":0,"line":1688}},"selectionRange":{"end":{"character":35,"line":1688},"start":{"character":20,"line":1688}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, int, ncclConfig_t *)","kind":12,"name":"ncclCommInitRankDev","range":{"end":{"character":1,"line":1825},"start":{"character":0,"line":1773}},"selectionRange":{"end":{"character":39,"line":1773},"start":{"character":20,"line":1773}}},{"children":[{"detail":"int","kind":8,"name":"rank","range":{"end":{"character":10,"line":1829},"start":{"character":2,"line":1829}},"selectionRange":{"end":{"character":10,"line":1829},"start":{"character":6,"line":1829}}},{"detail":"int","kind":8,"name":"nranks","range":{"end":{"character":12,"line":1830},"start":{"character":2,"line":1830}},"selectionRange":{"end":{"character":12,"line":1830},"start":{"character":6,"line":1830}}},{"detail":"int","kind":8,"name":"cudaDev","range":{"end":{"character":13,"line":1831},"start":{"character":2,"line":1831}},"selectionRange":{"end":{"character":13,"line":1831},"start":{"character":6,"line":1831}}}],"detail":"struct","kind":23,"name":"NvtxParamsCommInitRank","range":{"end":{"character":1,"line":1832},"start":{"character":0,"line":1827}},"selectionRange":{"end":{"character":29,"line":1827},"start":{"character":7,"line":1827}}},{"detail":"const nvtxPayloadSchemaEntry_t[3]","kind":13,"name":"CommInitRankSchema","range":{"end":{"character":1,"line":1837},"start":{"character":0,"line":1833}},"selectionRange":{"end":{"character":53,"line":1833},"start":{"character":35,"line":1833}}},{"children":[{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int)","kind":12,"name":"pncclCommInitRank","range":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}},"selectionRange":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int)","kind":12,"name":"ncclCommInitRank","range":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}},"selectionRange":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}}}],"detail":"(ncclResult_t, ncclCommInitRank, ncclComm_t* newcomm, int nranks, ncclUniqueId commId ...)","kind":21,"name":"NCCL_API","range":{"end":{"character":106,"line":1839},"start":{"character":0,"line":1839}},"selectionRange":{"end":{"character":8,"line":1839},"start":{"character":0,"line":1839}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int)","kind":12,"name":"ncclCommInitRank","range":{"end":{"character":1,"line":1853},"start":{"character":0,"line":1840}},"selectionRange":{"end":{"character":29,"line":1840},"start":{"character":13,"line":1840}}},{"children":[{"detail":"ncclResult_t (ncclComm_t *, int, const int *)","kind":12,"name":"pncclCommInitAll","range":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}},"selectionRange":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}}},{"detail":"ncclResult_t (ncclComm_t *, int, const int *)","kind":12,"name":"ncclCommInitAll","range":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}},"selectionRange":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}}}],"detail":"(ncclResult_t, ncclCommInitAll, ncclComm_t* comms, int ndev, const int* devlist)","kind":21,"name":"NCCL_API","range":{"end":{"character":88,"line":1855},"start":{"character":0,"line":1855}},"selectionRange":{"end":{"character":8,"line":1855},"start":{"character":0,"line":1855}}},{"detail":"ncclResult_t (ncclComm_t *, int, const int *)","kind":12,"name":"ncclCommInitAll","range":{"end":{"character":1,"line":1911},"start":{"character":0,"line":1856}},"selectionRange":{"end":{"character":28,"line":1856},"start":{"character":13,"line":1856}}},{"detail":"ncclResult_t (ncclComm_t, ncclResult_t)","kind":12,"name":"ncclCommSetAsyncError","range":{"end":{"character":1,"line":1921},"start":{"character":0,"line":1913}},"selectionRange":{"end":{"character":34,"line":1913},"start":{"character":13,"line":1913}}},{"children":[{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, ncclConfig_t *)","kind":12,"name":"pncclCommInitRankConfig","range":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}},"selectionRange":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, ncclConfig_t *)","kind":12,"name":"ncclCommInitRankConfig","range":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}},"selectionRange":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}}}],"detail":"(ncclResult_t, ncclCommInitRankConfig, ncclComm_t* comm, int nranks, ncclUniqueId ...)","kind":21,"name":"NCCL_API","range":{"end":{"character":131,"line":1923},"start":{"character":0,"line":1923}},"selectionRange":{"end":{"character":8,"line":1923},"start":{"character":0,"line":1923}}},{"detail":"ncclResult_t (ncclComm_t *, int, ncclUniqueId, int, ncclConfig_t *)","kind":12,"name":"ncclCommInitRankConfig","range":{"end":{"character":1,"line":1949},"start":{"character":0,"line":1924}},"selectionRange":{"end":{"character":35,"line":1924},"start":{"character":13,"line":1924}}},{"detail":"ncclResult_t (struct ncclAsyncJob *)","kind":12,"name":"commDestroySync","range":{"end":{"character":1,"line":1984},"start":{"character":0,"line":1951}},"selectionRange":{"end":{"character":35,"line":1951},"start":{"character":20,"line":1951}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commCleanup","range":{"end":{"character":1,"line":2007},"start":{"character":0,"line":1986}},"selectionRange":{"end":{"character":31,"line":1986},"start":{"character":20,"line":1986}}},{"detail":"ncclResult_t (ncclComm_t, bool)","kind":12,"name":"commFinalize","range":{"end":{"character":1,"line":2028},"start":{"character":0,"line":2009}},"selectionRange":{"end":{"character":32,"line":2009},"start":{"character":20,"line":2009}}},{"children":[{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"pncclCommFinalize","range":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}},"selectionRange":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommFinalize","range":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}},"selectionRange":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}}}],"detail":"(ncclResult_t, ncclCommFinalize, ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":57,"line":2030},"start":{"character":0,"line":2030}},"selectionRange":{"end":{"character":8,"line":2030},"start":{"character":0,"line":2030}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommFinalize","range":{"end":{"character":1,"line":2058},"start":{"character":0,"line":2031}},"selectionRange":{"end":{"character":29,"line":2031},"start":{"character":13,"line":2031}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"commReclaim","range":{"end":{"character":1,"line":2142},"start":{"character":0,"line":2060}},"selectionRange":{"end":{"character":31,"line":2060},"start":{"character":20,"line":2060}}},{"children":[{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"pncclCommDestroy","range":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}},"selectionRange":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommDestroy","range":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}},"selectionRange":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}}}],"detail":"(ncclResult_t, ncclCommDestroy, ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":56,"line":2144},"start":{"character":0,"line":2144}},"selectionRange":{"end":{"character":8,"line":2144},"start":{"character":0,"line":2144}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommDestroy","range":{"end":{"character":1,"line":2171},"start":{"character":0,"line":2145}},"selectionRange":{"end":{"character":28,"line":2145},"start":{"character":13,"line":2145}}},{"children":[{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"pncclCommAbort","range":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}},"selectionRange":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommAbort","range":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}},"selectionRange":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}}}],"detail":"(ncclResult_t, ncclCommAbort, ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":54,"line":2173},"start":{"character":0,"line":2173}},"selectionRange":{"end":{"character":8,"line":2173},"start":{"character":0,"line":2173}}},{"detail":"ncclResult_t (ncclComm_t)","kind":12,"name":"ncclCommAbort","range":{"end":{"character":1,"line":2203},"start":{"character":0,"line":2174}},"selectionRange":{"end":{"character":26,"line":2174},"start":{"character":13,"line":2174}}},{"children":[{"detail":"ncclResult_t (ncclComm_t, int, int, ncclComm_t *, ncclConfig_t *)","kind":12,"name":"pncclCommSplit","range":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}},"selectionRange":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}}},{"detail":"ncclResult_t (ncclComm_t, int, int, ncclComm_t *, ncclConfig_t *)","kind":12,"name":"ncclCommSplit","range":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}},"selectionRange":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}}}],"detail":"(ncclResult_t, ncclCommSplit, ncclComm_t comm, int color, int key, ncclComm_t *newcomm ...)","kind":21,"name":"NCCL_API","range":{"end":{"character":117,"line":2205},"start":{"character":0,"line":2205}},"selectionRange":{"end":{"character":8,"line":2205},"start":{"character":0,"line":2205}}},{"detail":"ncclResult_t (ncclComm_t, int, int, ncclComm_t *, ncclConfig_t *)","kind":12,"name":"ncclCommSplit","range":{"end":{"character":1,"line":2268},"start":{"character":0,"line":2206}},"selectionRange":{"end":{"character":26,"line":2206},"start":{"character":13,"line":2206}}},{"children":[{"detail":"const char *(ncclResult_t)","kind":12,"name":"pncclGetErrorString","range":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}},"selectionRange":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}}},{"detail":"const char *(ncclResult_t)","kind":12,"name":"ncclGetErrorString","range":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}},"selectionRange":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}}}],"detail":"(const char*, ncclGetErrorString, ncclResult_t code)","kind":21,"name":"NCCL_API","range":{"end":{"character":60,"line":2270},"start":{"character":0,"line":2270}},"selectionRange":{"end":{"character":8,"line":2270},"start":{"character":0,"line":2270}}},{"detail":"const char *(ncclResult_t)","kind":12,"name":"ncclGetErrorString","range":{"end":{"character":1,"line":2283},"start":{"character":0,"line":2271}},"selectionRange":{"end":{"character":30,"line":2271},"start":{"character":12,"line":2271}}},{"children":[{"detail":"const char *(const ncclComm_t)","kind":12,"name":"pncclGetLastError","range":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}},"selectionRange":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}}},{"detail":"const char *(const ncclComm_t)","kind":12,"name":"ncclGetLastError","range":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}},"selectionRange":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}}}],"detail":"(const char*, ncclGetLastError, const ncclComm_t comm)","kind":21,"name":"NCCL_API","range":{"end":{"character":62,"line":2288},"start":{"character":0,"line":2288}},"selectionRange":{"end":{"character":8,"line":2288},"start":{"character":0,"line":2288}}},{"detail":"const char *(ncclComm_t)","kind":12,"name":"ncclGetLastError","range":{"end":{"character":1,"line":2291},"start":{"character":0,"line":2289}},"selectionRange":{"end":{"character":28,"line":2289},"start":{"character":12,"line":2289}}},{"children":[{"detail":"ncclResult_t (ncclComm_t, ncclResult_t *)","kind":12,"name":"pncclCommGetAsyncError","range":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}},"selectionRange":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}}},{"detail":"ncclResult_t (ncclComm_t, ncclResult_t *)","kind":12,"name":"ncclCommGetAsyncError","range":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}},"selectionRange":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}}}],"detail":"(ncclResult_t, ncclCommGetAsyncError, ncclComm_t comm, ncclResult_t *asyncError)","kind":21,"name":"NCCL_API","range":{"end":{"character":88,"line":2293},"start":{"character":0,"line":2293}},"selectionRange":{"end":{"character":8,"line":2293},"start":{"character":0,"line":2293}}},{"detail":"ncclResult_t (ncclComm_t, ncclResult_t *)","kind":12,"name":"ncclCommGetAsyncError","range":{"end":{"character":1,"line":2301},"start":{"character":0,"line":2294}},"selectionRange":{"end":{"character":34,"line":2294},"start":{"character":13,"line":2294}}},{"children":[{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"pncclCommCount","range":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}},"selectionRange":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCount","range":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}},"selectionRange":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}}}],"detail":"(ncclResult_t, ncclCommCount, const ncclComm_t comm, int* count)","kind":21,"name":"NCCL_API","range":{"end":{"character":72,"line":2303},"start":{"character":0,"line":2303}},"selectionRange":{"end":{"character":8,"line":2303},"start":{"character":0,"line":2303}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCount","range":{"end":{"character":1,"line":2315},"start":{"character":0,"line":2304}},"selectionRange":{"end":{"character":26,"line":2304},"start":{"character":13,"line":2304}}},{"children":[{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"pncclCommCuDevice","range":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}},"selectionRange":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCuDevice","range":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}},"selectionRange":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}}}],"detail":"(ncclResult_t, ncclCommCuDevice, const ncclComm_t comm, int* devid)","kind":21,"name":"NCCL_API","range":{"end":{"character":75,"line":2317},"start":{"character":0,"line":2317}},"selectionRange":{"end":{"character":8,"line":2317},"start":{"character":0,"line":2317}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommCuDevice","range":{"end":{"character":1,"line":2328},"start":{"character":0,"line":2318}},"selectionRange":{"end":{"character":29,"line":2318},"start":{"character":13,"line":2318}}},{"children":[{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"pncclCommUserRank","range":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}},"selectionRange":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommUserRank","range":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}},"selectionRange":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}}}],"detail":"(ncclResult_t, ncclCommUserRank, const ncclComm_t comm, int* rank)","kind":21,"name":"NCCL_API","range":{"end":{"character":74,"line":2330},"start":{"character":0,"line":2330}},"selectionRange":{"end":{"character":8,"line":2330},"start":{"character":0,"line":2330}}},{"detail":"ncclResult_t (const ncclComm_t, int *)","kind":12,"name":"ncclCommUserRank","range":{"end":{"character":1,"line":2341},"start":{"character":0,"line":2331}},"selectionRange":{"end":{"character":29,"line":2331},"start":{"character":13,"line":2331}}},{"children":[{"detail":"ncclResult_t (void **, size_t)","kind":12,"name":"pncclMemAlloc","range":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}},"selectionRange":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}}},{"detail":"ncclResult_t (void **, size_t)","kind":12,"name":"ncclMemAlloc","range":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}},"selectionRange":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}}}],"detail":"(ncclResult_t, ncclMemAlloc, void **ptr, size_t size)","kind":21,"name":"NCCL_API","range":{"end":{"character":61,"line":2343},"start":{"character":0,"line":2343}},"selectionRange":{"end":{"character":8,"line":2343},"start":{"character":0,"line":2343}}},{"detail":"ncclResult_t (void **, size_t)","kind":12,"name":"ncclMemAlloc","range":{"end":{"character":1,"line":2418},"start":{"character":0,"line":2344}},"selectionRange":{"end":{"character":26,"line":2344},"start":{"character":14,"line":2344}}},{"children":[{"detail":"ncclResult_t (void *)","kind":12,"name":"pncclMemFree","range":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}},"selectionRange":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}}},{"detail":"ncclResult_t (void *)","kind":12,"name":"ncclMemFree","range":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}},"selectionRange":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}}}],"detail":"(ncclResult_t, ncclMemFree, void *ptr)","kind":21,"name":"NCCL_API","range":{"end":{"character":46,"line":2420},"start":{"character":0,"line":2420}},"selectionRange":{"end":{"character":8,"line":2420},"start":{"character":0,"line":2420}}},{"detail":"ncclResult_t (void *)","kind":12,"name":"ncclMemFree","range":{"end":{"character":1,"line":2454},"start":{"character":0,"line":2421}},"selectionRange":{"end":{"character":25,"line":2421},"start":{"character":14,"line":2421}}}]}

I[15:12:28.830] --> textDocument/clangd.fileStatus
V[15:12:28.830] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/init.cc"}}

V[15:12:28.841] indexed preamble AST for /root/code/nccl-trace/src/enqueue.cc version 1:
  symbol slab: 21535 symbols, 8096742 bytes
  ref slab: 0 symbols, 0 refs, 128 bytes
  relations slab: 14 relations, 296 bytes
V[15:12:28.942] Build dynamic index for header symbols with estimated memory usage of 18585170 bytes
V[15:12:28.989] Build dynamic index for header symbols with estimated memory usage of 18591515 bytes
V[15:12:29.040] <<< {"id":8,"jsonrpc":"2.0","method":"textDocument/codeAction","params":{"context":{"diagnostics":[],"triggerKind":2},"range":{"end":{"character":28,"line":191},"start":{"character":28,"line":191}},"textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:29.040] <-- textDocument/codeAction(8)
V[15:12:29.040] ASTWorker running codeAction on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:29.041] --> reply:textDocument/codeAction(8) 0 ms
V[15:12:29.041] >>> {"id":8,"jsonrpc":"2.0","result":[]}

I[15:12:29.041] --> textDocument/clangd.fileStatus
V[15:12:29.041] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/init.cc"}}

V[15:12:30.318] <<< {"id":9,"jsonrpc":"2.0","method":"textDocument/semanticTokens/full/delta","params":{"previousResultId":"1","textDocument":{"uri":"file:///root/code/nccl-trace/src/init.cc"}}}

I[15:12:30.318] <-- textDocument/semanticTokens/full/delta(9)
V[15:12:30.318] ASTWorker running SemanticHighlights on version 1 of /root/code/nccl-trace/src/init.cc
I[15:12:30.330] --> reply:textDocument/semanticTokens/full/delta(9) 11 ms
V[15:12:30.330] >>> {"id":9,"jsonrpc":"2.0","result":{"edits":[],"resultId":"2"}}

I[15:12:30.330] --> textDocument/clangd.fileStatus
V[15:12:30.330] >>> {"jsonrpc":"2.0","method":"textDocument/clangd.fileStatus","params":{"state":"idle","uri":"file:///root/code/nccl-trace/src/init.cc"}}
```
